* TASKS
- [-] Enum [9/10]
  - [X] Enum declaration
  - [X] Enum variant node
  - [X] Enum type generation 
  - [X] Enum instance (unitialized) should have first enum value if there is one 
  - [X] Enum unit test 
  - [X] Enum member access 
  - [X] Enum base expression generation (only numbers accepted for now)
  - [X] All expressions passed into evaluation must be validated by check as consts 
  - [ ] Pointer enums are invalid!!! 
  - [X] Check enum non-existing variant expression  
- [-] Struct [8/12]
  - [X] Self containing struct member should generate error: struct a { mem a; } -> leads to endless recursion
  - [X] Member ref expression node 
  - [X] Member ref expression node parsing
  - [X] Struct member node
  - [X] Public and private struct members parsing.
  - [X] Struct member access
  - [X] Handle invalid found types [[file:~/Develop/bl/libbl/src/linker.c::found%20%3D%20satisfy_decl_ref(cnt,%20expr)%3B][here]]
  - [ ] *Member access type checking* [[7][here]]
  - [X] Check if members are in current scope or public [[file:~/Develop/bl/libbl/src/linker.c::satisfy_member(context_t%20*cnt,%20bl_node_t%20*expr)][here]] -> generate error if member is inaccessible  
  - [ ] Initialization expression for struct [[file:~/Develop/bl/libbl/src/parser.c::/*%20TODO:%20parse%20initialization%20expression%20here%20*/][here]] 
  - [ ] Check for recursions over multiple structs struct A { b B } struct B { a A } -> generate error
  - [ ] All public members in structure must have also public types -> print error 
- [-] Array [7/9]
  - [X] Parsing
  - [X] Array elem expression parsing 
  - [X] LLVM generation 
  - [X] Type declaration
  - [ ] Multidimensional arrays??? 
    decl_var should contain array with dimension sizes do recalculate positions later
    -> define helper methods for adding dimensions
  - [ ] Array type checking (size and type) 
  - [X] Use expression reference instead number in [N] 
  - [X] Array definition size as const expr 
  - [X] Handle zero sized arrays -> generate error (in check.c)
- [ ] Casting [0/1]
  - [ ] Parsing
- [ ] For loop [0/1]
  - [ ] Parsing for (i i32 in 0..10) {}
- [X] Global/local const [5/5]
  - [X] Unique node
  - [X] Parsing
  - [X] Visitor and linking
  - [X] Evaluation
  - [X] LLVM generation
- [ ] Variable argument type [0/1]
  - [ ] Parsing
- [-] Other [11/16]
  - [X] Constant "variable" declaration
  - [X] i16 and u16
  - [X] Error when return statement is missing
  - [ ] Improve error checking of return statement (not all path return value error?) 
  - [X] Remove 'ptr' type 
  - [X] Check const = ? -> constants cannot be modified at runtime!!!
  - [X] Improve unit testing 
  - [X] Separate node for func params 
  - [X] Type casting
  - [ ] Single character parsing ('c') 
  - [ ] Linux/MacOS installation in CMAKE
  - [X] Constant expression evaluator
  - [X] Path parsing fix (last node of path must be parsed also) 
  - [ ] Implicit numeric constant casting
  - [ ] Use talloc instead of normal memory allocators
  - [X] Nodes using path should use token of last path element (simple add method -> not use of previous token)
- [-] Unary operator (separate expression node in ast) [3/4]
  - [X] Ast node
  - [X] Parsing
  - [X] Check validity (not valid for struct references)
  - [ ] Evaluation
- [-] Value evaluation [1/2]
  - [ ] String constant evaluation 
  - [X] Evaluate const init expressions 
- [-] Windows port!!! [2/3]
  - [X] BObject compilation
  - [X] LLVM instalation
  - [ ] Linker fix
- [X] Pointer [4/4]
  - [X] Parse unary address-of and dereferencing
  - [X] Pointer type fundamental
  - [X] Pointer type ref
  - [X] -> operator
- [ ] Check [0/2]
  - [ ] Only pointers can have null value
  - [ ] Check numeric limits
- [ ] Set size of size_t by target machine architecture [[file:~/Develop/bl/libbl/src/llvm_generator.c::if%20(sizeof(size_t)%20%3D%3D%204)%20{][here]]  
- [X] Preprocesor #load [4/4]
  - [X] Ast representatio
  - [X] Parsing
  - [X] Duplicit load detection 
  - [X] Search for files in path
- [-] Using [5/8]
  - [X] Ast node for using
  - [X] Duplicity using check 
  - [X] Parsing
  - [X] Global usings valid only in module?
  - [ ] Using inside struct or enum body?
  - [ ] Symbol colisions handling between modules 
  - [ ] Symbol colisions handling between current module and used modules
  - [X] Using must be module or enumerator -> improve checking
- [-] Sizeof buildin [4/5]
  - [X] Ast node
  - [X] Parsing
  - [X] Generation
  - [X] Size_t type 32/64 bit
  - [ ] Evaluation
- [X] Better linker [7/7]
  - [X] Create global root module by default in parser
  - [X] Review module merging
  - [X] Path element validation via validation methods???
  - [X] Symbol inserting in current scope without lookup in tree -> possibility to hide members up the tree 
  - [X] Member access parser + better expression handling 
  - [X] Finalize 
  - [X] Add assembly root module and link it to all unit global modules

* BUGS [2/6]
- [ ] When enumerator variant is used as array size, compiler don't track usage of this enum and warn user about unused declaration.
- [X] Cannot evaluate array size inside structures. 
- [ ] Invalid typecheck for var initializer of enum 'var e Enum = Enum::Foo;'
- [ ] Invalid copying of: rect_src.w = e->rect.w;
- [ ] Wrong parsing of cast expressions cast(i32) foo->i;  
- [X] Unable to return struct member copy from the function

* PIPELINE
** Text (can run in multithread)
   1. file loader
   2. lexer

** Tokens (can run in multithread)
   1. token printer
   2. parser

** AST
   1. preprocessor
   2. merge 
   3. connection 
   4. ast printing 
   5. check
   6. const-expr evaluation

** LLVM
   1. llvm generator
   2. llvm jit execute
   3. llvm byte-code writer
   4. llvm linker
   5. llvm native bin builder
  
* IDEAS
** implicit casting pointer to bool: if (some_PT) {}
** static array
** zero initialized statc arrays??
** statement tagging?

** Casting syntax:
   - cast<i32>(f)
   - f as i32
   - i32(f)
   - cast(i32) f
* NOTES
** global using search return array of all founds references???
