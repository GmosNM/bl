* Documentation for BL-MIR
 BL-MIR (Biscuit Language Middle Intermediate Representation) is a simplified representation of the Biscuit Language created from SAT. It is located between AST and LCM-IR.

** Instructions: 
  
*** block
    Basic block representation.

    #+BEGIN_EXAMPLE
    <name>: 
      %0  s32 const 666
      %1 void ret %0
    #+END_EXAMPLE

*** const
    Constant value.

    #+BEGIN_EXAMPLE
    <T> const <value> // yields constant value of the type T
    #+END_EXAMPLE

    | stack op | data  | description    |
    |----------+-------+----------------|
    | PUSH     | value | constant value |

*** decl
    Variable declaration.

    #+BEGIN_EXAMPLE
    <*T> decl <name> : <T> // yields *T (pointer to value allocated on the stack)
    #+END_EXAMPLE

    | stack op | data | description              |
    |----------+------+--------------------------|
    | PUSH     | -    | storage for the variable |
    
*** load
    Push pointed value on the stack.

    #+BEGIN_EXAMPLE
    <T> load <ptr> // yields T loaded from ptr
    #+END_EXAMPLE

    | stack op | data  | description              |
    |----------+-------+--------------------------|
    | POP      | ptr   | pointer to source        |
    | PUSH     | value | value loaded from source |
    
*** store
    Store value from source to destination address.

    #+BEGIN_EXAMPLE
    void store <src> -> <dest_ptr> // yields void
    #+END_EXAMPLE

    Destination pointer is on the stack:
    | stack op | data     | description            |
    |----------+----------+------------------------|
    | POP      | dest_ptr | pointer to destination |
    | POP      | src_ptr  | value                  |

    Destination pointer is declaration:
    | stack op | data     | description            |
    |----------+----------+------------------------|
    | POP      | src_ptr  | value                  |
    
*** arg
    Load argument of the current function on the stack.

    #+BEGIN_EXAMPLE
    <T> arg $<arg number> // yields T
    #+END_EXAMPLE

    | stack op | data | description |
    |----------+------+-------------|
    | PUSH     | arg  | fn argument |

*** call
    pc   program counter (pointer to current instruction)
    RA   return address (used later for rollback of the stack)

    call fn (1, 2, 3) 4

    | stack op | data        | instr |
    |----------+-------------+-------|
    | PUSH     | 3           | ?     |
    | PUSH     | 2           | ?     |
    | PUSH     | 1           | ?     |
    | PUSH RA  | pc, prev RA | call  |
    | ...      | -           | -     |
    | POP RA   | -           | ret   |
    | POP      | -           | ret   |
    | POP      | -           | ret   |
    | POP      | -           | ret   |
    | PUSH     | 4           | ret   |

*** ret
    Return value from the function and return control to the caller. This instruction terminates current basic block.

    #+BEGIN_EXAMPLE
    void ret [value] // yields void
    #+END_EXAMPLE

    | stack op | data  | description                            |
    |----------+-------+----------------------------------------|
    | POP RA   | -     | rollback the stack to return address   |
    | POP      | arg 1 | clenup fn argument                     |
    | POP      | arg 2 | clenup fn argument                     |
    | PUSH     | value | push call result value if there is one |

*** br
    Breaks to the basic block. This instruction terminates current basic block.

    #+BEGIN_EXAMPLE
    void br <block> // yields void
    #+END_EXAMPLE

*** br (conditional)
    Breaks into then block if the condition is true. This instruction terminates current basic block.

    #+BEGIN_EXAMPLE
    void br <cont> ? <then_block> : <else_block> // yields void
    #+END_EXAMPLE

    | stack op | data      | description       |
    |----------+-----------+-------------------|
    | POP      | condition | checked condition |

*** unreachable
    Abort execution when this instruction is reached.

*** binop
    TODO

*** unop
    TODO

*** elemptr
    TODO
