* Documentation for BL-MIR
 BL-MIR (Biscuit Language Middle Intermediate Representation) is a simplified representation of the Biscuit Language created from SAT. It is located between AST and LCM-IR. 

** Assert function in MIR
 #+BEGIN_EXAMPLE
 @assert fn(bool) void {
 init_0:
   %0              *bool decl cond : bool
   %1               bool arg $0
   %3               void store %1 -> %0
   %11              void br entry_1
 
 entry_1:
   %5               bool load %0
   %6               bool unop !%5
   %7               void br %6 ? if_then_2 : if_else_3
 
 if_then_2:
   %8               void unreachable
   %9               void br if_cont_4
 
 if_else_3:
   %10              void br if_cont_4
 
 if_cont_4:
   %12              void ret
 }
 #+END_EXAMPLE

** Function
   #+BEGIN_EXAMPLE
   @<name> <T> { 
     [entry block]
   }
   #+END_EXAMPLE

** Block
   Basic block representation.

   #+BEGIN_EXAMPLE
   <name>: 
     ...
     <terminal instruction>
   #+END_EXAMPLE

** Instructions: 
  
*** const
    Constant value.

    #+BEGIN_EXAMPLE
    <T> const <value> // yields constant value of the type T
    #+END_EXAMPLE

    | stack op | data  | description    |
    |----------+-------+----------------|
    | PUSH     | value | constant value |

*** decl
    Variable declaration.

    #+BEGIN_EXAMPLE
    <*T> decl <name> : <T> // yields *T (pointer to value allocated on the stack)
    #+END_EXAMPLE

    | stack op | data | description              |
    |----------+------+--------------------------|
    | PUSH     | -    | storage for the variable |
    
*** load
    Push pointed value on the stack.

    #+BEGIN_EXAMPLE
    <T> load <ptr> // yields T loaded from ptr
    #+END_EXAMPLE

    | stack op | data  | description              |
    |----------+-------+--------------------------|
    | POP      | ptr   | pointer to source        |
    | PUSH     | value | value loaded from source |
    
*** store
    Store value from source to destination address.

    #+BEGIN_EXAMPLE
    void store <src> -> <dest_ptr> // yields void
    #+END_EXAMPLE

    Destination pointer is on the stack:
    | stack op | data     | description            |
    |----------+----------+------------------------|
    | POP      | dest_ptr | pointer to destination |
    | POP      | src_ptr  | value                  |

    Destination pointer is declaration:
    | stack op | data     | description            |
    |----------+----------+------------------------|
    | POP      | src_ptr  | value                  |
    
*** arg
    Load argument of the current function on the stack.

    #+BEGIN_EXAMPLE
    <T> arg $<arg number> // yields T
    #+END_EXAMPLE

    | stack op | data | description |
    |----------+------+-------------|
    | PUSH     | arg  | fn argument |

*** call
    pc   program counter (pointer to current instruction)
    RA   return address (used later for rollback of the stack)

    call fn (1, 2, 3) 4

    | stack op | data        | instr |
    |----------+-------------+-------|
    | PUSH     | 3           | ?     |
    | PUSH     | 2           | ?     |
    | PUSH     | 1           | ?     |
    | PUSH RA  | pc, prev RA | call  |
    | ...      | -           | -     |
    | POP RA   | -           | ret   |
    | POP      | -           | ret   |
    | POP      | -           | ret   |
    | POP      | -           | ret   |
    | PUSH     | 4           | ret   |

*** ret
    Return value from the function and return control to the caller. This instruction terminates current basic block.

    #+BEGIN_EXAMPLE
    void ret [value] // yields void
    #+END_EXAMPLE

    | stack op | data  | description                            |
    |----------+-------+----------------------------------------|
    | POP RA   | -     | rollback the stack to return address   |
    | POP      | arg 1 | clenup fn argument                     |
    | POP      | arg 2 | clenup fn argument                     |
    | PUSH     | value | push call result value if there is one |

*** br
    Breaks to the basic block. This instruction terminates current basic block.

    #+BEGIN_EXAMPLE
    void br <block> // yields void
    #+END_EXAMPLE

*** br (conditional)
    Breaks into then block if the condition is true. This instruction terminates current basic block.

    #+BEGIN_EXAMPLE
    void br <cont> ? <then_block> : <else_block> // yields void
    #+END_EXAMPLE

    | stack op | data      | description       |
    |----------+-----------+-------------------|
    | POP      | condition | checked condition |

*** unreachable
    Abort execution when this instruction is reached.

*** binop
    Binary operation.

    #+BEGIN_EXAMPLE
    <T> binop <lhs> <+|-|*|/|%> <rhs> // yields result value of type T
    #+END_EXAMPLE

    | stack op | data   | description                   |
    |----------+--------+-------------------------------|
    | POP      | lhs    | left-hand side of operation   |
    | POP      | rhs    | right-hand side of operation  |
    | PUSH     | result | result value of the operation |

*** unop
    Unary operation.

    #+BEGIN_EXAMPLE
    <T> unop <+|-|*|&> <value> // yields result value of type T
    #+END_EXAMPLE

    | stack op | data   | description                   |
    |----------+--------+-------------------------------|
    | POP      | value  |                               |
    | PUSH     | result | result value of the operation |

*** elemptr
    TODO
