#import "extra/argparse"

Args :: struct {
    cmd: string_view;
    rc: s32;
}

args: Args;

main :: fn () s32 {
	defer std.temporary_release();
    args.rc = 100;
    {
        using argparse;
        parser: Parser;
        init(&parser, "Benchmark runner tool.");
        defer terminate(&parser);
        set_executable_name(&parser, command_line_arguments[0]);
        add_usage(&parser, "--command=<EXECUTABLE> [options]");
        add(&parser, &args.cmd, "--command", "-c", "Command to be executed.", true);
        add(&parser, &args.rc, "--run-count", "-rc", "Count of executions.");
        _, parse_error :: parse(&parser, command_line_arguments);
        if parse_error {
            print_err(parse_error);
            print_help(&parser);
            return 1;
        }
        if parser.help { return 0; }
    }

    cmd :: tprint("\"%\" 1>nul", args.cmd);
    ec := 0;
    runtime_min := 1000000.0;
    runtime_max := 0.001;
    runtime_total := 0.0;
    prev_perc := -1;
    loop i := 0; i < args.rc; i += 1 {
        perc :: cast(s32)((cast(f32) i + 1.f) / cast(f32) args.rc * 100.f);
        if perc != prev_perc {
			print("Run [%%]\n", perc, "%");
            prev_perc = perc;
        }
        measure_elapsed_ms_begin();
        if os_execute(cmd) != 0 { ec += 1; }
        runtime :: measure_elapsed_ms_end();
		runtime_min = std.min(runtime_min, runtime);
		runtime_max = std.max(runtime_max, runtime);
        runtime_total += runtime;
    }
    print("================================================================================\n");
    print(
        "Running:     '%' % times.\n"
        "Failed count: % times.\n"
        "Runtime min:  % ms.\n"
        "Runtime max:  % ms.\n"
        "AVG:          % ms.\n", args.cmd, args.rc, ec, runtime_min, runtime_max, runtime_total / cast(f64) args.rc
        );
    print("================================================================================\n");
    return 0;
}
