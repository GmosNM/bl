#import "std/arg_parser"
#import "std/fs"

ProjKind :: enum {
    Executable;
    Shared;
    CommandLineTool;
}

HELP_TEXT ::
"Generate BL new project.\n"
"Usage:\n"
"  bl-make-project [options] <name>";

// Command line arguments context.
Args :: struct #base ArgCtx {
    proj_dir: string;
    proj_kind: ProjKind;
}

g_args: Args;

main :: fn () s32 {
    _context.print_log_fn = &custom_logger;
    arg_parser :: arg_parser_new(HELP_TEXT);
    defer arg_parser_delete(arg_parser);
    
    arg_parser_add(
        arg_parser,
        "",
        "--dir",
        "Project directory.",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {
            a := cast(*Args) ctx;
            if (args.len < 2) {
                return 0, error("Expected directory name!");
            }
            path := args[1];
            string_replace_all(&path, '\\', '/');
            if (!string_is_empty(path)) && path[path.len-1] == '\"' {
                path[path.len-1] = '\0';
                path.len -= 1;
            }
            a.proj_dir = path;
            is_valid_directory :: fs_is_directory(a.proj_dir);
            if !is_valid_directory {  
                return 0, error("Invalid directory path '%'!", a.proj_dir);
            }
            return 2, ok();
        });
        
     arg_parser_add(
        arg_parser,
        "",
        "--kind=exe",
        "Generate simple executable project (default).",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.proj_kind = ProjKind.Executable;
            return 1, ok();
        });
        
     arg_parser_add(
        arg_parser,
        "",
        "--kind=shared",
        "Generate shared library project.",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.proj_kind = ProjKind.Shared;
            return 1, ok();
        });        
     
     arg_parser_add(
        arg_parser,
        "",
        "--kind=tool",
        "Generate command line tool project.",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.proj_kind = ProjKind.CommandLineTool;
            return 1, ok();
        });        
          
    g_args.proj_dir = ".";   
    state: Error;
    state = arg_parser_run(arg_parser, command_line_arguments, &g_args, 1);
    if !is_ok(state) {
        print_err("%", state);
        arg_parser_print_help(arg_parser);
        return 1;
    }
    if g_args.help { return 0; }
    if g_args.other.len == 0 { 
        print_err("Expected project name!");
        arg_parser_print_help(arg_parser);
        return 1;
    }
    proj_name :: g_args.other[0];
    print_log("Generate project '%' at '%' (%).", proj_name, g_args.proj_dir, g_args.proj_kind); 
    
    return 0;
}

#private
custom_logger :: fn (kind: PrintLogKind, file: string, line: s32, format: string, args: ...) {
    switch kind {
        PrintLogKind.Message { print("  "); }
        PrintLogKind.Warning { print("  [W] "); }
        default { print("  [E] "); }                        
    }
    print(format, args);
    print("\n");
}
