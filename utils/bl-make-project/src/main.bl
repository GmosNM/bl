#import "std/arg_parser"
#import "std/fs"

HELP ::
    "BL project generator.\n"
    "Usage:\n"
    "  bl-make-project [options] <name>"
    ;

MAIN_BODY_EXE :: 
    "main :: fn () s32 {\n"
    "    return 0;\n"
    "}\n"
    ;
    
MAIN_BODY_SHARED :: 
    "my_func :: fn () s32 #export {\n"
    "    return 0;\n"
    "}\n"
    ;
    
MAIN_BODY_CLT :: 
    "#import \"std/arg_parser\"\n"
    "\n"
    "// Command line arguments context.\n"
    "Args :: struct #base ArgCtx {\n"
    "    my_flag: bool;\n"
    "}\n"
    "\n"
    "g_args: Args;\n"
    "\n"
    "main :: fn () s32 {\n"
    "    arg_parser :: arg_parser_new();\n"
    "    defer arg_parser_delete(arg_parser);\n"
    "\n"
    "    // Add new argument.\n"
    "    arg_parser_add(\n"
    "        arg_parser, \n"
    "        \"-f\", // Short name (must start with -)\n"
    "        \"--flag\", // Long name (must start with -)\n"
    "        \"Specify my flag.\", // Help text.\n"
    "        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {\n"
    "            a: *Args = auto ctx;\n"
    "            a.my_flag = true;\n"
    "            return 1, ok(); // Return number of parsed arguments and state.\n"
    "        });\n"
    "\n"
    "    // Start parsing.\n"
    "    state :: arg_parser_run(arg_parser, command_line_arguments, &g_args, 1);\n"
    "    if !is_ok(state) {\n"
    "        print_err(\"%\", state);\n"
    "        arg_parser_print_help(arg_parser);\n"
    "        return 1;\n"
    "    }\n"
    "    if g_args.help { return 0; }\n"
    "    return 0;\n"
    "}"
    ;
    
BUILD_BODY :: // executable/library ; name ; entry
    "build :: fn () #build_entry {\n"
    "    exe :: add_%(\"%\");\n"
    "    set_output_dir(exe, \"bin\");\n"
    "    add_unit(exe, \"%/%\");\n"
    "}\n"
    ;
    
MAIN_FILE :: "main.bl";    
BUILD_FILE :: "build.bl";    
SRC_DIR :: "src";

Args :: struct #base ArgCtx {
    proj_dir: string;
    proj_kind: ProjKind;
}

g_args: Args;

ProjKind :: enum {
    Executable;
    Shared;
    CommandLineTool;
}

main :: fn () s32 {
    _context.print_log_fn = &custom_logger;
    arg_parser :: arg_parser_new(HELP);
    defer arg_parser_delete(arg_parser);
    
    arg_parser_add(
        arg_parser,
        "",
        "--output-dir",
        "Sets the output directory. This is directory in which root project directory will be created.",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {
            a: *Args = auto ctx;
            if (args.len < 2) {
                return 0, error("Expected directory name!");
            }
            a.proj_dir = args[1];
            is_dir, err :: Fs.is_directory(a.proj_dir);
            if (!is_ok(err)) || (!is_dir) { return 0, error("Invalid directory '%'.", a.proj_dir); }
            return 2, ok();
        });
     
     arg_parser_add(
        arg_parser,
        "",
        "--exe",
        "Generate simple executable project (default).",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.proj_kind = ProjKind.Executable;
            return 1, ok();
        });
        
     arg_parser_add(
        arg_parser,
        "",
        "--shared",
        "Generate shared library project.",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.proj_kind = ProjKind.Shared;
            return 1, ok();
        });        
     
     arg_parser_add(
        arg_parser,
        "",
        "--tool",
        "Generate command line tool project.",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.proj_kind = ProjKind.CommandLineTool;
            return 1, ok();
        });        
        
    g_args.proj_dir = ".";
    state: Error;
    
    // Start parsing.
    state = arg_parser_run(arg_parser, command_line_arguments, &g_args, 1);
    if !is_ok(state) {
        print_err("%", state);
        arg_parser_print_help(arg_parser);
        return 1;
    }
    if g_args.help { return 0; }
    if g_args.other.len == 0 {
        print_err("Expected project name!");
        arg_parser_print_help(arg_parser);
        return 1;
    }
    proj_name :: g_args.other[0];
    print_log("Generate new project '%' in '%' (%).", proj_name, g_args.proj_dir, g_args.proj_kind);
    
    proj_root :: sprint(g_args.proj_dir, "/", proj_name);
    proj_src  :: sprint(proj_root, "/", SRC_DIR);
    defer String.delete(proj_src);    
    defer String.delete(proj_root);
    
    // create root directory
    state = Fs.dir_create(proj_root);
    if !is_ok(state) { print_err("%", state); return 1; }

    // create src directory
    state = Fs.dir_create(proj_src);
    if !is_ok(state) { print_err("%", state); return 1; }

    switch g_args.proj_kind {
        ProjKind.Executable {
            proj_main :: sprint(proj_src, "/", MAIN_FILE);
            defer String.delete(proj_main);            
            make_file(proj_main, MAIN_BODY_EXE);
            
            proj_build :: sprint(proj_root, "/", BUILD_FILE);
            defer String.delete(proj_build);            
            make_file(proj_build, BUILD_BODY, "executable", proj_name, SRC_DIR, MAIN_FILE);
        }
        ProjKind.Shared {
            proj_main_filename :: sprint(proj_name, ".bl");
            proj_main :: sprint(proj_src, "/", proj_main_filename);
            defer String.delete(proj_main);            
            defer String.delete(proj_main_filename);            
            make_file(proj_main, MAIN_BODY_SHARED);

            proj_build :: sprint(proj_root, "/", BUILD_FILE);
            defer String.delete(proj_build);            
            make_file(proj_build, BUILD_BODY, "library", proj_name, SRC_DIR, proj_main_filename);

        }
        ProjKind.CommandLineTool {
            proj_main :: sprint(proj_src, "/", MAIN_FILE);
            defer String.delete(proj_main);            
            make_file(proj_main, MAIN_BODY_CLT);

            proj_build :: sprint(proj_root, "/", BUILD_FILE);
            defer String.delete(proj_build);            
            make_file(proj_build, BUILD_BODY, "executable", proj_name, SRC_DIR, MAIN_FILE);
        }
    }

    return 0;
}

make_file :: fn (filepath: string, content: string, args: ...) Error {
    file, err :: Fs.open(filepath, Fs.OpenMode.Write, Fs.OpenMode.Create);
    defer Fs.close(file);
    if !is_ok(err) { return err; }
    Fs.write_fmt(file, content, args);
    return ok();
}

#private
custom_logger :: fn (kind: PrintLogKind, file: string, line: s32, format: string, args: ...) {
    switch kind {
        PrintLogKind.Message { print("  "); }
        PrintLogKind.Warning { print("  [W] "); }
        default { print("  [E] "); }                        
    }    
    print(format, args);
    print("\n");
}