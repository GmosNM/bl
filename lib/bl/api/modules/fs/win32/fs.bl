#load "../shared.bl"

fs_exist :: fn (filepath: string) bool #inline {
    return _PathFileExistsA(auto filepath.ptr) > 0;
}

fs_file_open :: fn (handle: *FSFile, filepath: string, mode: ...FSFileOpenMode) FSError {
    if !handle { return FSError.InvalidInput; }
    if string_is_empty(filepath) { return FSError.InvalidInput; }
    access :: modes_to_flags(mode);
    tmp :: _CreateFile(auto filepath.ptr, access, 0, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null);
    if tmp == WIN32_INVALID_HANDLE_VALUE {
        return error();                
    }
    ^handle = tmp;
    return FSError.OK;
}

fs_file_create :: fn (handle: *FSFile, filepath: string, mode: ...FSFileOpenMode) FSError {
    if !handle { return FSError.InvalidInput; }
    if string_is_empty(filepath) { return FSError.InvalidInput; }
    access :: modes_to_flags(mode);
    tmp :: _CreateFile(auto filepath.ptr, access, 0, null, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, null);
    if tmp == WIN32_INVALID_HANDLE_VALUE {
        return error();                
    }
    ^handle = tmp;
    return FSError.OK;
}

fs_file_delete :: fn (filepath: string) bool #inline {
    if string_is_empty(filepath) { return false; }
    tmp :: _DeleteFileA(auto filepath.ptr);
    if tmp == 0 { return false; }
    return true;
}

fs_file_close :: fn (handle: FSFile) {
    _CloseHandle(handle);
}

// @DOC, @INCOMPLETE
//fs_read :: fn (handle: FSFile) string {
//    size: WIN32_LARGE_INTEGER #noinit;
//    if _GetFileSizeEx(auto handle, &size) == 0 {
//        // error;
//        panic();
//    }
//    print("Size: %B\n", size);
//    return "";
//}

fs_pwd :: fn () string #inline {
    buf: [OS_PATH_MAX]u8;
    written :: _GetCurrentDirectoryA(auto buf.len, auto buf.ptr);
    if written == 0 { return string_new(); }
    out :: string_new(buf.ptr);
    string_replace_all(&out, '\\', '/');
    return out;
}

fs_home :: fn () string #inline {
    tmp :: "USERPROFILE";
    cdir :: getenv(tmp.ptr);
    if !cdir { return string_new(); }
    return string_new(cdir);
}

fs_tmp :: fn () string #inline {
    buf: [OS_PATH_MAX]u8;
    written :: _GetTempPathA(auto buf.len, auto buf.ptr);
    if written == 0 { return string_new(); }
    out :: string_new(buf.ptr);
    string_replace_all(&out, '\\', '/');
    return out;
}

fs_normalize :: fn (filepath: *string) bool {
    buf : [OS_PATH_MAX]u8 #noinit;
    if _GetFullPathNameA(auto filepath.ptr, auto buf.len, buf.ptr, null) > 0 {
//        if win32_PathFileExistsA(auto filepath.ptr) == 0 { return false; }
        string_clear(filepath);
        string_append(filepath, cstr_to_str(buf.ptr));
        string_replace_all(filepath, '\\', '/');
        return true;
    }
    return false;
}

fs_remove_extension :: fn (filename: string) string #inline {
    if string_is_empty(filename) { return string_empty; }
    tmp := filename;
    tmp.len = 0;
    loop i := 0; i < filename.len; i += 1 {
        c :: filename[i];
        if c == '.' && i > 0 { break; }
        tmp.len += 1;
    }
    return tmp;
}

fs_get_extension :: fn (filename: string) string #inline {
    if string_is_empty(filename) { return string_empty; }
    if filename[0] == '.' {
        if filename.len == 1 { return string_empty; }
        filename.len -= 1; filename.ptr = &filename[1]; 
    }
    rhs: string;
    if string_split_by_first(filename, '.', null, &rhs) {
        return rhs;
    }
    return string_empty;
}

#private
GENERIC_READ : u32 : 0x80000000;
GENERIC_WRITE : u32 : 0x40000000;

CREATE_NEW : u32 : 1;
CREATE_ALWAYS : u32 : 2;
OPEN_EXISTING : u32 : 3;
OPEN_ALWAYS : u32 : 4;
TRUNCATE_EXISTING : u32 : 5;

FILE_ATTRIBUTE_NORMAL : u32 : 0x00000080;

ERROR_FILE_NOT_FOUND :: 2;
ERROR_FILE_EXISTS :: 80;
ERROR_ACCESS_DENIED  :: 5;

modes_to_flags :: fn (modes: []FSFileOpenMode) u32 #inline {
    if modes.len == 0 { return GENERIC_READ | GENERIC_WRITE; }
    flags: u32;
    loop i := 0; i < modes.len; i += 1 {
        switch modes[i] {
            FSFileOpenMode.Read    { flags = flags | GENERIC_READ;  }            
            FSFileOpenMode.Write   { flags = flags | GENERIC_WRITE; }
            default { panic(); }
        }
    }
    return flags;
}

error :: fn () FSError #inline {
    ec :: _GetLastError();
    switch ec {
        0                    { return FSError.OK;           }
        ERROR_FILE_NOT_FOUND { return FSError.NotFound;     }
        ERROR_FILE_EXISTS    { return FSError.AlreadyExist; }
        ERROR_ACCESS_DENIED  { return FSError.AccessDenied; }
        default { return FSError.Unknown; }
    }
}

getenv :: fn (name: *u8) *u8 #extern;
_GetLastError :: fn () WIN32_DWORD #extern "GetLastError";
_PathFileExistsA :: fn (pszPath: WIN32_LPCSTR) WIN32_BOOL #extern "PathFileExistsA";
_GetFullPathNameA :: fn (lpFileName: WIN32_LPCSTR,
                        nBufferLength: WIN32_DWORD,
                        lpBuffer: WIN32_LPSTR,
                        lpFilePart: *WIN32_LPSTR
) WIN32_DWORD #extern "GetFullPathNameA";
_CreateFile :: fn (
    lpFileName: WIN32_LPCSTR,
    dwDesiredAccess: WIN32_DWORD,
    dwShareMode: WIN32_DWORD,
    lpSecurityAttributes: WIN32_LPSECURITY_ATTRIBUTES,
    dwCreationDisposition: WIN32_DWORD,
    dwFlagsAndAttributes: WIN32_DWORD,
    hTemplateFile: WIN32_HANDLE
) *u8 #extern "CreateFileA"; 
_CloseHandle :: fn (hObject: WIN32_HANDLE) WIN32_BOOL #extern "CloseHandle";
_GetTempPathA :: fn (nBufferLength: WIN32_DWORD, lpBuffer: WIN32_LPSTR) WIN32_DWORD #extern "GetTempPathA";
_DeleteFileA :: fn (lpFileName: WIN32_LPCSTR) WIN32_BOOL #extern "DeleteFileA";
_GetCurrentDirectoryA :: fn (nBufferLength: WIN32_DWORD, lpBuffer: WIN32_LPSTR) WIN32_DWORD #extern "GetCurrentDirectoryA";
_GetFileSizeEx :: fn (hFile: WIN32_HANDLE, lpFileSize: WIN32_PLARGE_INTEGER) WIN32_BOOL #extern "GetFileSizeEx";