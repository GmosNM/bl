#load "../shared.bl"

// TODO
// file_read_buffer
// create_dir
// open_dir
// list_dir
// rename
// is_path_valid

FSFile :: *u8;
FSFileInvalid : FSFile : null;

fs_exist :: fn (filepath: string) bool #inline {
    if filepath.len == 0 { return false; }
    return _PathFileExistsA(auto filepath.ptr) > 0;
}

fs_file_open :: fn (filepath: string, mode: ...FSFileOpenMode) (FSFile, FSError) {
    if string_is_empty(filepath) { return null, FSError.InvalidInput; }
    access :: modes_to_flags(mode);
    handle :: _CreateFile(auto filepath.ptr, access, 0, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null);
    if handle == WIN32_INVALID_HANDLE_VALUE {
        return null, error();                
    }
    return handle, FSError.OK;
}

fs_file_create :: fn (filepath: string, mode: ...FSFileOpenMode) (FSFile, FSError) {
    if string_is_empty(filepath) { return null, FSError.InvalidInput; }
    access :: modes_to_flags(mode);
    handle :: _CreateFile(auto filepath.ptr, access, 0, null, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, null);
    if handle == WIN32_INVALID_HANDLE_VALUE {
        return null, error();                
    }
    return handle, FSError.OK;
}

fs_file_delete :: fn (filepath: string) bool #inline {
    if string_is_empty(filepath) { return false; }
    tmp :: _DeleteFileA(auto filepath.ptr);
    if tmp == 0 { return false; }
    return true;
}

fs_file_close :: fn (handle: FSFile) #inline {
    if !handle { return; }
    _CloseHandle(handle);
}

fs_file_read :: fn (handle: FSFile) (string, FSError) {
    size: WIN32_LARGE_INTEGER #noinit;
    if _GetFileSizeEx(auto handle, &size) == 0 {
        return string_empty, error();                
    }
    buf := string_new(cast(usize) size);
    if _ReadFile(handle, buf.ptr, auto size, null, null) == 0 {
        string_delete(buf);
        return string_empty, error();                
    }
    buf.len = size;
    return buf, FSError.OK;
}

// @DOC
fs_file_read_slice :: fn (handle: FSFile) ([]u8, FSError) {
    size: WIN32_LARGE_INTEGER #noinit;
    invalid: []u8;
    if _GetFileSizeEx(auto handle, &size) == 0 {
        return invalid, error();                
    }
    buf: []u8;
    slice_init(buf, size);
    if _ReadFile(handle, buf.ptr, auto size, null, null) == 0 {
        slice_terminate(buf);
        return invalid, error();                
    }
    buf.len = size;
    return buf, FSError.OK;
}

fs_validate_filename :: fn (name: string) bool {
    if name.len == 0 { return false; }
    invalid :: "<>:\"/\\|?*\t";
    loop i := 0; i < invalid.len; i += 1 {
        if string_count(name, invalid[i]) > 0 { return false; }
    }
    return true;
}

fs_cwd :: fn () string #inline {
    buf: [OS_PATH_MAX]u8;
    written :: _GetCurrentDirectoryA(auto buf.len, auto buf.ptr);
    if written == 0 { return string_new(); }
    out :: string_new(buf.ptr);
    string_replace_all(&out, '\\', '/');
    return out;
}

fs_home :: fn () string #inline {
    tmp :: "USERPROFILE";
    cdir :: getenv(tmp.ptr);
    if !cdir { return string_new(); }
    return string_new(cdir);
}

fs_tmp :: fn () string #inline {
    buf: [OS_PATH_MAX]u8;
    written :: _GetTempPathA(auto buf.len, auto buf.ptr);
    if written == 0 { return string_new(); }
    out :: string_new(buf.ptr);
    string_replace_all(&out, '\\', '/');
    return out;
}

fs_normalize :: fn (filepath: *string) bool {
    buf : [OS_PATH_MAX]u8 #noinit;
    if _GetFullPathNameA(auto filepath.ptr, auto buf.len, buf.ptr, null) > 0 {
        if win32_PathFileExistsA(auto filepath.ptr) == 0 { return false; }
        string_clear(filepath);
        string_append(filepath, cstr_to_str(buf.ptr));
        string_replace_all(filepath, '\\', '/');
        return true;
    }
    return false;
}

fs_remove_extension :: fn (filename: string) string #inline {
    if string_is_empty(filename) { return string_empty; }
    tmp := filename;
    tmp.len = 0;
    loop i := 0; i < filename.len; i += 1 {
        c :: filename[i];
        if c == '.' && i > 0 { break; }
        tmp.len += 1;
    }
    return tmp;
}

fs_get_extension :: fn (filename: string) string #inline {
    if string_is_empty(filename) { return string_empty; }
    if filename[0] == '.' {
        if filename.len == 1 { return string_empty; }
        filename.len -= 1; filename.ptr = &filename[1]; 
    }
    rhs: string;
    if string_split_by_first(filename, '.', null, &rhs) {
        return rhs;
    }
    return string_empty;
}

#private
GENERIC_READ : u32 : 0x80000000;
GENERIC_WRITE : u32 : 0x40000000;

CREATE_NEW : u32 : 1;
CREATE_ALWAYS : u32 : 2;
OPEN_EXISTING : u32 : 3;
OPEN_ALWAYS : u32 : 4;
TRUNCATE_EXISTING : u32 : 5;

FILE_ATTRIBUTE_NORMAL : u32 : 0x00000080;

ERROR_FILE_NOT_FOUND :: 2;
ERROR_FILE_EXISTS :: 80;
ERROR_ACCESS_DENIED  :: 5;
ERROR_INVALID_HANDLE :: 6;

modes_to_flags :: fn (modes: []FSFileOpenMode) u32 #inline {
    if modes.len == 0 { return GENERIC_READ | GENERIC_WRITE; }
    flags: u32;
    loop i := 0; i < modes.len; i += 1 {
        switch modes[i] {
            FSFileOpenMode.Read    { flags = flags | GENERIC_READ;  }            
            FSFileOpenMode.Write   { flags = flags | GENERIC_WRITE; }
            default { panic(); }
        }
    }
    return flags;
}

error :: fn () FSError #inline {
    ec :: _GetLastError();
    switch ec {
        0                    { return FSError.OK;            }
        ERROR_FILE_NOT_FOUND { return FSError.NotFound;      }
        ERROR_FILE_EXISTS    { return FSError.AlreadyExist;  }
        ERROR_ACCESS_DENIED  { return FSError.AccessDenied;  }
        ERROR_INVALID_HANDLE { return FSError.InvalidHandle; }
        default { return FSError.Unknown; }
    }
}

getenv :: fn (name: *u8) *u8 #extern;
_GetLastError :: fn () WIN32_DWORD #extern "GetLastError";
_PathFileExistsA :: fn (pszPath: WIN32_LPCSTR) WIN32_BOOL #extern "PathFileExistsA";
_GetFullPathNameA :: fn (lpFileName: WIN32_LPCSTR,
                        nBufferLength: WIN32_DWORD,
                        lpBuffer: WIN32_LPSTR,
                        lpFilePart: *WIN32_LPSTR
) WIN32_DWORD #extern "GetFullPathNameA";
_CreateFile :: fn (
    lpFileName: WIN32_LPCSTR,
    dwDesiredAccess: WIN32_DWORD,
    dwShareMode: WIN32_DWORD,
    lpSecurityAttributes: WIN32_LPSECURITY_ATTRIBUTES,
    dwCreationDisposition: WIN32_DWORD,
    dwFlagsAndAttributes: WIN32_DWORD,
    hTemplateFile: WIN32_HANDLE
) *u8 #extern "CreateFileA"; 
_CloseHandle :: fn (hObject: WIN32_HANDLE) WIN32_BOOL #extern "CloseHandle";
_GetTempPathA :: fn (nBufferLength: WIN32_DWORD, lpBuffer: WIN32_LPSTR) WIN32_DWORD #extern "GetTempPathA";
_DeleteFileA :: fn (lpFileName: WIN32_LPCSTR) WIN32_BOOL #extern "DeleteFileA";
_GetCurrentDirectoryA :: fn (nBufferLength: WIN32_DWORD, lpBuffer: WIN32_LPSTR) WIN32_DWORD #extern "GetCurrentDirectoryA";
_GetFileSizeEx :: fn (hFile: WIN32_HANDLE, lpFileSize: WIN32_PLARGE_INTEGER) WIN32_BOOL #extern "GetFileSizeEx";
_ReadFile :: fn (hFile: WIN32_HANDLE, lpBuffer: WIN32_LPVOID, nNumberOfBytesToRead: WIN32_DWORD, lpNumberOfBytesRead: WIN32_LPDWORD, lpOverlapped: WIN32_LPOVERLAPPED) WIN32_BOOL #extern "ReadFile";