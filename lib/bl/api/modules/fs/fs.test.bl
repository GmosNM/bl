#load "std/test.bl"
#load "std/debug_allocator.bl"

#import "fs"

main :: fn () s32 {
    dbgalloc_init();
    defer dbgalloc_terminate();
    return test_run();    
}

#private
get_dummy_filepath :: fn () string {
    tmp :: fs_tmp();
    string_concatenate(&tmp, "/", "deleteme.txt");
    return tmp;
}

fs_exist_test :: fn () #test {
    test_true(fs_exist(#file));
    test_false(fs_exist("foobar"));
}

fs_home_test :: fn () #test {
    tmp :: fs_home();
    defer string_delete(tmp);
    test_neq(tmp, string_empty);
    test_true(fs_exist(tmp));
}

fs_tmp_test :: fn () #test {
    tmp :: fs_tmp();
    defer string_delete(tmp);
    test_neq(tmp, string_empty);
    test_true(fs_exist(tmp));    
}

fs_cwd_test :: fn () #test {
    tmp :: fs_cwd();
    defer string_delete(tmp);
    test_neq(tmp, string_empty);
    test_true(fs_exist(tmp));    
}

fs_file_open_test :: fn () #test {
    {
        file, err :: fs_file_open("");
        test_true(err == ERR_INVALID_INPUT);    
    }
    
    {
        file, err :: fs_file_open("foobar");
        test_true(err == ERR_NOT_FOUND);
    }
    
    {
        file, err :: fs_file_open(#file);    
        test_true(err == OK);
        fs_file_close(file);
    }
}

fs_file_create_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer string_delete(filepath);
    
    fs_file_delete(filepath);
    
    {
        file, err :: fs_file_create("");
        test_true(err == ERR_INVALID_INPUT);    
    }
    
    {
        file, err :: fs_file_create(#file);
        test_true(err == ERR_ALREADY_EXIST);
    }
    
    {
        file, err :: fs_file_create(filepath);
        test_true(err == OK);
        fs_file_close(file);
    }    
    
    fs_file_delete(filepath);
}

fs_file_read_string_test :: fn () #test {
    file, err1 :: fs_file_open(#file, FSFileOpenMode.Read);
    defer fs_file_close(file);
    test_true(err1 == OK);
    data, err2 := fs_file_read_string(file);
    test_true(err2 == OK);
    defer string_delete(data);
    test_neq(data, string_empty);
    data.len += 1;
    test_true(data[data.len-1] == '\0');
}

fs_file_read_string_test2 :: fn () #test {
    data, err := fs_file_read_string(FS_FILE_INVALID);
    test_true(err == ERR_INVALID_HANDLE);
}

fs_file_read_slice_test :: fn () #test {
    file :: fs_file_open(#file, FSFileOpenMode.Read);
    defer fs_file_close(file);
    data, err := fs_file_read_slice(file);
    test_true(err == OK);
    defer slice_terminate(data);
    test_not_null(data.ptr);
    test_neq(data.len, 0);
}

fs_validate_filename_test :: fn () #test {
    if OS_KIND == OSKind.Windows {
        test_false(fs_validate_filename("<"));
        test_false(fs_validate_filename(">"));
        test_false(fs_validate_filename(":")); 
        test_false(fs_validate_filename("\""));     
        test_false(fs_validate_filename("/"));
        test_false(fs_validate_filename("\\"));
        test_false(fs_validate_filename("|")); 
        test_false(fs_validate_filename("?"));        
        test_false(fs_validate_filename("*"));
        test_false(fs_validate_filename("\t"));
        test_false(fs_validate_filename("foo<"));
        test_true(fs_validate_filename("foo_bar-File.txt"));
    } else {
        test_false(fs_validate_filename("foo/"));
        test_true(fs_validate_filename("foo_bar-File.txt"));
    }
}

fs_get_extension_test :: fn () #test {
    {
        filename :: "foo.bar";
        ext      :: fs_get_extension(filename);
        test_eq(ext, "bar");
    }
    {
        filename :: "foo.bar.bar";
        ext      :: fs_get_extension(filename);
        test_eq(ext, "bar.bar");
    }
    {
        filename :: "";
        ext      :: fs_get_extension(filename);
        test_eq(ext, string_empty);
    }    
    {
        filename :: ".";
        ext      :: fs_get_extension(filename);
        test_eq(ext, string_empty);
    }
    {
        filename :: ".foo";
        ext      :: fs_get_extension(filename);
        test_eq(ext, string_empty);
    }
    {
        filename :: ".foo.bar";
        ext      :: fs_get_extension(filename);
        test_eq(ext, "bar");
    }
    {
        filename :: ".foo.bar.bar";
        ext      :: fs_get_extension(filename);
        test_eq(ext, "bar.bar");
    }        
}

fs_remove_extension_test :: fn () #test {
    {
        filename :: "foo.bar";
        ext      :: fs_remove_extension(filename);
        test_eq(ext, "foo");
    }
    {
        filename :: "foo.bar.bar";
        ext      :: fs_remove_extension(filename);
        test_eq(ext, "foo");
    }
    {
        filename :: "";
        ext      :: fs_remove_extension(filename);
        test_eq(ext, string_empty);
    }    
    {
        filename :: ".";
        ext      :: fs_remove_extension(filename);
        test_eq(ext, ".");
    }
    {
        filename :: ".foo";
        ext      :: fs_remove_extension(filename);
        test_eq(ext, ".foo");
    }
    {
        filename :: ".foo.bar";
        ext      :: fs_remove_extension(filename);
        test_eq(ext, ".foo");
    }
    {
        filename :: ".foo.bar.bar";
        ext      :: fs_remove_extension(filename);
        test_eq(ext, ".foo");
    }
}

fs_normalize_test :: fn () #test {
    {
        cwd :: fs_cwd();
        defer string_delete(cwd);
        parent: string;
        test_true(string_split_by_last(cwd, '/', &parent, null));
        filepath :: string_new("..");
        defer string_delete(filepath);
        test_true(fs_normalize(&filepath));
        test_eq(filepath, parent);
    }
    {
        cwd :: fs_cwd();
        defer string_delete(cwd);
        filepath :: string_new(".");
        defer string_delete(filepath);
        test_true(fs_normalize(&filepath));
        test_eq(filepath, cwd);
    }    
    {
        file :: fs_file_create("foo");
        fs_file_close(file);
        defer fs_file_delete("foo");
        cwd :: fs_cwd();
        defer string_delete(cwd);    
        filepath :: string_new("foo");
        string_concatenate(&cwd, "/", filepath);
        defer string_delete(filepath);
        test_true(fs_normalize(&filepath));
        test_eq(filepath, cwd);
    }    
}

fs_file_delete_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer string_delete(filepath);
    
    fs_file_delete(filepath);
    file, err :: fs_file_create(filepath);
    test_true(err == OK);
    fs_file_close(file);
    test_true(fs_file_delete(filepath));
}

fs_file_size_test :: fn () #test {
    file :: fs_file_open(#file);
    defer fs_file_close(file);
    size, err :: fs_file_size(file);
    test_true(err == OK);
    test_true(size > 0);
}

fs_file_read_test :: fn () #test {
    file :: fs_file_open(#file);
    defer fs_file_close(file);
    buf: [1042]u8 #noinit;
    bytes, err :: fs_file_read(file, buf.ptr, buf.len);
    test_true(err == OK);
    test_eq(bytes, buf.len);
}

fs_file_read_buffer_test2 :: fn () #test {
    buf: [1042]u8 #noinit;
    bytes, err :: fs_file_read(FS_FILE_INVALID, buf.ptr, buf.len);
    test_true(err == ERR_INVALID_HANDLE);
    test_eq(bytes, 0);
}

fs_file_read_buffer_test3 :: fn () #test {
    file :: fs_file_open(#file);
    defer fs_file_close(file);
    bytes, err :: fs_file_read(file, null, 0);
    test_true(err == ERR_INVALID_HANDLE);
    test_eq(bytes, 0);
}

fs_file_read_test4 :: fn () #test {
    file :: fs_file_open(#file);
    defer fs_file_close(file);
    buf: [1024]u8 #noinit;
    bytes, err :: fs_file_read(file, buf.ptr, 100);
    test_true(err == OK);
    test_eq(bytes, 100);
}

fs_file_write_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer string_delete(filepath);
    fs_file_delete(filepath);
    content :: "Hello I'm cool file content!";    
    
    { // write
        file :: fs_file_create(filepath);
        written, err :: fs_file_write(file, content.ptr, content.len);
        test_true(err == OK);
        test_eq(written, content.len);
        fs_file_close(file);
    }
    { // read
        file :: fs_file_open(filepath);
        tmp, err :: fs_file_read_string(file);
        test_true(err == OK);
        defer string_delete(tmp);
        test_eq(tmp, content);
        fs_file_close(file);
    }
    fs_file_delete(filepath);
}

fs_file_write_string_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer string_delete(filepath);
    fs_file_delete(filepath);
    content :: "Hello I'm cool file content!";    
    
    { // write
        file :: fs_file_create(filepath);
        written, err :: fs_file_write_string(file, content);
        test_true(err == OK);
        test_eq(written, content.len);
        fs_file_close(file);
    }
    { // read
        file :: fs_file_open(filepath);
        tmp, err :: fs_file_read_string(file);
        test_true(err == OK);
        defer string_delete(tmp);
        test_eq(tmp, content);
        fs_file_close(file);
    }
    fs_file_delete(filepath);
}

fs_file_write_slice_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer string_delete(filepath);
    fs_file_delete(filepath);
    content :: {:[5]u8: 'H', 'e', 'l', 'o', 'o' };
    
    { // write
        file :: fs_file_create(filepath);
        written, err :: fs_file_write_slice(file, content);
        test_true(err == OK);
        test_eq(written, content.len);
        fs_file_close(file);
    }
    { // read
        file :: fs_file_open(filepath);
        tmp, err :: fs_file_read_string(file);
        test_true(err == OK);
        defer string_delete(tmp);
        test_eq(tmp.len, content.len);
        fs_file_close(file);
    }
    fs_file_delete(filepath);
}