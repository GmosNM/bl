#load "os/linux/error.bl"
#load "os/linux/errno.bl"
#load "os/linux/fcntl.bl"
#load "os/linux/stat.bl"
#load "os/posix/unistd.bl"
#load "libc.bl"
#load "../shared.bl"

FSFile :: s64;
FS_FILE_INVALID : FSFile : -1;

fs_exist :: fn (filepath: string) bool #inline {
    if filepath.len == 0 { return false; }
    tmp: _Stat;
    return _stat(auto filepath.ptr, &tmp) == 0;
}

fs_file_open :: fn (filepath: string, mode: ...FSFileOpenMode) (FSFile, FSError) {
    if string_is_empty(filepath) { return 0, FSError.InvalidInput; }
    flags := modes_to_flags(mode);
    handle :: _open(auto filepath.ptr, flags);
    if handle == -1 { // error
        return 0, error();
    }    
    return handle, FSError.OK;   
}

fs_file_create :: fn (filepath: string, mode: ...FSFileOpenMode) (FSFile, FSError) {
    if string_is_empty(filepath) { return 0, FSError.InvalidInput; }
    flags := modes_to_flags(mode) | _O_CREAT | _O_EXCL;
    handle :: _open(auto filepath.ptr, flags);
    if handle == -1 { // error
        return 0, error();
    }    
    return handle, FSError.OK;
}

fs_file_delete :: fn (filepath: string) bool #inline {
    if string_is_empty(filepath) { return false; }
    return _unlink(auto filepath.ptr) == 0;
}

fs_file_close :: fn (handle: FSFile) #inline {
    _close(auto handle);
}

fs_file_read :: fn (handle: FSFile) (string, FSError) {
    tmp: _Stat;
    if _fstat(auto handle, &tmp) != 0 {
        return string_empty, error();
    }
    size :: tmp.st_size;
    buf := string_new(cast(usize) size);
    read :: _read(auto handle, auto buf.ptr, auto size);
    if read < 0 { 
        string_delete(buf);
        return string_empty, error();
    }
    buf.len = auto read;
    return buf, FSError.OK;
}

fs_file_read_slice :: fn (handle: FSFile) ([]u8, FSError) {
    tmp: _Stat;
    invalid: []u8;
    if _fstat(auto handle, &tmp) != 0 {
        return invalid, error();
    }
    size :: tmp.st_size;
    buf: []u8;
    slice_init(buf, size);
    read :: _read(auto handle, auto buf.ptr, auto size);
    if read < 0 { 
        slice_terminate(buf);
        return invalid, error();
    }
    buf.len = auto read;
    return buf, FSError.OK;
}

fs_validate_filename :: fn (name: string) bool {
    if name.len == 0 { return false; }
    invalid :: "/";
    loop i := 0; i < invalid.len; i += 1 {
        if string_count(name, invalid[i]) > 0 { return false; }
    }
    return true;
}

fs_cwd :: fn () string #inline {
    buf: [OS_PATH_MAX]u8;
    if !_getcwd(auto buf.ptr, auto buf.len) { return string_new(); }
    return string_new(buf.ptr);
}

fs_home :: fn () string #inline {
    tmp :: "HOME";
    cdir :: cast(*u8) c_getenv(auto tmp.ptr);
    if !cdir { return string_new(); }
    return string_new(cdir);
}

fs_tmp :: fn () string #inline {
    tmp :: "TMPDIR";
    cdir :: cast(*u8) c_getenv(auto tmp.ptr);
    if !cdir { return string_new("/tmp"); }
    return string_new(cdir);
}

fs_normalize :: fn (filepath: *string) bool {
    buf : [OS_PATH_MAX]u8;
    if !c_realpath(auto filepath.ptr, auto buf.ptr) {
        return false;
    }
    string_clear(filepath);
    string_append(filepath, cstr_to_str(buf.ptr));
    return true;
}

fs_remove_extension :: fn (filename: string) string #inline {
    if string_is_empty(filename) { return string_empty; }
    tmp := filename;
    tmp.len = 0;
    loop i := 0; i < filename.len; i += 1 {
        c :: filename[i];
        if c == '.' && i > 0 { break; }
        tmp.len += 1;
    }
    return tmp;
}

fs_get_extension :: fn (filename: string) string #inline {
    if string_is_empty(filename) { return string_empty; }
    if filename[0] == '.' {
        if filename.len == 1 { return string_empty; }
        filename.len -= 1; filename.ptr = &filename[1]; 
    }
    rhs: string;
    if string_split_by_first(filename, '.', null, &rhs) {
        return rhs;
    }
    return string_empty;
}

#private
modes_to_flags :: fn (modes: []FSFileOpenMode) s32 #inline {
    if modes.len == 0 { return _O_RDWR; }
    r, w := false;
    loop i := 0; i < modes.len; i += 1 {
        switch modes[i] {
            FSFileOpenMode.Read    { r = true; }
            FSFileOpenMode.Write   { w = true; }
            default { panic(); }
        }
    }
    if w && (!r) { return _O_WRONLY; }
    if r && (!w) { return _O_RDONLY; }
    return _O_RDWR;
}

error :: fn () FSError #inline {
    ec :: _errno();
    switch ec {
        0       { return FSError.OK;            }
        _ENOENT { return FSError.NotFound;      }
        _EEXIST { return FSError.AlreadyExist;  }
        _EACCES { return FSError.AccessDenied;  }
        _EBADF  { return FSError.InvalidHandle; }
        default { return FSError.Unknown; }
    }
}

