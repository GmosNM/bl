#import "extra/gl"

#scope glwindow

//! # GLWindow
//!
//! `#import "extra/glwindow"`
//!
//! !!! warning
//!     This module is currently available only for Windows.
//!
//! Set of tools to handle creation of the operating system native window with OpenGL context and its user inputs (like keyboard and mouse).
//! Since the OpenGL context is set globally only one window can be created right now.
//!
//! The window creation does not cover OpenGL initialization, since its API must be loaded dynamically in runtime, thus the `gl_init` must
//! be called after a window is successfully created (the propper context is set).

Window :: win32.HWND;

EventKind :: enum {
    QUIT;

    MOUSE_LB_DOWN;
    MOUSE_LB_UP;
    MOUSE_MB_DOWN;
    MOUSE_MB_UP;
    MOUSE_RB_DOWN;
    MOUSE_RB_UP;
    MOUSE_MOVE;

    KEY_PRESS;
    KEY_RELEASE;
}

KEY_LBUTTON      : u32 : 0x01;
KEY_RBUTTON      : u32 : 0x02;
KEY_CANCEL       : u32 : 0x03;
KEY_BACK         : u32 : 0x08;
KEY_TAB          : u32 : 0x09;
KEY_CLEAR        : u32 : 0x0C;
KEY_RETURN       : u32 : 0x0D;
KEY_SHIFT        : u32 : 0x10;
KEY_CONTROL      : u32 : 0x11;
KEY_MENU         : u32 : 0x12;
KEY_PAUSE        : u32 : 0x13;
KEY_CAPITAL      : u32 : 0x14;
KEY_KANA         : u32 : 0x15;
KEY_HANGEUL      : u32 : 0x15;
KEY_HANGUL       : u32 : 0x15;
KEY_IME_ON       : u32 : 0x16;
KEY_JUNJA        : u32 : 0x17;
KEY_FINAL        : u32 : 0x18;
KEY_HANJA        : u32 : 0x19;
KEY_KANJI        : u32 : 0x19;
KEY_IME_OFF      : u32 : 0x1A;
KEY_ESCAPE       : u32 : 0x1B;
KEY_CONVERT      : u32 : 0x1C;
KEY_NONCONVERT   : u32 : 0x1D;
KEY_ACCEPT       : u32 : 0x1E;
KEY_MODECHANGE   : u32 : 0x1F;
KEY_SPACE        : u32 : 0x20;
KEY_PRIOR        : u32 : 0x21;
KEY_NEXT         : u32 : 0x22;
KEY_END          : u32 : 0x23;
KEY_HOME         : u32 : 0x24;
KEY_LEFT         : u32 : 0x25;
KEY_UP           : u32 : 0x26;
KEY_RIGHT        : u32 : 0x27;
KEY_DOWN         : u32 : 0x28;
KEY_SELECT       : u32 : 0x29;
KEY_PRINT        : u32 : 0x2A;
KEY_EXECUTE      : u32 : 0x2B;
KEY_SNAPSHOT     : u32 : 0x2C;
KEY_INSERT       : u32 : 0x2D;
KEY_DELETE       : u32 : 0x2E;
KEY_HELP         : u32 : 0x2F;
KEY_LWIN         : u32 : 0x5B;
KEY_RWIN         : u32 : 0x5C;
KEY_APPS         : u32 : 0x5D;
KEY_SLEEP        : u32 : 0x5F;
KEY_NUMPAD0      : u32 : 0x60;
KEY_NUMPAD1      : u32 : 0x61;
KEY_NUMPAD2      : u32 : 0x62;
KEY_NUMPAD3      : u32 : 0x63;
KEY_NUMPAD4      : u32 : 0x64;
KEY_NUMPAD5      : u32 : 0x65;
KEY_NUMPAD6      : u32 : 0x66;
KEY_NUMPAD7      : u32 : 0x67;
KEY_NUMPAD8      : u32 : 0x68;
KEY_NUMPAD9      : u32 : 0x69;
KEY_MULTIPLY     : u32 : 0x6A;
KEY_ADD          : u32 : 0x6B;
KEY_SEPARATOR    : u32 : 0x6C;
KEY_SUBTRACT     : u32 : 0x6D;
KEY_DECIMAL      : u32 : 0x6E;
KEY_DIVIDE       : u32 : 0x6F;
KEY_F1           : u32 : 0x70;
KEY_F2           : u32 : 0x71;
KEY_F3           : u32 : 0x72;
KEY_F4           : u32 : 0x73;
KEY_F5           : u32 : 0x74;
KEY_F6           : u32 : 0x75;
KEY_F7           : u32 : 0x76;
KEY_F8           : u32 : 0x77;
KEY_F9           : u32 : 0x78;
KEY_F10          : u32 : 0x79;
KEY_F11          : u32 : 0x7A;
KEY_F12          : u32 : 0x7B;
KEY_F13          : u32 : 0x7C;
KEY_F14          : u32 : 0x7D;
KEY_F15          : u32 : 0x7E;
KEY_F16          : u32 : 0x7F;
KEY_F17          : u32 : 0x80;
KEY_F18          : u32 : 0x81;
KEY_F19          : u32 : 0x82;
KEY_F20          : u32 : 0x83;
KEY_F21          : u32 : 0x84;
KEY_F22          : u32 : 0x85;
KEY_F23          : u32 : 0x86;
KEY_F24          : u32 : 0x87;
KEY_0            : u32 : 0x30;
KEY_1            : u32 : 0x31;
KEY_2            : u32 : 0x32;
KEY_3            : u32 : 0x33;
KEY_4            : u32 : 0x34;
KEY_5            : u32 : 0x35;
KEY_6            : u32 : 0x36;
KEY_7            : u32 : 0x37;
KEY_8            : u32 : 0x38;
KEY_9            : u32 : 0x39;
KEY_A            : u32 : 0x41;
KEY_B            : u32 : 0x42;
KEY_C            : u32 : 0x43;
KEY_D            : u32 : 0x44;
KEY_E            : u32 : 0x45;
KEY_F            : u32 : 0x46;
KEY_G            : u32 : 0x47;
KEY_H            : u32 : 0x48;
KEY_I            : u32 : 0x49;
KEY_J            : u32 : 0x4a;
KEY_K            : u32 : 0x4b;
KEY_L            : u32 : 0x4c;
KEY_M            : u32 : 0x4d;
KEY_N            : u32 : 0x4e;
KEY_O            : u32 : 0x4f;
KEY_P            : u32 : 0x50;
KEY_Q            : u32 : 0x51;
KEY_R            : u32 : 0x52;
KEY_S            : u32 : 0x53;
KEY_T            : u32 : 0x54;
KEY_U            : u32 : 0x55;
KEY_V            : u32 : 0x56;
KEY_W            : u32 : 0x57;
KEY_X            : u32 : 0x58;
KEY_Y            : u32 : 0x59;
KEY_Z            : u32 : 0x5a;

/// General window event representation.
Event :: struct {
    /// Window event [kind](#draweventkind).
    kind: EventKind;
    /// Window which recieved this event.
    sender: Window;
    /// Event related data
    data: union {
        /// Related to MOUSE_MOVE event.
        mouse_move: struct { x: s32; y: s32; };
        /// Related to KEY_* events.
        key_code: u32;
    }
}

frame_events: [..]Event;

init :: fn () {
    using win32;
    SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
}

terminate :: fn () {
    array_terminate(&frame_events);
}

/// Window initialization options. Use [make_default_create_window_options](#glwindowmake_default_create_window_options) to
/// create default options.
CreateWindowOptions :: struct {
    /// Window title text shown in the title bar.
    title: string_view;
    /// Window width in pixels. (Must be greater than 0.)
    width: s32;
    /// Window height in pixels. (Must be greater than 0.)
    height: s32;
    /// Window initial X position in pixels.
    position_x: s32;
    /// Window initial Y position in pixels.
    position_y: s32;
    /// Required OpenGL major version.
    gl_major_version: s32;
    /// Required OpenGL minor version.
    gl_minor_version: s32;
    // @Incomplete: pixel formats, multisampling
}

/// Creates instance of default [CreateWindowOptions](#drawcreatewindowoptions)
make_default_create_window_options :: fn () CreateWindowOptions #inline {
    return CreateWindowOptions.{
        title            = "OpenGL Window",
        width            = 800,
        height           = 600,
        position_x       = win32.CW_USEDEFAULT,
        position_y       = win32.CW_USEDEFAULT,
        gl_major_version = 3,
        gl_minor_version = 3,
    };
}

/// Create a new instance of window with OpenGL buffer initialized; the OpenGL API initialization must be handled
/// explicitly on caller side with `gl_init` and `gl_terminate`.
create_window :: fn (options: *CreateWindowOptions) (Window, Error) {
    using win32;
    assert(options.width * options.height > 0, "Invalid window size requested!");

    window_class :: WNDCLASSEXA.{
        cbSize        = auto sizeof(WNDCLASSEXA),
        style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC,
        lpfnWndProc   = &window_procedure,
        hCursor       = LoadCursorA(null, IDC_ARROW),
        lpszClassName = std.strtoc("GlWindowClass"),
    };
    if RegisterClassExA(&window_class) == 0 {
        return null, error("Failed to register window.");
    }

    fake_window := CreateWindowA(
        window_class.lpszClassName,
        std.strtoc("Fake"),
        WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
        0, 0,
        1, 1,
        null, null, null, null);

    if !fake_window {
        return null, error("Failed to create window.");
    }

    fake_device_context :: GetDC(fake_window);
    fake_pixel_format_descriptor :: PIXELFORMATDESCRIPTOR.{
        nSize = auto sizeof(PIXELFORMATDESCRIPTOR),
        nVersion = 1,
        dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        iPixelType = auto PFD_TYPE_RGBA,
        cColorBits = 32,
        cAlphaBits = 8,
        cDepthBits = 24,
    };

    fake_pixel_format :: ChoosePixelFormat(fake_device_context, &fake_pixel_format_descriptor);
    if fake_pixel_format == 0 {
        return null, error("Cannot setup pixel format.");
    }

    if SetPixelFormat(fake_device_context, fake_pixel_format, &fake_pixel_format_descriptor) == 0 {
        return null, error("Cannot setup pixel format.");
    }

    fake_render_context :: wglCreateContext(fake_device_context);
    if !fake_render_context {
        return null, error("Cannot create OpenGL render context.");
    }
    if wglMakeCurrent(fake_device_context, fake_render_context) == 0 {
        return null, error("Cannot make current OpenGL render context.");
    }

    wgl_init();

    window_style :: WS_CAPTION | WS_SYSMENU | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
    window_rect := RECT.{ right = options.width, bottom = options.height };
    AdjustWindowRect(&window_rect, window_style, 0);

    window := CreateWindowA(
        window_class.lpszClassName,
        std.strtoc(options.title),
        window_style,
        options.position_x, options.position_y,
        window_rect.right  - window_rect.left,
        window_rect.bottom - window_rect.top,
        null, null, null, null);

    if !window {
        return null, error("Failed to create window.");
    }

    device_context :: GetDC(window);

    // @Incomplete: Those things should be configurable.
    pixel_attributes :: [23]s32.{
        WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
        WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
        WGL_DOUBLE_BUFFER_ARB, GL_TRUE,
        WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
        WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,
        WGL_COLOR_BITS_ARB, 32,
        WGL_ALPHA_BITS_ARB, 8,
        WGL_DEPTH_BITS_ARB, 24,
        WGL_STENCIL_BITS_ARB, 8,
        WGL_SAMPLE_BUFFERS_ARB, GL_TRUE,
        WGL_SAMPLES_ARB, 4,
        0
    };

    pixel_format_id: s32;
    num_formats: u32;
    status :: wgl.ChoosePixelFormatARB(device_context, pixel_attributes.ptr, null, 1, &pixel_format_id, &num_formats);
    if status == 0 || num_formats == 0 {
        return null, error("Cannot choose pixel format.");
    }

    pixel_format_descriptor: PIXELFORMATDESCRIPTOR;
    DescribePixelFormat(device_context, pixel_format_id, auto sizeof(pixel_format_descriptor), &pixel_format_descriptor);
    SetPixelFormat(device_context, pixel_format_id, &pixel_format_descriptor);

    context_attributes :: [7]s32.{
        WGL_CONTEXT_MAJOR_VERSION_ARB, options.gl_major_version,
        WGL_CONTEXT_MINOR_VERSION_ARB, options.gl_minor_version,
        WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
        0
    };

    render_context :: wgl.CreateContextAttribsARB(device_context, null, context_attributes.ptr);
    if !render_context {
        return null, error("Cannot create render context, requested OpenGL version is: %.%. (The version is not supported on current system or it's missing from the options.)", options.gl_major_version, options.gl_minor_version);
    }

    wglMakeCurrent(null, null);
    wglDeleteContext(fake_render_context);
    ReleaseDC(fake_window, fake_device_context);
    DestroyWindow(fake_window);
    if wglMakeCurrent(device_context, render_context) == 0 {
        return null, error("Cannot make current render context.");
    }

    ShowWindow(window, 1);
    return window, OK;
}

/// Destroy window created by [create_window](#drawcreate_window).
destroy_window :: fn (window: Window) {
    using win32;
    if !window { return; }
    DestroyWindow(window);
}

/// Swaps current buffers (presents changes to the window's OpenGL viewport).
swap_buffers :: fn (window: Window) #inline {
    using win32;
    assert(window);
    SwapBuffers(GetDC(window));
}

poll_window_events :: fn () {
    using win32;
    array_clear(&frame_events);

    msg: MSG;
    loop PeekMessageA(&msg, null, 0, 0, PM_REMOVE) != 0 {
        TranslateMessage(&msg);
        DispatchMessageA(&msg);
    }
}

#private

window_procedure :: fn (window: win32.HWND, msg: win32.UINT, wparam: win32.WPARAM, lparam: win32.LPARAM) *s32 {
    using win32;
    using EventKind;

    event: *Event;

    switch msg {
        WM_CLOSE         { event = array_push(&frame_events, Event.{ kind = QUIT });           }

        WM_LBUTTONDOWN   { event = array_push(&frame_events, Event.{ kind = MOUSE_LB_DOWN});   }
        WM_LBUTTONUP     { event = array_push(&frame_events, Event.{ kind = MOUSE_LB_UP});     }
        WM_MBUTTONDOWN   { event = array_push(&frame_events, Event.{ kind = MOUSE_MB_DOWN});   }
        WM_MBUTTONUP     { event = array_push(&frame_events, Event.{ kind = MOUSE_MB_UP});     }
        WM_RBUTTONDOWN   { event = array_push(&frame_events, Event.{ kind = MOUSE_RB_DOWN});   }
        WM_RBUTTONUP     { event = array_push(&frame_events, Event.{ kind = MOUSE_RB_UP});     }
        WM_MOUSEMOVE     {
            data: Event.data;
            data.mouse_move.x = GET_X_LPARAM(lparam);
            data.mouse_move.y = GET_Y_LPARAM(lparam);
            event = array_push(&frame_events, Event.{ kind = MOUSE_MOVE, data = data });
        }

        WM_KEYDOWN {
            data: Event.data;
            data.key_code = cast(u32) wparam;
            event = array_push(&frame_events, Event.{ kind = KEY_PRESS, data = data });
        }

        WM_KEYUP {
            data: Event.data;
            data.key_code = cast(u32) wparam;
            event = array_push(&frame_events, Event.{ kind = KEY_RELEASE, data = data });
        }

        default { return win32.DefWindowProcA(window, msg, wparam, lparam); }
    }

    assert(event);
    event.sender = window;
    return null; // null means handled
}
