// =================================================================================================
// bl
//
// File:   windows_api.bl 
// Author: Martin Dorazil
// Date:   26/2/20
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

#scope win32

TRUE :: 1;
FALSE :: 0;
MAX_PATH :: 260;
INVALID_HANDLE_VALUE :: cast(HANDLE) (cast(LONG_PTR)0xffffffffffffffff);
INFINITE : u32 : 0xFFFFFFFF;

STD_INPUT_HANDLE :: cast(DWORD) -10;
STD_OUTPUT_HANDLE :: cast(DWORD) -11;
STD_ERROR_HANDLE :: cast(DWORD) -12;


ERROR_FILE_NOT_FOUND :: 2;
ERROR_FILE_EXISTS :: 80;
ERROR_ACCESS_DENIED  :: 5;
ERROR_INVALID_HANDLE :: 6;
ERROR_DIRECTORY :: 267;
CP_UTF8 : u32 : 65001;
WCHAR        :: *C.ushort;
LPWSTR       :: *C.ushort;
LPCWSTR      :: *C.ushort;
LPCSTR       :: *C.char;
LPSTR        :: *C.char;
LPCTSTR      :: *C.uchar;
PCSTR        :: *C.char;
PCHAR        :: *C.char;
HLOCAL       :: *C.uchar;
UINT         :: C.uint;
DWORD        :: C.uint;
PDWORD       :: *DWORD;
LPCCH        :: C.uchar;
LPCWCH       :: C.ushort;
LPBOOL       :: C.int;
HMODULE      :: *C.uchar;
BOOL         :: C.int;
PBOOL        :: *BOOL;
FARPROC      :: *C.uchar; 
LPVOID       :: *C.uchar; 
LPOVERLAPPED :: *OVERLAPPED;
LPDWORD      :: *DWORD;
HANDLE       :: *C.uchar;
HCURSOR      :: C.void_ptr;
HINSTANCE    :: C.void_ptr;
ULONG        :: C.ulong;
ULONG_PTR    :: *ULONG;
ULONG64      :: *s64;
SIZE_T       :: C.ulong;
PVOID        :: *C.uchar; 
CHAR         :: C.uchar; 
LONG_PTR     :: *C.long;
UINT_PTR     :: *C.uint;
LARGE_INTEGER :: C.longlong;
PLARGE_INTEGER :: *LARGE_INTEGER;
LONG         :: C.long;
LONGLONG     :: C.longlong;
PLONG        :: *LONG;
WORD         :: C.ushort;
LPARAM       :: LONG_PTR;
WPARAM       :: UINT_PTR;
LRESULT      :: LONG_PTR;
DWORD64      :: s64;
PDWORD64     :: *DWORD64;
BYTE         :: u8;
PROC         :: *u8;

HGLOBAL      :: C.void_ptr;
HWND         :: C.void_ptr;
HDC          :: C.void_ptr;
HGLRC        :: C.void_ptr;

GENERIC_READ : u32 : 0x80000000;
GENERIC_WRITE : u32 : 0x40000000;
FILE_BEGIN : u32 : 0;
FILE_CURRENT : u32: 1;
FILE_END : u32 : 2;
CREATE_NEW : u32 : 1;
CREATE_ALWAYS : u32 : 2;
OPEN_EXISTING : u32 : 3;
OPEN_ALWAYS : u32 : 4;
TRUNCATE_EXISTING : u32 : 5;
LPOVERLAPPED_COMPLETION_ROUTINE :: * fn(dwErrorCode: DWORD, dwNumberOfBytesTransfered: DWORD, lpOverlapped: LPOVERLAPPED);
LPOFNHOOKPROC :: *fn (_1: HWND, _2: UINT, _3: WPARAM, _4: LPARAM) UINT_PTR;
FILE_ADD_FILE             : u32 : 0x0002;
FILE_ADD_SUBDIRECTORY     : u32 : 0x0004;
FILE_APPEND_DATA          : u32 : 0x0004;
FILE_ATTRIBUTE_ARCHIVE : u32 : 0x00000020;
FILE_ATTRIBUTE_COMPRESSED : u32 : 0x00000800;
FILE_ATTRIBUTE_DEVICE : u32 : 0x00000040;
FILE_ATTRIBUTE_DIRECTORY : u32 : 0x00000010;
FILE_ATTRIBUTE_ENCRYPTED : u32 : 0x00004000;
FILE_ATTRIBUTE_HIDDEN : u32 : 0x00000002;
FILE_ATTRIBUTE_NORMAL : u32 : 0x00000080;
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED : u32 : 0x00002000;
FILE_ATTRIBUTE_OFFLINE : u32 : 0x00001000;
FILE_ATTRIBUTE_READONLY : u32 : 0x00000001;
FILE_ATTRIBUTE_REPARSE_POINT : u32 : 0x00000400;
FILE_ATTRIBUTE_SPARSE_FILE : u32 : 0x00000200;
FILE_ATTRIBUTE_SYSTEM : u32 : 0x00000004;
FILE_ATTRIBUTE_TEMPORARY : u32 : 0x00000100;
FILE_ATTRIBUTE_VIRTUAL : u32 : 0x00010000;
FILE_CREATE_PIPE_INSTANCE : u32 : 0x0004;
FILE_FLAG_BACKUP_SEMANTICS    : u32 :  0x02000000;
FILE_FLAG_DELETE_ON_CLOSE     : u32 :  0x04000000;
FILE_FLAG_FIRST_PIPE_INSTANCE : u32 :  0x00080000;
FILE_FLAG_NO_BUFFERING        : u32 :  0x20000000;
FILE_FLAG_OPEN_NO_RECALL      : u32 :  0x00100000;
FILE_FLAG_OPEN_REPARSE_POINT  : u32 :  0x00200000;
FILE_FLAG_OVERLAPPED          : u32 :  0x40000000;
FILE_FLAG_POSIX_SEMANTICS     : u32 :  0x01000000;
FILE_FLAG_RANDOM_ACCESS       : u32 :  0x10000000;
FILE_FLAG_SEQUENTIAL_SCAN     : u32 :  0x08000000;
FILE_FLAG_SESSION_AWARE       : u32 :  0x00800000;
FILE_FLAG_WRITE_THROUGH       : u32 :  0x80000000;
FILE_LIST_DIRECTORY       : u32 : 0x0001;
FILE_READ_DATA            : u32 : 0x0001;
FILE_SHARE_DELETE : u32 : 0x00000004;
FILE_SHARE_READ   : u32 : 0x00000001;
FILE_SHARE_WRITE  : u32 : 0x00000002;
FILE_WRITE_DATA           : u32 : 0x0002;
GHND : u32 : 0x0042;
GMEM_FIXED : u32 : 0x0000;
GMEM_MOVEABLE : u32 : 0x0002;
GMEM_ZEROINIT : u32 : 0x0040;
GPTR : u32 : 0x0040;
CF_TEXT : u32 : 1;
FILE_NOTIFY_CHANGE_FILE_NAME : u32 : 0x00000001;
FILE_NOTIFY_CHANGE_DIR_NAME : u32 : 0x00000002;
FILE_NOTIFY_CHANGE_ATTRIBUTES : u32 : 0x00000004;
FILE_NOTIFY_CHANGE_SIZE : u32 : 0x00000008;
FILE_NOTIFY_CHANGE_LAST_WRITE : u32 : 0x00000010;
FILE_NOTIFY_CHANGE_LAST_ACCESS : u32 : 0x00000020;
FILE_NOTIFY_CHANGE_CREATION : u32 : 0x00000040;
FILE_NOTIFY_CHANGE_SECURITY : u32 : 0x00000100;

OFN_READONLY             : u32 :    0x00000001;
OFN_OVERWRITEPROMPT      : u32 :    0x00000002;
OFN_HIDEREADONLY         : u32 :    0x00000004;
OFN_NOCHANGEDIR          : u32 :    0x00000008;
OFN_SHOWHELP             : u32 :    0x00000010;
OFN_ENABLEHOOK           : u32 :    0x00000020;
OFN_ENABLETEMPLATE       : u32 :    0x00000040;
OFN_ENABLETEMPLATEHANDLE : u32 :    0x00000080;
OFN_NOVALIDATE           : u32 :    0x00000100;
OFN_ALLOWMULTISELECT     : u32 :    0x00000200;
OFN_EXTENSIONDIFFERENT   : u32 :    0x00000400;
OFN_PATHMUSTEXIST        : u32 :    0x00000800;
OFN_FILEMUSTEXIST        : u32 :    0x00001000;
OFN_CREATEPROMPT         : u32 :    0x00002000;
OFN_SHAREAWARE           : u32 :    0x00004000;
OFN_NOREADONLYRETURN     : u32 :    0x00008000;
OFN_NOTESTFILECREATE     : u32 :    0x00010000;
OFN_NONETWORKBUTTON      : u32 :    0x00020000;
OFN_NOLONGNAMES          : u32 :    0x00040000;    // force no long names for 4.x modules
OFN_EXPLORER             : u32 :    0x00080000;    // new look commdlg
OFN_NODEREFERENCELINKS   : u32 :    0x00100000;
OFN_LONGNAMES            : u32 :    0x00200000;    // force long names for 3.x modules
OFN_ENABLEINCLUDENOTIFY  : u32 :    0x00400000;    // send include message to callback
OFN_ENABLESIZING         : u32 :    0x00800000;
OFN_DONTADDTORECENT      : u32 :    0x02000000;
OFN_FORCESHOWHIDDEN      : u32 :    0x10000000;    // Show All files including System and hidden files

IDC_ARROW           :: cast(LPCSTR) (cast(ULONG_PTR) 32512);
IDC_IBEAM           :: cast(LPCSTR) (cast(ULONG_PTR) 32513);
IDC_WAIT            :: cast(LPCSTR) (cast(ULONG_PTR) 32514);
IDC_CROSS           :: cast(LPCSTR) (cast(ULONG_PTR) 32515);
IDC_UPARROW         :: cast(LPCSTR) (cast(ULONG_PTR) 32516);
IDC_SIZE            :: cast(LPCSTR) (cast(ULONG_PTR) 32640);
IDC_ICON            :: cast(LPCSTR) (cast(ULONG_PTR) 32641);
IDC_SIZENWSE        :: cast(LPCSTR) (cast(ULONG_PTR) 32642);
IDC_SIZENESW        :: cast(LPCSTR) (cast(ULONG_PTR) 32643);
IDC_SIZEWE          :: cast(LPCSTR) (cast(ULONG_PTR) 32644);
IDC_SIZENS          :: cast(LPCSTR) (cast(ULONG_PTR) 32645);
IDC_SIZEALL         :: cast(LPCSTR) (cast(ULONG_PTR) 32646);
IDC_NO              :: cast(LPCSTR) (cast(ULONG_PTR) 32648);

SYMOPT_CASE_INSENSITIVE           : DWORD : 0x00000001;
SYMOPT_UNDNAME                    : DWORD : 0x00000002;
SYMOPT_DEFERRED_LOADS             : DWORD : 0x00000004;
SYMOPT_NO_CPP                     : DWORD : 0x00000008;
SYMOPT_LOAD_LINES                 : DWORD : 0x00000010;
SYMOPT_OMAP_FIND_NEAREST          : DWORD : 0x00000020;
SYMOPT_LOAD_ANYTHING              : DWORD : 0x00000040;
SYMOPT_IGNORE_CVREC               : DWORD : 0x00000080;
SYMOPT_NO_UNQUALIFIED_LOADS       : DWORD : 0x00000100;
SYMOPT_FAIL_CRITICAL_ERRORS       : DWORD : 0x00000200;
SYMOPT_EXACT_SYMBOLS              : DWORD : 0x00000400;
SYMOPT_ALLOW_ABSOLUTE_SYMBOLS     : DWORD : 0x00000800;
SYMOPT_IGNORE_NT_SYMPATH          : DWORD : 0x00001000;
SYMOPT_INCLUDE_32BIT_MODULES      : DWORD : 0x00002000;
SYMOPT_PUBLICS_ONLY               : DWORD : 0x00004000;
SYMOPT_NO_PUBLICS                 : DWORD : 0x00008000;
SYMOPT_AUTO_PUBLICS               : DWORD : 0x00010000;
SYMOPT_NO_IMAGE_SEARCH            : DWORD : 0x00020000;
SYMOPT_SECURE                     : DWORD : 0x00040000;
SYMOPT_NO_PROMPTS                 : DWORD : 0x00080000;
SYMOPT_OVERWRITE                  : DWORD : 0x00100000;
SYMOPT_IGNORE_IMAGEDIR            : DWORD : 0x00200000;
SYMOPT_FLAT_DIRECTORY             : DWORD : 0x00400000;
SYMOPT_FAVOR_COMPRESSED           : DWORD : 0x00800000;
SYMOPT_ALLOW_ZERO_ADDRESS         : DWORD : 0x01000000;
SYMOPT_DISABLE_SYMSRV_AUTODETECT  : DWORD : 0x02000000;
SYMOPT_READONLY_CACHE             : DWORD : 0x04000000;
SYMOPT_SYMPATH_LAST               : DWORD : 0x08000000;
SYMOPT_DISABLE_FAST_SYMBOLS       : DWORD : 0x10000000;
SYMOPT_DISABLE_SYMSRV_TIMEOUT     : DWORD : 0x20000000;
SYMOPT_DISABLE_SRVSTAR_ON_STARTUP : DWORD : 0x40000000;
SYMOPT_DEBUG                      : DWORD : 0x80000000;

MAX_SYM_NAME : usize : 2000;

CS_VREDRAW         : u32 : 0x0001;
CS_HREDRAW         : u32 : 0x0002;
CS_DBLCLKS         : u32 : 0x0008;
CS_OWNDC           : u32 : 0x0020;
CS_CLASSDC         : u32 : 0x0040;
CS_PARENTDC        : u32 : 0x0080;
CS_NOCLOSE         : u32 : 0x0200;
CS_SAVEBITS        : u32 : 0x0800;
CS_BYTEALIGNCLIENT : u32 : 0x1000;
CS_BYTEALIGNWINDOW : u32 : 0x2000;
CS_GLOBALCLASS     : u32 : 0x4000;

WS_OVERLAPPED       : u32 :0x00000000;
WS_POPUP            : u32 :0x80000000;
WS_CHILD            : u32 :0x40000000;
WS_MINIMIZE         : u32 :0x20000000;
WS_VISIBLE          : u32 :0x10000000;
WS_DISABLED         : u32 :0x08000000;
WS_CLIPSIBLINGS     : u32 :0x04000000;
WS_CLIPCHILDREN     : u32 :0x02000000;
WS_MAXIMIZE         : u32 :0x01000000;
WS_CAPTION          : u32 :0x00C00000;
WS_BORDER           : u32 :0x00800000;
WS_DLGFRAME         : u32 :0x00400000;
WS_VSCROLL          : u32 :0x00200000;
WS_HSCROLL          : u32 :0x00100000;
WS_SYSMENU          : u32 :0x00080000;
WS_THICKFRAME       : u32 :0x00040000;
WS_GROUP            : u32 :0x00020000;
WS_TABSTOP          : u32 :0x00010000;
WS_MINIMIZEBOX      : u32 :0x00020000;
WS_MAXIMIZEBOX      : u32 :0x00010000;
WS_TILED            : u32 :WS_OVERLAPPED;
WS_ICONIC           : u32 :WS_MINIMIZE;
WS_SIZEBOX          : u32 :WS_THICKFRAME;
WS_TILEDWINDOW      : u32 :WS_OVERLAPPEDWINDOW;
WS_OVERLAPPEDWINDOW : u32 :WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
WS_POPUPWINDOW      : u32 :WS_POPUP | WS_BORDER | WS_SYSMENU;
WS_CHILDWINDOW      : u32 :WS_CHILD;

WS_EX_DLGMODALFRAME    : u32 : 0x00000001;
WS_EX_NOPARENTNOTIFY   : u32 : 0x00000004;
WS_EX_TOPMOST          : u32 : 0x00000008;
WS_EX_ACCEPTFILES      : u32 : 0x00000010;
WS_EX_TRANSPARENT      : u32 : 0x00000020;
WS_EX_MDICHILD         : u32 : 0x00000040;
WS_EX_TOOLWINDOW       : u32 : 0x00000080;
WS_EX_WINDOWEDGE       : u32 : 0x00000100;
WS_EX_CLIENTEDGE       : u32 : 0x00000200;
WS_EX_CONTEXTHELP      : u32 : 0x00000400;
WS_EX_RIGHT            : u32 : 0x00001000;
WS_EX_LEFT             : u32 : 0x00000000;
WS_EX_RTLREADING       : u32 : 0x00002000;
WS_EX_LTRREADING       : u32 : 0x00000000;
WS_EX_LEFTSCROLLBAR    : u32 : 0x00004000;
WS_EX_RIGHTSCROLLBAR   : u32 : 0x00000000;
WS_EX_CONTROLPARENT    : u32 : 0x00010000;
WS_EX_STATICEDGE       : u32 : 0x00020000;
WS_EX_APPWINDOW        : u32 : 0x00040000;
WS_EX_OVERLAPPEDWINDOW : u32 : WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE;
WS_EX_PALETTEWINDOW    : u32 : WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST;

WNDPROC :: *fn (HWND, UINT, WPARAM, LPARAM) LRESULT;
HICON :: *C.int;
HBRUSH :: *C.int;

WNDCLASSA :: struct {
    style: UINT;
    lpfnWndProc: WNDPROC;
    cbClsExtra: C.int;
    cbWndExtra: C.int;
    hInstance: HINSTANCE;
    hIcon: HICON;
    hCursor: HCURSOR;
    hbrBackground: HBRUSH;
    lpszMenuName: LPCSTR;
    lpszClassName: LPCSTR;
}

WNDCLASSEXA :: struct {
    cbSize: UINT;
    style: UINT;
    lpfnWndProc: WNDPROC;
    cbClsExtra: C.int;
    cbWndExtra: C.int;
    hInstance: HINSTANCE;
    hIcon: HICON;
    hCursor: HCURSOR;
    hbrBackground: HBRUSH;
    lpszMenuName: LPCSTR;
    lpszClassName: LPCSTR;
    hIconSm: HICON;
}

SYMBOL_INFO :: struct {
    SizeOfStruct: ULONG;
    TypeIndex: ULONG;
    Reserved: [2]ULONG64;
    Index: ULONG;
    Size: ULONG;
    ModBase: ULONG64;
    Flags: ULONG;
    Value: ULONG64;
    Address: ULONG64;
    Register: ULONG;
    Scope: ULONG;
    Tag: ULONG;
    NameLen: ULONG;
    MaxNameLen: ULONG;
    Name: [1]CHAR;
}
PSYMBOL_INFO :: *SYMBOL_INFO;

IMAGEHLP_LINE64 :: struct {
    SizeOfStruct: DWORD;
    Key: PVOID;
    LineNumber: DWORD;
    FileName: PCHAR;
    Address: DWORD64;
}
PIMAGEHLP_LINE64 :: *IMAGEHLP_LINE64;

OPENFILENAMEA :: struct {
   lStructSize: DWORD;
   hwndOwner: HWND;
   hInstance: HINSTANCE;
   lpstrFilter: LPCSTR;
   lpstrCustomFilter: LPSTR;
   nMaxCustFilter: DWORD;
   nFilterIndex: DWORD;
   lpstrFile: LPSTR;
   nMaxFile: DWORD;
   lpstrFileTitle: LPSTR;
   nMaxFileTitle: DWORD;
   lpstrInitialDir: LPCSTR;
   lpstrTitle: LPCSTR;
   Flags: DWORD;
   nFileOffset: WORD;
   nFileExtension: WORD;
   lpstrDefExt: LPCSTR;
   lCustData: LPARAM;
   lpfnHook: LPOFNHOOKPROC;
   lpTemplateName: LPCSTR;
   pvReserved: *u8;
   dwReserved: DWORD;
   FlagsEx: DWORD;
}
LPOPENFILENAMEA :: *OPENFILENAMEA;

FILE_NOTIFY_INFORMATION :: struct {
    NextEntryOffset: DWORD;
    Action: DWORD;
    FileNameLength: DWORD;
    FileName: [1]WCHAR;
}
OVERLAPPED :: struct {
    Internal: ULONG_PTR;
    InternalHigh: ULONG_PTR;
    Pointer: PVOID;
    hEvent: HANDLE;
}
FILETIME :: struct {
    dwLowDateTime: DWORD;
    dwHighDateTime: DWORD;
}
PFILETIME :: FILETIME;
LPFILETIME :: *FILETIME;
FIND_DATA :: struct {
    dwFileAttributes: DWORD;
    ftCreationTime: FILETIME;
    ftLastAccessTime: FILETIME;
    ftLastWriteTime: FILETIME;
    nFileSizeHigh: DWORD;
    nFileSizeLow: DWORD;
    dwReserved0: DWORD;
    dwReserved1: DWORD;
    cFileName: [MAX_PATH]CHAR;
    cAlternateFileName: [14]CHAR;
}

BY_HANDLE_FILE_INFORMATION :: struct {
    dwFileAttributes: DWORD;
    ftCreationTime: FILETIME;
    ftLastAccessTime: FILETIME;
    ftLastWriteTime: FILETIME;
    dwVolumeSerialNumber: DWORD;
    nFileSizeHigh: DWORD;
    nFileSizeLow: DWORD;
    nNumberOfLinks: DWORD;
    nFileIndexHigh: DWORD;
    nFileIndexLow: DWORD;
}
LPBY_HANDLE_FILE_INFORMATION :: *BY_HANDLE_FILE_INFORMATION;
FIND_DATAA :: FIND_DATA;
P_FIND_DATAA :: *FIND_DATA;
LP_FIND_DATAA :: *FIND_DATA;
INVALID_HANDLE :: cast(*u8) -1;
INVALID_FILE_SIZE :: cast(DWORD) 0xFFFFFFFF;
INVALID_SET_FILE_POINTER :: cast(DWORD) -1;
INVALID_FILE_ATTRIBUTES :: cast(DWORD) -1;

WAIT_TIMEOUT :: 258;
WAIT_FAILED : DWORD : 0xFFFFFFFF;
WAIT_OBJECT_0 :: 0;
LIST_ENTRY :: struct {
   Flink: *LIST_ENTRY;
   Blink: *LIST_ENTRY;
} 
RTL_CRITICAL_SECTION_DEBUG :: struct {
    Type: WORD;
    CreatorBackTraceIndex: WORD;
    CriticalSection: *RTL_CRITICAL_SECTION;
    ProcessLocksList: LIST_ENTRY;
    EntryCount: DWORD;
    ContentionCount: DWORD;
    Flags: DWORD;
    CreatorBackTraceIndexHigh: WORD;
    SpareWORD: WORD;
}
PRTL_CRITICAL_SECTION_DEBUG :: *RTL_CRITICAL_SECTION_DEBUG;
RTL_CRITICAL_SECTION :: struct {
    DebugInfo: PRTL_CRITICAL_SECTION_DEBUG;
    LockCount: LONG;
    RecursionCount: LONG;
    OwningThread: HANDLE; 
    LockSemaphore: HANDLE;
    SpinCount: ULONG_PTR;
}
LPCRITICAL_SECTION :: *RTL_CRITICAL_SECTION;

POINT :: struct {
    x: LONG;
    y: LONG;
}

LPPOINT :: *POINT;

FORMAT_MESSAGE_IGNORE_INSERTS : u32 : 0x00000200;
FORMAT_MESSAGE_FROM_STRING    : u32 : 0x00000400;
FORMAT_MESSAGE_FROM_HMODULE   : u32 : 0x00000800;
FORMAT_MESSAGE_FROM_SYSTEM    : u32 : 0x00001000;
FORMAT_MESSAGE_ARGUMENT_ARRAY : u32 : 0x00002000;
FORMAT_MESSAGE_MAX_WIDTH_MASK : u32 : 0x000000FF;

FindFirstFile :: fn  (lpFileName: LPCSTR, lpFindFileData: LP_FIND_DATAA) HANDLE #extern "FindFirstFileA";
FindClose :: fn (hFindFile: HANDLE) BOOL #extern "FindClose";
FindNextFile :: fn (hFindFile: HANDLE, lpFindFileData: LP_FIND_DATAA) BOOL #extern "FindNextFileA";
GetFileAttributesA :: fn (lpFileName: LPCSTR) DWORD #extern "GetFileAttributesA";
CreateFile :: fn (
    lpFileName: LPCSTR,
    dwDesiredAccess: DWORD,
    dwShareMode: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    dwCreationDisposition: DWORD,
    dwFlagsAndAttributes: DWORD,
    hTemplateFile: HANDLE
) *u8 #extern "CreateFileA"; 
CreateDirectoryA :: fn (
    lpPathName: LPCSTR,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
) BOOL #extern "CreateDirectoryA";
ReadDirectoryChanges :: fn (
    hDirectory: HANDLE,
    lpBuffer: LPVOID,
    nBufferLength: DWORD,
    bWatchSubtree: BOOL,
    dwNotifyFilter: DWORD,
    lpBytesReturned: LPDWORD,
    lpOverlapped: LPOVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE 
) s32 #extern "ReadDirectoryChangesW";
WideCharToMultiByte :: fn (
    CodePage: UINT,
    dwFlags: *DWORD,
    lpWideCharStr: *LPCWCH,
    cchWideChar: s32,
    lpMultiByteStr: LPSTR,
    cbMultiByte: s32,
    lpDefaultChar: *LPCCH,
    lpUsedDefaultChar: *LPBOOL
) s32 #extern "WideCharToMultiByte";
CreateEvent :: fn (
  lpEventAttributes: LPSECURITY_ATTRIBUTES,
  bManualReset: BOOL,
  bInitialState: BOOL,
  lpName: LPCSTR 
) HANDLE #extern "CreateEventA";
SetEvent :: fn (hEvent: HANDLE) BOOL #extern "SetEvent";
FindFirstChangeNotification :: fn (
  lpPathName: LPCSTR,
  bWatchSubtree: BOOL,
  dwNotifyFilter: DWORD
) HANDLE #extern "FindFirstChangeNotificationA";
FindNextChangeNotification :: fn (hChangeHandle: HANDLE) BOOL #extern "FindNextChangeNotification";
FindCloseChangeNotification :: fn (hChangeHandle: HANDLE) BOOL #extern "FindCloseChangeNotification";
WaitForSingleObject :: fn (hHandle: HANDLE, dwMilliseconds: DWORD) DWORD #extern "WaitForSingleObject";
WaitForMultipleObjects :: fn (
    nCount: DWORD,
    lpHandles: *HANDLE,
    bWaitAll: BOOL,
    dwMilliseconds: DWORD        
) DWORD #extern "WaitForMultipleObjects";
GetCommandLineW     :: fn () LPWSTR #extern "GetCommandLineW";
CommandLineToArgvW  :: fn (lpCmdLine: LPCWSTR, pNumArgs: *s32) *LPWSTR #extern "CommandLineToArgvW";
LocalFree           :: fn (hMem: HLOCAL) HLOCAL #extern "LocalFree";
Sleep               :: fn (dwMilliseconds: DWORD) #extern "Sleep";
SleepEx             :: fn (dwMilliseconds: DWORD, bAlertable: BOOL) DWORD #extern "SleepEx";
GetFullPathNameA    :: fn (lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: *LPSTR) DWORD #extern "GetFullPathNameA";
PathFileExistsA     :: fn (pszPath: LPCSTR) BOOL #extern "PathFileExistsA";
LoadLibraryA        :: fn (lpLibFileName: LPCSTR) HMODULE #extern "LoadLibraryA";
FreeLibrary         :: fn (hLibModule: HMODULE) BOOL #extern "FreeLibrary";
GetModuleHandleA    :: fn (lpModuleName: LPCSTR) HMODULE #extern "GetModuleHandleA";
GetProcAddress      :: fn (hModule: HMODULE, lpProcName: LPCSTR) FARPROC #extern "GetProcAddress";
DebugBreak          :: fn () #extern "DebugBreak";
IsDebuggerPresent   :: fn () BOOL #extern "IsDebuggerPresent";
CheckRemoteDebuggerPresent :: fn (hProcess: HANDLE, pbDebuggerPresent: PBOOL) BOOL #extern "CheckRemoteDebuggerPresent";
GetModuleFileNameA  :: fn (hModule: HMODULE, lpFilename: LPSTR, nSize: DWORD) DWORD #extern "GetModuleFileNameA";
SECURITY_ATTRIBUTES :: struct {
    nLength: DWORD;
    lpSecurityDescriptor: LPVOID;
    bInheritHandle: BOOL;
} 
PSECURITY_ATTRIBUTES  :: *SECURITY_ATTRIBUTES;
LPSECURITY_ATTRIBUTES :: *SECURITY_ATTRIBUTES;
LPTHREAD_START_ROUTINE :: *fn (args: LPVOID) DWORD;

CreateThread :: fn (
    lpThreadAttributes: LPSECURITY_ATTRIBUTES,
    dwStackSize: SIZE_T,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: LPVOID,
    dwCreationFlags: DWORD,
    lpThreadId: LPDWORD 
) HANDLE #extern "CreateThread";

GetCurrentThread :: fn () HANDLE #extern "GetCurrentThread";
GetCurrentProcess :: fn () HANDLE #extern "GetCurrentProcess";
TerminateThread :: fn (handle: HANDLE, exit_code: DWORD) BOOL #extern "TerminateThread";
GetExitCodeThread :: fn (hThread: HANDLE, lpExitCode: LPDWORD) BOOL #extern "GetExitCodeThread";

CreateMutexA :: fn (
    lpMutexAttributes: LPSECURITY_ATTRIBUTES,
    bInitialOwner: BOOL,
    lpName: LPCSTR
) HANDLE #extern "CreateMutexA";

HMENU :: *C.int;
CW_USEDEFAULT : C.int : 0x80000000;

MSG :: struct {
    hwnd: HWND;
    message: UINT;
    wParam: WPARAM;
    lParam: LPARAM;
    time: DWORD;
    pt: POINT;
}
LPMSG :: *MSG;

PM_NOREMOVE : u32 : 0x0000;
PM_REMOVE   : u32 : 0x0001;
PM_NOYIELD  : u32 : 0x0002;

WM_NULL     : u32 : 0x0000;
WM_CREATE   : u32 : 0x0001;
WM_DESTROY  : u32 : 0x0002;
WM_MOVE     : u32 : 0x0003;
WM_SIZE     : u32 : 0x0005;
WM_ACTIVATE : u32 : 0x0006;
WM_QUIT     : u32 : 0x0012;
WM_SETFOCUS      : u32 :  0x0007;
WM_KILLFOCUS     : u32 :  0x0008;
WM_ENABLE        : u32 :  0x000A;
WM_SETREDRAW     : u32 :  0x000B;
WM_SETTEXT       : u32 :  0x000C;
WM_GETTEXT       : u32 :  0x000D;
WM_GETTEXTLENGTH : u32 :  0x000E;
WM_PAINT         : u32 :  0x000F;
WM_CLOSE         : u32 :  0x0010;


RECT :: struct {
    left: LONG;
    top: LONG;
    right: LONG;
    bottom: LONG;
}

PFD_TYPE_RGBA             : u32 : 0;
PFD_TYPE_COLORINDEX       : u32 : 1;
PFD_MAIN_PLANE            : u32 : 0;
PFD_OVERLAY_PLANE         : u32 : 1;
PFD_UNDERLAY_PLANE        : u32 : -1;
PFD_DOUBLEBUFFER          : u32 : 0x00000001;
PFD_STEREO                : u32 : 0x00000002;
PFD_DRAW_TO_WINDOW        : u32 : 0x00000004;
PFD_DRAW_TO_BITMAP        : u32 : 0x00000008;
PFD_SUPPORT_GDI           : u32 : 0x00000010;
PFD_SUPPORT_OPENGL        : u32 : 0x00000020;
PFD_GENERIC_FORMAT        : u32 : 0x00000040;
PFD_NEED_PALETTE          : u32 : 0x00000080;
PFD_NEED_SYSTEM_PALETTE   : u32 : 0x00000100;
PFD_SWAP_EXCHANGE         : u32 : 0x00000200;
PFD_SWAP_COPY             : u32 : 0x00000400;
PFD_SWAP_LAYER_BUFFERS    : u32 : 0x00000800;
PFD_GENERIC_ACCELERATED   : u32 : 0x00001000;
PFD_SUPPORT_DIRECTDRAW    : u32 : 0x00002000;
PFD_DIRECT3D_ACCELERATED  : u32 : 0x00004000;
PFD_SUPPORT_COMPOSITION   : u32 : 0x00008000;
PFD_DEPTH_DONTCARE        : u32 : 0x20000000;
PFD_DOUBLEBUFFER_DONTCARE : u32 : 0x40000000;
PFD_STEREO_DONTCARE       : u32 : 0x80000000;


PIXELFORMATDESCRIPTOR :: struct {
    nSize: WORD;
    nVersion: WORD;
    dwFlags: DWORD;
    iPixelType: BYTE;
    cColorBits: BYTE;
    cRedBits: BYTE;
    cRedShift: BYTE;
    cGreenBits: BYTE;
    cGreenShift: BYTE;
    cBlueBits: BYTE;
    cBlueShift: BYTE;
    cAlphaBits: BYTE;
    cAlphaShift: BYTE;
    cAccumBits: BYTE;
    cAccumRedBits: BYTE;
    cAccumGreenBits: BYTE;
    cAccumBlueBits: BYTE;
    cAccumAlphaBits: BYTE;
    cDepthBits: BYTE;
    cStencilBits: BYTE;
    cAuxBuffers: BYTE;
    iLayerType: BYTE;
    bReserved: BYTE;
    dwLayerMask: DWORD;
    dwVisibleMask: DWORD;
    dwDamageMask: DWORD;
};
LPPIXELFORMATDESCRIPTOR :: *PIXELFORMATDESCRIPTOR;

MB_OK               : u32 : 0x00000000;
MB_OKCANCEL         : u32 : 0x00000001;
MB_ABORTRETRYIGNORE : u32 : 0x00000002;
MB_YESNOCANCEL      : u32 : 0x00000003;
MB_YESNO            : u32 : 0x00000004;
MB_RETRYCANCEL      : u32 : 0x00000005;

ReleaseMutex :: fn (hMutex: HANDLE) BOOL #extern "ReleaseMutex";
GetTickCount :: fn () DWORD #extern "GetTickCount";
QueryPerformanceCounter :: fn (lpPerformanceCount: *LARGE_INTEGER) BOOL #extern "QueryPerformanceCounter";
QueryPerformanceFrequency :: fn (lpPerformanceCount: *LARGE_INTEGER) BOOL #extern "QueryPerformanceFrequency";
GlobalAlloc :: fn (uFlags: UINT, dwBytes: SIZE_T) HGLOBAL #extern "GlobalAlloc";
GlobalFree :: fn (hMem: HGLOBAL) HGLOBAL #extern "GlobalFree";
GlobalLock :: fn (hMem: HGLOBAL) LPVOID #extern "GlobalLock";
GlobalUnlock :: fn (hMem: HGLOBAL) BOOL #extern "GlobalUnlock";
OpenClipboard :: fn (hWndNewOwner: HWND) BOOL #extern "OpenClipboard";
EmptyClipboard :: fn () BOOL #extern "EmptyClipboard";
SetClipboardData :: fn (uFormat: UINT, hMem: HANDLE) HANDLE #extern "SetClipboardData";
GetClipboardData :: fn (uFormat: UINT) HANDLE  #extern "GetClipboardData";
CloseClipboard :: fn () BOOL #extern "CloseClipboard";
GetLastError :: fn () DWORD #extern "GetLastError";
CloseHandle :: fn (hObject: HANDLE) BOOL #extern "CloseHandle";
GetTempPathA :: fn (nBufferLength: DWORD, lpBuffer: LPSTR) DWORD #extern "GetTempPathA";
DeleteFileA :: fn (lpFileName: LPCSTR) BOOL #extern "DeleteFileA";
RemoveDirectoryA :: fn (lpPathName: LPCSTR) BOOL #extern "RemoveDirectoryA";
GetCurrentDirectoryA :: fn (nBufferLength: DWORD, lpBuffer: LPSTR) DWORD #extern "GetCurrentDirectoryA";
SetCurrentDirectoryA :: fn (lpPathName: LPSTR) BOOL #extern "SetCurrentDirectoryA";
GetFileSizeEx :: fn (hFile: HANDLE, lpFileSize: PLARGE_INTEGER) BOOL #extern "GetFileSizeEx";
ReadFile :: fn (hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: LPDWORD, lpOverlapped: LPOVERLAPPED) BOOL #extern "ReadFile";
WriteFile :: fn (hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToWrite: DWORD, lpNumberOfBytesWritten: LPDWORD, lpOverlapped: LPOVERLAPPED) BOOL #extern "WriteFile";
CopyFileA :: fn (lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, bFailIfExists: BOOL) BOOL #extern "CopyFileA";
SetEndOfFile :: fn (hFile: HANDLE) BOOL #extern "SetEndOfFile";
SetFilePointer :: fn (hFile: HANDLE, lDistanceToMove: LONG, lpDistanceToMoveHigh: PLONG, dwMoveMethod: DWORD) DWORD #extern "SetFilePointer";
InitializeCriticalSection :: fn (lpCriticalSection: LPCRITICAL_SECTION) #extern "InitializeCriticalSection";
DeleteCriticalSection :: fn (lpCriticalSection: LPCRITICAL_SECTION) #extern "DeleteCriticalSection";
EnterCriticalSection  :: fn (lpCriticalSection: LPCRITICAL_SECTION) #extern "EnterCriticalSection";
LeaveCriticalSection  :: fn (lpCriticalSection: LPCRITICAL_SECTION) #extern "LeaveCriticalSection";
TryEnterCriticalSection :: fn (lpCriticalSection: LPCRITICAL_SECTION ) BOOL #extern "TryEnterCriticalSection";
GetFileInformationByHandle :: fn (hFile: HANDLE, lpFileInformation: LPBY_HANDLE_FILE_INFORMATION) BOOL #extern "GetFileInformationByHandle";
GetOverlappedResult :: fn (hFile: HANDLE, lpOverlapped: LPOVERLAPPED, lpNumberOfBytesTransferred: LPDWORD, bWait: BOOL) BOOL #extern "GetOverlappedResult";
ResetEvent :: fn (hEvent: HANDLE) BOOL #extern "ResetEvent";
FormatMessageA :: fn (dwFlags: DWORD, lpSource: LPVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPSTR, nSize: DWORD, Arguments: *u8) DWORD #extern "FormatMessageA";
GetCursorPos :: fn (lpPoint: LPPOINT) BOOL #extern "GetCursorPos";
LoadCursorA :: fn (hInstance: HINSTANCE, lpCursorName: LPCSTR) HCURSOR #extern "LoadCursorA";
SetCursor :: fn (hCursor: HCURSOR) HCURSOR #extern "SetCursor";
GetSaveFileNameA :: fn (param1: LPOPENFILENAMEA) BOOL #extern "GetSaveFileNameA";
GetOpenFileNameA :: fn (param1: LPOPENFILENAMEA) BOOL #extern "GetOpenFileNameA";
FlushFileBuffers :: fn (hFile: HANDLE) BOOL #extern "FlushFileBuffers";
GetStdHandle :: fn (nStdHandle: DWORD) HANDLE #extern "GetStdHandle";
SetConsoleOutputCP :: fn (wCodePageID: UINT) BOOL #extern "SetConsoleOutputCP";
SymSetOptions :: fn (SymOptions: DWORD) DWORD #extern "SymSetOptions";
SymInitialize :: fn (hProcess: HANDLE, UserSearchPath: PCSTR, fInvadeProcess: BOOL) BOOL #extern "SymInitialize";
SymCleanup :: fn (hProcess: HANDLE) BOOL #extern "SymCleanup";
CaptureStackBackTrace :: fn (FramesToSkip: DWORD, FramesToCapture: DWORD, BackTrace: *PVOID, BackTraceHash: PDWORD) WORD #extern "RtlCaptureStackBackTrace";
SymFromAddr :: fn (hProcess: HANDLE, Address: DWORD64, Displacement: PDWORD64, Symbol: PSYMBOL_INFO) BOOL #extern "SymFromAddr";
SymGetLineFromAddr64 :: fn (hProcess: HANDLE, qwAddr: DWORD64, pdwDisplacement: PDWORD, Line64: PIMAGEHLP_LINE64) BOOL #extern "SymGetLineFromAddr64";
RegisterClassA :: fn (lpWndClass: *WNDCLASSA) WORD #extern "RegisterClassA";
CreateWindowExA :: fn (dwExStyle: DWORD, lpClassName: LPCSTR, lpWindowName: LPCSTR, dwStyle: DWORD, X: C.int, Y: C.int, nWidth: C.int, nHeight: C.int, hWndParent: HWND, hMenu: HMENU, hInstance: HINSTANCE, lpParam: LPVOID) HWND #extern "CreateWindowExA";
GetModuleHandleW :: fn (lpModuleName: LPCWSTR) HMODULE #extern "GetModuleHandleW";
DefWindowProcA :: fn (hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) LRESULT #extern "DefWindowProcA";
ShowWindow :: fn (hWnd: HWND, nCmdShow: C.int) BOOL #extern "ShowWindow";
PeekMessageA :: fn (lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT, wRemoveMsg: UINT) BOOL #extern "PeekMessageA";
TranslateMessage :: fn (lpMsg: *MSG) BOOL #extern "TranslateMessage";
DispatchMessageA :: fn (lpMsg: *MSG) BOOL #extern "DispatchMessageA";
UpdateWindow :: fn (hWnd: HWND) BOOL #extern "UpdateWindow";
PostQuitMessage :: fn (nExitCode: C.int) #extern "PostQuitMessage";
GetDC :: fn (hWnd: HWND) HDC #extern "GetDC";
ChoosePixelFormat :: fn (hdc: HDC, ppfd: *PIXELFORMATDESCRIPTOR) C.int #extern "ChoosePixelFormat";
RegisterClassExA :: fn (lpWndClass: *WNDCLASSEXA) WORD #extern "RegisterClassExA";
CreateWindowA :: fn (lpClassName: LPCSTR, lpWindowName: LPCSTR, dwStyle: DWORD, X: C.int, Y: C.int, nWidth: C.int, nHeight: C.int, hWndParent: HWND, hMenu: HMENU, hInstance: HINSTANCE, lpParam: LPVOID) HWND #inline {
    return CreateWindowExA(0, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}
SetPixelFormat :: fn (hdc: HDC, format: C.int, ppfd: *PIXELFORMATDESCRIPTOR) BOOL #extern "SetPixelFormat";
DescribePixelFormat :: fn (hdc: HDC, iPixelFormat: C.int, nBytes: UINT, ppfd: LPPIXELFORMATDESCRIPTOR) C.int #extern "DescribePixelFormat";
ReleaseDC :: fn (hWnd: HWND, hDC: HDC) C.int #extern "ReleaseDC";
DestroyWindow :: fn (hWnd: HWND) BOOL #extern "DestroyWindow";
SetWindowTextA :: fn (hWnd: HWND, lpString: LPCSTR) BOOL #extern "SetWindowText";
SwapBuffers :: fn (context: HDC) BOOL #extern "SwapBuffers";
MessageBoxA :: fn (hWnd: HWND, lpText: LPCSTR, lpCaption: LPCSTR, uType: UINT) C.int #extern "MessageBoxA";
