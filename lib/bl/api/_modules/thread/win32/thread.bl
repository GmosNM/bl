#load "os/windows/winapi.bl"

Thread :: _HANDLE;
ThreadEntryFn :: *fn (args: ...);

thread_create :: fn (entry: ThreadEntryFn, args: ...) (Thread, Error) {
    if !entry { return null, error(ERR_INVALID_HANDLE, "Cannot create thread. Handle is invalid."); }
    tmp: *_ThreadArgs = auto alloc(sizeof(_ThreadArgs));
    tmp.entry = entry;
    tmp.args = args;
    thread :: _CreateThread(null, 0, &thread_entry, auto tmp, 0, null);
    if !thread {
        free(auto tmp);
        ec, estr :: os_get_last_error();
        return null, error(ec, "Cannot create thread: %.", estr);
    }
    return thread, ok();
}

thread_join :: fn (thread: Thread, timeout_ms := _INFINITE) Error {
    if !thread { error(ERR_INVALID_HANDLE, "Cannot join. Handle is invalid."); }
    if _WaitForSingleObject(thread, timeout_ms) == _WAIT_FAILED {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot join: %.", estr);
    }
    if _CloseHandle(thread) == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot join: %.", estr);
    }
    return ok();
}

thread_current :: fn () Thread #inline {
    return _GetCurrentThread();
}

thread_kill :: fn (thread: Thread, exit_code: s32 = 0) Error #inline {
    if !thread { return error(ERR_INVALID_HANDLE, "Cannot kill thread. Handle is invalid."); }
    if _TerminateThread(thread, auto exit_code) != 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot kill thread: %.", estr);
    }
    return ok();
}

#private
_ThreadArgs :: struct {
    entry: ThreadEntryFn;
    args: ...; 
}

thread_entry :: fn (_args: *u8) u32 {
    tmp :: cast(*_ThreadArgs) _args;
    defer free(auto tmp);
    tmp.entry(tmp.args);
    return 0;
}