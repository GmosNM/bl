//! # Command Line Argument Parser
//! 
//! `#import "std/arg_parser"`
//!
//! Generic command line argument parsing tool.
//! 
//! ### Example
//! 
//! ```
//! #import "std/arg_parser"
//! 
//! // Command line arguments context.
//! Args :: struct #base std.ArgParserCtx {
//!     my_flag: bool;
//!     my_name: string_view;
//! }
//! 
//! g_args: Args;
//! 
//! main :: fn () s32 {
//!     parser :: std.arg_parser_new();
//!     defer std.arg_parser_delete(parser);
//!     // After this all positional arguments stored inside the argument parser
//!     // context are invalid.
//!     defer std.arg_parser_ctx_terminate(&g_args);
//! 
//!     // Add new argument.
//!     std.arg_parser_add(
//!         parser, 
//!         "-f", // Short name (must start with -)
//!         "--flag", // Long name (must start with -)
//!         "Specify my flag.", // Help text.
//!         &fn (parser: std.ArgParser, args: []string_view, ctx: *std.ArgParserCtx) (s32, Error) {
//!             a: *Args = auto ctx;
//!             a.my_flag = true;
//!             return 1, ok(); // Return number of parsed arguments and state.
//!         });
//! 
//!     std.arg_parser_add(
//!         parser,
//!         "-n",
//!         "--name",
//!         "Specify my name.",
//!         &fn (parser: std.ArgParser, args: []string_view, ctx: *std.ArgParserCtx) (s32, Error) {
//!             a: *Args = auto ctx;
//!             if (args.len < 2) {
//!                 return 0, error("Expected name!");
//!             }
//!             a.my_name = args[1];
//!             return 2, ok();
//!         });
//! 
//!     // Start parsing.
//!     state :: std.arg_parser_run(parser, command_line_arguments, &g_args, 1);
//!     if !is_ok(state) {
//!         print_err("%", state);
//!         std.arg_parser_print_help(parser);
//!         return 1;
//!     }
//! 
//!     print("%\n", g_args);
//!     return 0;
//! }
//! ```

#import "std/array"

#scope std

/// Arguments context base type.
ArgParserCtx :: struct {
    /// Contains other positional arguments not considered as options (i.e. input files).
    positional: [..]string_view;
    /// True when help was invoked implicitly.
    help: bool;
}

/// Argument parser opaque handle.
ArgParser :: *u8;

/// Argument parser callback function type. In context of [add](#argparseradd) this callback 
/// function provides current `parser`, rest of the input argument slice starting from currently 
/// captured argument name and custom argument context `ctx`. Expected return of such function is 
/// count of parsed arguments from `args` input (at least one for successfully parsed argument with 
/// no additional input) and status.
///
/// See also: [add](#argparseradd)
///
/// **todo**: Is reference to parent parser needed here?
ArgParserHandlerFn :: *fn (parser: ArgParser, args: []string_view, ctx: *ArgParserCtx) (s32, Error);

/// Create new instance of parser with possibility to set custom help text. Use 
/// [delete](#argparserdelete) to release parser instance.
arg_parser_new :: fn (help_text := std.str_view_empty) ArgParser {
    parser := cast(*ParserImpl) alloc(sizeof(ParserImpl));
    parser.pad = 0;
    parser.help_text = std.str_new(help_text);
    array_init(&parser.entries);

    arg_parser_add(auto parser,
        "-h",
        "--help",
        "Print this help.",
        &fn (parser: ArgParser, _: []string_view, ctx: *ArgParserCtx) (s32, Error) {
            if ctx { ctx.help = true; }
            arg_parser_print_help(parser);
            return 1, ok();
        });

    return auto parser;
}

/// Delete parser instance.
arg_parser_delete :: fn (_parser: ArgParser) {
    parser: *ParserImpl = auto _parser;
    loop i := 0; i < parser.entries.len; i += 1 {
        entry_delete(&parser.entries[i]);
    }
    array_terminate(&parser.entries);
    std.str_delete(&parser.help_text);
    free(auto parser);
}

/// Release 'positional' arguments array inside the context data. 
arg_parser_ctx_terminate :: fn (ctx: *ArgParserCtx) {
    assert(ctx);
    array_terminate(&ctx.positional);
}

/// Perform parsing on input `args` slice and provide `ctx` as context to the argument parsing
/// callbacks. `start` specify first element of `args` slice considered to be an argument.
/// See also: (command_line_arguments)[#argparsercommand_line_arguments] 
/// (**note**: first element contains name of the executable)
arg_parser_run :: fn (_parser: ArgParser, args: []string_view, ctx: *ArgParserCtx, start := 0) Error {
    assert(ctx);
    parser: *ParserImpl = auto _parser;
    if start >= args.len {
        return ok();
    } else {
        args.ptr = &args[start];
        args.len -= start;
    }

    loop args.len > 0 {
        arg :: &args[0];
        if arg.len > 0 && (@arg)[0] != '-' {
            array_push(&ctx.positional, @arg);
            if args.len > 1 {
                args.ptr = &args[1];
            } else {
                args.ptr = null;
            }
            args.len -= 1;
            continue;
        }
        found: bool;
        loop e := 0; e < parser.entries.len; e += 1 {
            entry :: &parser.entries[e];
            if std.str_match(@arg, entry.short) || std.str_match(@arg, entry.long) {
                found = true;
                parsed, err :: entry.handler(_parser, args, ctx);
                if !is_ok(err) {
                    return err;
                }
                if parsed == 0 {
                    panic("Parsed count returned from argument lambda is supposed to be at least 1, not %!", parsed); 
                }
                if args.len > parsed { args.ptr = &args[parsed]; }
                args.len -= parsed;
                break;
            }
        }
        if !found {
            return error("Invalid argument '%'.", @arg);
        }
    }
    return ok();
}

/// Add new argument specified by `short` and `long` name to be recognised by parser. The argument 
/// description can be specified as `help`. `handler` function is called every time parser hits 
/// this argument (`short` or `long` name match). Argument name must be unique name starting with 
/// `-`. Help command (as `-h` or `--help`) is added by default.
///
/// ### Example
///
/// ```
/// std.arg_parser_add(parser,
///     "-d", // short name.
///     "--debug", // long name.
///     "Enable debug mode.", // Help text.
///     &fn (parser: std.ArgParser, args: []string_view, ctx: *std.ArgParserCtx) (s32, Error) {
///         a: *MyArgs = auto ctx;
///         a.is_debug = true;
///         return 1, ok(); // One argument parsed ('-d' or '--debug') 
///     });
/// ```
arg_parser_add :: fn (
    _parser: ArgParser,
    short: string_view,
    long: string_view,
    help: string_view,
    handler: ArgParserHandlerFn
) {
    parser: *ParserImpl = auto _parser;
    entry: Entry #noinit;
    entry.short = std.str_new(short);
    entry.long = std.str_new(long);
    entry.help = std.str_new(help);
    entry.handler = handler;
    array_push(&parser.entries, entry);

    // '  short, long '
    pad :: 2 + short.len + 2 + long.len + 1;
    if parser.pad < pad { parser.pad = auto pad; }
}

/// Print help for all registered commands.
arg_parser_print_help :: fn (_parser: ArgParser) {
    parser: *ParserImpl = auto _parser;
    if !std.str_is_empty(parser.help_text) {
        print("%\n", parser.help_text);
    }
    print("Options:\n");
    loop i := 0; i < parser.entries.len; i += 1 {
        entry :: &parser.entries[i];
        printed: s32;
        if std.str_is_empty(entry.short) {
            printed = print("  % ", entry.long);
        } else {
            printed = print("  %, % ", entry.short, entry.long);
        }
        loop p := 0; p < (parser.pad - printed); p += 1 {
            print(" ");
        }
        print("%\n", entry.help);
    }
}

#private
ParserImpl :: struct {
    entries: [..]Entry;
    pad: s32;
    help_text: string; 
}

Entry :: struct {
    short: string;
    long: string;
    help: string;
    handler: ArgParserHandlerFn;
}

entry_delete :: fn (entry: *Entry) {
    std.str_delete(&entry.short);
    std.str_delete(&entry.long);
    std.str_delete(&entry.help);
}
