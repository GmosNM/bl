// =================================================================================================
// bl
//
// File:   debug_allocator.bl
// Author: Martin Dorazil
// Date:   18/9/20
//
// Copyright 2020 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

#import "std/sync"
#import "std/table"

#scope std 

//! # Debug Allocator
//! 
//! `#import "std/debug_allocator"`
//! 
//! Debug allocator can be used to analyze memory usage and eventually investigate possible memory leaks.
//! Every allocation done via debug allocator is internally recorded with some meta-data included to each
//! allocation. Debug allocator can later panic in situations like double-free, freeing of non-allocated
//! memory; or just report memory usage or memory leaks.
//!
//! Each allocation takes more space due to meta data beeing stored. This allocator also should not be
//! used in production code since it's way much slower than regular allocators.
//!
//! ### Example
//! 
//! ```
//! #import "std/debug_allocator"
//!
//! debug_allocator: std.DebugAllocator;
//!
//! main :: fn () s32 {
//!     using std;
//!     // Initialize debug allocator with current context allocator.
//!     debug_allocator = debug_allocator_make(application_context.allocator);
//!     // Always cleanup at the end of the scope.
//!     defer debug_allocator_terminate(&debug_allocator);
//!
//!     // Some leaking memory.
//!     allocate_memory(&debug_allocator, 128);
//!
//!     // Do some other stuff...
//!
//!     dump_memory_leaks(&debug_allocator);
//!     return 0;
//! }
//! ```
//! 
//! 
//! ```text
//! .\out.exe
//! Dump memory leaks begin:
//!     [1] - C:/Develop/bl/tests/test.bl:13 (128 bytes)
//! Dump memory leaks end.
//! ```
//!
//! !!! note
//!     Debug allocator can be used as global application allocator to catch all possible memory leaks
//!     and other issues.
//! 
//! !!! note
//!     Debug allocator is thread safe.

DebugAllocator :: struct #base Allocator {
    mutex: std.Mutex;
    allocator: *Allocator;
    total_allocated: s64;
    alloc_table: std.Table(*u8, Meta);
    serial: u64;
    break_on: u64;
}

/// Create new debug allocator instace using `allocator` to allocate memory.
debug_allocator_make :: fn (allocator: *Allocator) DebugAllocator {
    dbgalloc: DebugAllocator;
    dbgalloc.handler = auto &handler;
    dbgalloc.allocator = allocator;
    std.tbl_init(&dbgalloc.alloc_table, 2048, dbgalloc.allocator);
    std.mutex_init(&dbgalloc.mutex);
    return dbgalloc;
}

/// Release debug allocator resources.
debug_allocator_terminate :: fn (dbgalloc: *DebugAllocator) {
    std.tbl_terminate(&dbgalloc.alloc_table);
    std.mutex_terminate(&dbgalloc.mutex);
}

/// Invoke `debug_break` before allocation with defined serial ID.
debug_allocator_break :: fn (dbgalloc: *DebugAllocator, serial: u64) #inline {
    dbgalloc.break_on = serial;
}

/// Return currently allocated memory in bytes.
debug_allocator_allocated :: fn (dbgalloc: *DebugAllocator) usize #inline {
    std.mutex_lock(&dbgalloc.mutex);
    defer std.mutex_unlock(&dbgalloc.mutex);
    return auto dbgalloc.total_allocated;
}

/// Print memory report. First block contains currently allocated bytes and current count
/// of allocations. Optional memory leak dump block (enabled by `dump_leaks` argument) contains:
/// 
/// ```text
/// [allocation serial ID] - <file>:<line> (allocation size in bytes) 
/// ``` 
/// 
/// ```text
/// $ ./out.exe
/// ******************* MEMORY REPORT ******************
/// * Allocated 64 Bytes.
/// * Count of allocations 1.
/// ****************************************************
/// Dump memory leaks begin:
///     [1] - test.bl:10 (64 bytes)
/// Dump memory leaks end.
/// ``` 
/// 
/// !!! note
///     Printed report contains all remaining (not freed) allocations in time when function was
///     called. Memory leaks can contain false-positives when function is called before execution end.
/// 
/// !!! note
///     Allocation serail ID can be used by [debug_allocator_break](#debug_allocator_break) to interrupt
///     execution before memory is allocated and eventually localize allocation in debbuger.
print_memory_report :: fn (dbgalloc: *DebugAllocator, dump_leaks := false) {
    std.mutex_lock(&dbgalloc.mutex);
    defer std.mutex_unlock(&dbgalloc.mutex);
    unit := "Bytes";
    total := dbgalloc.total_allocated;
    if total > 1024 { total /= 1024; unit = "kB"; }
    if total > 1024 { total /= 1024; unit = "MB"; }
    if total > 1024 { total /= 1024; unit = "GB"; }
    
    print("******************* MEMORY REPORT ******************\n");
    print("* Allocated % %.\n", total, unit);
    print("* Count of allocations %.\n", dbgalloc.alloc_table.len);
    print("****************************************************\n");

    if dump_leaks && dbgalloc.alloc_table.len > 0 { dump_memory_leaks(dbgalloc); }
}

/// Print only leaking memory if any and returs count of leaking allocations. Please see the
/// [print_memory_report](debug_allocator.md#stdprint_memory_report) for further details.
dump_memory_leaks :: fn (dbgalloc: *DebugAllocator) s64 {
    if dbgalloc.alloc_table.len == 0 { return 0; }
    print("Dump memory leaks begin:\n");
    loop it := std.tbl_begin(&dbgalloc.alloc_table); it != std.tbl_end(&dbgalloc.alloc_table); std.tbl_iter_next(&it) {
        meta :: &it.value;
        print("    [%] - %:% (% bytes)\n", meta.serial, meta.file, meta.line, meta.allocated_size);
    }
    print("Dump memory leaks end.\n");
    return dbgalloc.alloc_table.len;
}

#private
Meta :: struct {
    serial: u64;
    allocated_size: usize;
    alignment: usize;
    file: string_view;
    line: s32;
}

handler :: fn (dbgalloc: *DebugAllocator, operation: AllocOp, size: usize, old_size: usize, ptr: *u8, alignment: usize, file: string_view, line: s32) (mem: *u8, err: Error) {
    using AllocOp;
    switch operation {
        ALLOCATE {
            mem, err :: allocate_memory(dbgalloc.allocator, size, alignment);
            if err { return mem, err; }
            add_allocation(dbgalloc, mem, size, alignment, file, line);
            return mem, err;
        }
        REALLOCATE {
            if ptr {
                previously_allocated_size, previous_alignment :: remove_allocation(dbgalloc, ptr);
                if previously_allocated_size != old_size {
                    panic("Invalid size of previously allocated memory block during reallocation, expected is %B but current is %B. Not all original data would be copied!", previously_allocated_size, old_size);
                }
                if previous_alignment != alignment {
                    panic("Alignment of reallocated memory block must be the same as previous one! Previous alignment is %B and current is %B.", previous_alignment, alignment);
                }
            }
            mem, err :: reallocate_memory(dbgalloc.allocator, ptr, old_size, size, alignment);
            if err { return mem, err; }
            add_allocation(dbgalloc, mem, size, alignment, file, line);
            return mem, OK;
        }
        FREE {
            if ptr {
                remove_allocation(dbgalloc, ptr);
                free_memory(dbgalloc.allocator, ptr);
            }
        }
        default { panic(); }
    }
    return null, OK;
}

add_allocation :: fn (dbgalloc: *DebugAllocator, ptr: *u8, size: usize, alignment: usize, file: string_view, line: s32) {
    mutex_lock(&dbgalloc.mutex);
    defer mutex_unlock(&dbgalloc.mutex);

    dbgalloc.serial += 1;
    if dbgalloc.break_on == dbgalloc.serial { debugbreak; }

    it := tbl_insert(&dbgalloc.alloc_table, ptr);
    it.value.allocated_size = size;
    it.value.alignment = alignment;
    it.value.file = file;
    it.value.line = line;
    it.value.serial = dbgalloc.serial;

    dbgalloc.total_allocated += auto size;
}

remove_allocation :: fn (dbgalloc: *DebugAllocator, ptr: *u8) (size: usize, alignment: usize) {
    mutex_lock(&dbgalloc.mutex);
    defer mutex_unlock(&dbgalloc.mutex);
    it :: tbl_lookup(&dbgalloc.alloc_table, ptr);
    if it == tbl_end(&dbgalloc.alloc_table) {
        panic("Attempt to free already freed or unallocated memory on address %!", ptr);
    }
    meta :: &it.value;
    allocated_size :: meta.allocated_size;
    alignment :: meta.alignment;
    dbgalloc.total_allocated -= auto allocated_size;
    tbl_erase_it(&dbgalloc.alloc_table, it);
    return allocated_size, alignment;
}
