// =================================================================================================
// bl
//
// File:   debug_allocator.bl
// Author: Martin Dorazil
// Date:   18/9/20
//
// Copyright 2020 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

#import "std/sync"
#import "std/table"

#scope std 

//! # Debug Allocator
//! 
//! `#import "std/debug_allocator"`
//! 
//! Debug allocator can be used to analyze memory usage of program and eventually analyze possible 
//! memory leaks. By [init](#init) call the global `context` allocator is replaced by 
//! debug allocator, every following allocations are recorded and analyzed in runtime since then. 
//! Call [terminate](#terminate) to swap default context allocator back to previous 
//! one.
//! 
//! ### Example
//! 
//! ```
//! #import "std/debug_allocator"
//! 
//! main :: fn () s32 {
//!     std.debug_allocator_init();
//!     defer std.debug_allocator_terminate();
//! 
//!     // leaking allocation
//!     alloc(64);
//!     return 0;
//! }
//! ```
//! 
//! 
//! ```text
//! $ ./out.exe
//! ******************* MEMORY REPORT ******************
//! * Allocated 64 Bytes.
//! * Count of allocations 1.
//! ****************************************************
//! Dump memory leaks begin:
//!     [1] - test.bl:10 (64 bytes)
//! Dump memory leaks end.
//! ```
//! 
//! **note**: Debug allocator is thread safe. Init and terminate must be called from main thread.

debug_allocator :: Allocator.{ &handler };

/// Initialize Debug Allocator. This function internally swap current global context allocator to 
/// debug one. Deinitialization must be done by [debug_allocator_terminate](#debug_allocator_terminate) call.
debug_allocator_init :: fn () {
    assert(!_prev_allocator);
    _prev_allocator = _context.allocator;
    _context.allocator = &debug_allocator;
    std.tbl_init(&_alloc_table, 2048, &default_allocator);
    std.mutex_init(&_mutex);
    _is_initialized = true;
}

/// Terminate Debug Allocator. Prints current memory report when 
/// [print_report](#print_report) is `true`.
debug_allocator_terminate :: fn (print_report := true) {
    if !_prev_allocator { return; }
    if print_report {
        print_memory_report(true);
    }
    assert(_prev_allocator);
    _context.allocator = _prev_allocator;
    std.tbl_terminate(&_alloc_table);
    std.mutex_terminate(&_mutex);
    _prev_allocator = null;
    _is_initialized = false;
}

/// Invoke [debug_break](#debug_break) before allocation with defined serial ID.
/// **note**: See also [print_memory_report](#print_memory_report)
debug_allocator_break :: fn (serial: u64) #inline {
    if !_is_initialized { return; }
    _break_on = serial;
}

/// Return currently allocated memory in bytes.
debug_allocator_allocated :: fn () usize #inline {
    if !_is_initialized { return 0; }
    std.mutex_lock(&_mutex);
    defer std.mutex_unlock(&_mutex);
    return auto _total_allocated;
}

/// Print memory report. First block contains currently allocated bytes and current count
/// of allocations. Optional memory leak dump block (enabled by `dump_leaks` argument) contains:
/// 
/// ```text
/// [allocation serial ID] - <file>:<line> (allocation size in bytes) 
/// ``` 
/// 
/// ```text
/// $ ./out.exe
/// ******************* MEMORY REPORT ******************
/// * Allocated 64 Bytes.
/// * Count of allocations 1.
/// ****************************************************
/// Dump memory leaks begin:
///     [1] - test.bl:10 (64 bytes)
/// Dump memory leaks end.
/// ``` 
/// 
/// **note**: Printed report contains all remaining (not freed) allocations in time when function was
/// called. Memory leaks can contain false-positives when function is called before execution end.
/// 
/// **hint**: Allocation serail ID can be used by [debug_allocator_break](#debug_allocator_break) to interrupt 
/// execution before memory is allocated and eventually localize allocation in debbuger.
print_memory_report :: fn (dump_leaks := false) {
    if !_is_initialized { return; }
    std.mutex_lock(&_mutex);
    defer std.mutex_unlock(&_mutex);
    unit := "Bytes";
    total := _total_allocated;
    if total > 1024 { total /= 1024; unit = "kB"; }
    if total > 1024 { total /= 1024; unit = "MB"; }
    if total > 1024 { total /= 1024; unit = "GB"; }
    
    print("******************* MEMORY REPORT ******************\n");
    print("* Allocated % %.\n", total, unit);
    print("* Count of allocations %.\n", _alloc_table.len);
    print("****************************************************\n");

    if dump_leaks && _alloc_table.len > 0 {
        print("Dump memory leaks begin:\n");
        loop it := std.tbl_begin(&_alloc_table); it != std.tbl_end(&_alloc_table); std.tbl_iter_next(&it) {
            meta :: &it.value;
            print("    [%] - %:% (% bytes)\n", meta.serial, meta.file, meta.line, meta.allocated_size);
        }
        print("Dump memory leaks end.\n");
    }
}

#private
_is_initialized := false;
_mutex: std.Mutex;
_total_allocated: s64;
_prev_allocator: *Allocator;
_alloc_table: std.Table(*u8, Meta);
_serial: u64;
_break_on: u64;

Meta :: struct {
    serial: u64;
    allocated_size: usize;
    file: string_view;
    line: s32;
}

handler :: fn (_: *Allocator, operation: AllocOp, size: usize, ptr : *u8 = null, file := std.str_view_empty, line := 0) *u8 {
    using AllocOp;
    switch operation {
        ALLOCATE {
            return debug_malloc(size, file, line);
        }
        FREE {
            debug_free(ptr);
        }
        RELEASE;
        default { panic(); }
    }
    return null;
}

debug_malloc :: fn (size: usize, file: string_view, line: s32) *u8 {
    if size == 0 { panic("Zero allocation!"); }
    allocator :: context(ContextMode.PARENT).allocator;
    mem :: allocator.handler(allocator, AllocOp.ALLOCATE, size);

    std.mutex_lock(&_mutex);
    defer std.mutex_unlock(&_mutex);

    _serial += 1;
    if _break_on == _serial { debugbreak; }

    it := std.tbl_insert(&_alloc_table, mem);
    it.value.allocated_size = size;
    it.value.file = file;
    it.value.line = line;
    it.value.serial = _serial;

    _total_allocated += auto size;
    return mem;
}

debug_free :: fn (ptr: *u8) {
    if ptr == null { return; }
    it :: std.tbl_lookup(&_alloc_table, ptr);
    if it == std.tbl_end(&_alloc_table) { 
        panic("Attempt to free already freed or unallocated memory on address %!", ptr); 
    }
    meta :: &it.value;
    { // CRITICAL
        std.mutex_lock(&_mutex);
        defer std.mutex_unlock(&_mutex);    
        _total_allocated -= auto meta.allocated_size;
        std.tbl_erase_it(&_alloc_table, it);
    }

    allocator :: context(ContextMode.PARENT).allocator;
    allocator.handler(allocator, AllocOp.FREE, 0, ptr);
}
