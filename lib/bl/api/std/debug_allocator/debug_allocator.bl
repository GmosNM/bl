// =================================================================================================
// bl
//
// File:   debug_allocator.bl
// Author: Martin Dorazil
// Date:   18/9/20
//
// Copyright 2020 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

#import "std/sync"
#import "std/table"

#scope std 

//! # Debug Allocator
//! 
//! `#import "std/debug_allocator"`
//! 
//! Debug allocator can be used to analyze memory usage of program and eventually analyze possible 
//! memory leaks. By [init](#init) call the global `context` allocator is replaced by 
//! debug allocator, every following allocations are recorded and analyzed in runtime since then. 
//! Call [terminate](#terminate) to swap default context allocator back to previous 
//! one.
//! 
//! ### Example
//! 
//! ```
//! #import "std/debug_allocator"
//! 
//! main :: fn () s32 {
//!     std.debug_allocator_init();
//!     defer std.debug_allocator_terminate();
//! 
//!     // leaking allocation
//!     alloc(64);
//!     return 0;
//! }
//! ```
//! 
//! 
//! ```text
//! $ ./out.exe
//! ******************* MEMORY REPORT ******************
//! * Allocated 64 Bytes.
//! * Count of allocations 1.
//! ****************************************************
//! Dump memory leaks begin:
//!     [1] - test.bl:10 (64 bytes)
//! Dump memory leaks end.
//! ```
//! 
//! **note**: Debug allocator is thread safe. Init and terminate must be called from main thread.

// @Incomplete: Fix the documentation!
// @Incomplete: Fix the documentation!
// @Incomplete: Fix the documentation!

DebugAllocator :: struct #base Allocator {
    mutex: std.Mutex;
    allocator: *Allocator;
    total_allocated: s64;
    alloc_table: std.Table(*u8, Meta);
    serial: u64;
    break_on: u64;
}

/// Initialize Debug Allocator. This function internally swap current global context allocator to
/// debug one. Deinitialization must be done by [debug_allocator_terminate](#debug_allocator_terminate) call.
debug_allocator_make :: fn (allocator: *Allocator) DebugAllocator {
    dbgalloc: DebugAllocator;
    dbgalloc.handler = auto &handler;
    dbgalloc.allocator = allocator;
    std.tbl_init(&dbgalloc.alloc_table, 2048, dbgalloc.allocator);
    std.mutex_init(&dbgalloc.mutex);
    return dbgalloc;
}

/// Terminate Debug Allocator. Prints current memory report when 
/// [print_report](#print_report) is `true`.
debug_allocator_terminate :: fn (dbgalloc: *DebugAllocator, print_report := true) {
    if print_report {
        print_memory_report(dbgalloc, true);
    }
    std.tbl_terminate(&dbgalloc.alloc_table);
    std.mutex_terminate(&dbgalloc.mutex);
}

/// Invoke [debug_break](#debug_break) before allocation with defined serial ID.
/// **note**: See also [print_memory_report](#print_memory_report)
debug_allocator_break :: fn (dbgalloc: *DebugAllocator, serial: u64) #inline {
    dbgalloc.break_on = serial;
}

/// Return currently allocated memory in bytes.
debug_allocator_allocated :: fn (dbgalloc: *DebugAllocator) usize #inline {
    std.mutex_lock(&dbgalloc.mutex);
    defer std.mutex_unlock(&dbgalloc.mutex);
    return auto dbgalloc.total_allocated;
}

/// Print memory report. First block contains currently allocated bytes and current count
/// of allocations. Optional memory leak dump block (enabled by `dump_leaks` argument) contains:
/// 
/// ```text
/// [allocation serial ID] - <file>:<line> (allocation size in bytes) 
/// ``` 
/// 
/// ```text
/// $ ./out.exe
/// ******************* MEMORY REPORT ******************
/// * Allocated 64 Bytes.
/// * Count of allocations 1.
/// ****************************************************
/// Dump memory leaks begin:
///     [1] - test.bl:10 (64 bytes)
/// Dump memory leaks end.
/// ``` 
/// 
/// **note**: Printed report contains all remaining (not freed) allocations in time when function was
/// called. Memory leaks can contain false-positives when function is called before execution end.
/// 
/// **hint**: Allocation serail ID can be used by [debug_allocator_break](#debug_allocator_break) to interrupt 
/// execution before memory is allocated and eventually localize allocation in debbuger.
print_memory_report :: fn (dbgalloc: *DebugAllocator, dump_leaks := false) {
    std.mutex_lock(&dbgalloc.mutex);
    defer std.mutex_unlock(&dbgalloc.mutex);
    unit := "Bytes";
    total := dbgalloc.total_allocated;
    if total > 1024 { total /= 1024; unit = "kB"; }
    if total > 1024 { total /= 1024; unit = "MB"; }
    if total > 1024 { total /= 1024; unit = "GB"; }
    
    print("******************* MEMORY REPORT ******************\n");
    print("* Allocated % %.\n", total, unit);
    print("* Count of allocations %.\n", dbgalloc.alloc_table.len);
    print("****************************************************\n");

    if dump_leaks && dbgalloc.alloc_table.len > 0 {
        print("Dump memory leaks begin:\n");
        loop it := std.tbl_begin(&dbgalloc.alloc_table); it != std.tbl_end(&dbgalloc.alloc_table); std.tbl_iter_next(&it) {
            meta :: &it.value;
            print("    [%] - %:% (% bytes)\n", meta.serial, meta.file, meta.line, meta.allocated_size);
        }
        print("Dump memory leaks end.\n");
    }
}

#private
Meta :: struct {
    serial: u64;
    allocated_size: usize;
    file: string_view;
    line: s32;
}

handler :: fn (dbgalloc: *DebugAllocator, operation: AllocOp, size: usize, ptr: *u8, _: s32, file: string_view, line: s32) *u8 {
    using AllocOp;
    switch operation {
        ALLOCATE {
            return debug_malloc(dbgalloc, size, file, line);
        }
        REALLOCATE {
            mem :: debug_malloc(dbgalloc, size, file, line);
            if ptr {
                it :: std.tbl_lookup(&dbgalloc.alloc_table, ptr);
                if it == std.tbl_end(&dbgalloc.alloc_table) {
                    panic("Attempt to reallocate invalid address %!", ptr);
                }
                meta :: &it.value;
                assert(meta.allocated_size > 0);
                memcpy(mem, ptr, meta.allocated_size);
                debug_free(dbgalloc, ptr);
            }
            return mem;
        }
        FREE {
            debug_free(dbgalloc, ptr);
        }
        default { panic(); }
    }
    return null;
}

debug_malloc :: fn (dbgalloc: *DebugAllocator, size: usize, file: string_view, line: s32) *u8 {
    mem :: allocate_memory(dbgalloc.allocator, size);

    std.mutex_lock(&dbgalloc.mutex);
    defer std.mutex_unlock(&dbgalloc.mutex);

    dbgalloc.serial += 1;
    if dbgalloc.break_on == dbgalloc.serial { debugbreak; }

    it := std.tbl_insert(&dbgalloc.alloc_table, mem);
    it.value.allocated_size = size;
    it.value.file = file;
    it.value.line = line;
    it.value.serial = dbgalloc.serial;

    dbgalloc.total_allocated += auto size;
    return mem;
}

debug_free :: fn (dbgalloc: *DebugAllocator, ptr: *u8) {
    if ptr == null { return; }
    it :: std.tbl_lookup(&dbgalloc.alloc_table, ptr);
    if it == std.tbl_end(&dbgalloc.alloc_table) {
        panic("Attempt to free already freed or unallocated memory on address %!", ptr); 
    }
    meta :: &it.value;
    { // CRITICAL
        std.mutex_lock(&dbgalloc.mutex);
        defer std.mutex_unlock(&dbgalloc.mutex);
        dbgalloc.total_allocated -= auto meta.allocated_size;
        std.tbl_erase_it(&dbgalloc.alloc_table, it);
    }

    free_memory(dbgalloc.allocator, ptr);
}
