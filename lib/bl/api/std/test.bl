//************************************************************************************************
// bl
//
// File:   test.bl 
// Author: Martin Dorazil
// Date:   2/11/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "std/debug.bl"
#load "std/string.bl"
#load "std/array.bl"

// @DOC
test_eq :: fn {
    str_eq;
    s64_eq;
    u64_eq;
    f32_eq;
    f64_eq;
}

// @DOC
test_neq :: fn {
    str_neq;
    s64_neq;
    u64_neq;
    f32_neq;
    f64_neq;
}

// @DOC
test_true :: fn (v: bool, loc := #call_location) {
    if v { return; }
    print_err("Value expected to be true.");
    assert(false, loc);
}

// @DOC
test_false :: fn (v: bool, loc := #call_location) {
    if !v { return; }
    print_err("Value expected to be false.");
    assert(false, loc);
}

// @DOC
test_null :: fn (ptr: *u8, loc := #call_location) {
    if ptr == null { return; }
    print_err("Pointer is expected to be null.");
    assert(false, loc);
}

// @DOC
test_not_null :: fn (ptr: *u8, loc := #call_location) {
    if ptr != null { return; }
    print_err("Pointer is expected not to be null.");
    assert(false, loc);
}

// @DOC
test_ptr_neq :: fn (got: *u8, not_expected: *u8, loc := #call_location) {
    if got != not_expected { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

// @DOC
test_ptr_eq :: fn (got: *u8, expected: *u8, loc := #call_location) {
    if got == expected { return; }
    print_err("Expected '%' got '%'.", expected, got);
    assert(false, loc);
}

// @DOC
test_run :: fn () s32 {
    cases :: testcases();
    if cases.len == 0 { return 0; }

    print("\n");
    prev_abort_handler :: _context.abort_fn;
    defer _context.abort_fn = prev_abort_handler;

    _context.abort_fn = &abort_handler;
    _ci = 0;

    // setup cases
    array_init(_queue);
    array_reserve(_queue, cases.len);
    defer array_terminate(_queue);

    print("\nTesting start\n");
    print("%\n", TEXT_LINE);

    loop i := 0; i < cases.len; i += 1 {
        array_push(_queue, {:TestRun: &cases[i], false, 0.});
    }

    loop _ci < _queue.len {
        t :: os_thread_create(&worker);
        os_thread_join(t);
    }

    print("\nResults:\n");
    print("%\n", TEXT_LINE);

    fc: s64;
    loop i := 0; i < _queue.len; i += 1 {
        t :: &_queue[i];
        if t.passed { continue; }
        
        fc += 1;
        print("[      | FAIL ] % (% ms)\n", t.case.name, t.runtime_ms);
    }

    perc := 100;
    if fc > 0 { 
        perc = cast(s32) (cast(f32) (_queue.len - fc) / ((cast(f32) _queue.len) * 0.01f));
        print("%\n", TEXT_LINE);
    }

    // @HACK: Cannot print percent, escape sequence cannot be easily detected here.
    print("Executed: %, passed %%.\n", _queue.len, perc, "%");
    print("%\n", TEXT_LINE);
    return auto fc;
}

#private
TestRun :: struct {
    case: *TestCase;
    passed: bool;
    runtime_ms: f64;
}

TEXT_LINE :: "--------------------------------------------------------------------------------";
_queue: [..]TestRun;
_current: *TestRun;
_ci: s64;
_start_time: f64;

abort_handler :: fn () {
    _current.runtime_ms = os_tick_ms() - _start_time;
    _current.passed = false;
    print("[      | FAIL ] % (% ms)\n", _current.case.name, _current.runtime_ms);
    thread :: os_thread_current();
    os_thread_kill(thread, 1);

    unreachable;
}

worker :: fn (args: []Any) {
    loop _ci < _queue.len {
        _current = &_queue[_ci];
        _ci += 1; 

        //print("    RUN  %\n", _current.case.name);

        _start_time = os_tick_ms();
        _current.case.func();
        _current.runtime_ms = os_tick_ms() - _start_time;
        _current.passed = true;
        print("[ PASS |      ] % (% ms)\n", _current.case.name, _current.runtime_ms);
    }
}

str_eq :: fn (got: string, expected: string, loc := #call_location) {
    if string_compare(expected, got) { return; }
    print_err("Expected '%' got '%'.", expected, got);
    assert(false, loc);
}

f32_eq :: fn (got: f32, expected: f32, epsilon: f32 = F32_EPSILON, loc := #call_location) {
    if compare(got, expected, epsilon) { return; }
    print_err("Expected '%' got '%'.", expected, got);
    assert(false, loc);
}

f64_eq :: fn (got: f64, expected: f64, epsilon: f64 = F64_EPSILON, loc := #call_location) {
    if compare(got, expected, epsilon) { return; }
    print_err("Expected '%' got '%'.", expected, got);
    assert(false, loc);
}

s64_eq :: fn (got: s64, expected: s64, loc := #call_location) {
    if got == expected { return; }
    print_err("Expected '%' got '%'.", expected, got);
    assert(false, loc);
}

u64_eq :: fn (got: u64, expected: u64, loc := #call_location) {
    if got == expected { return; }
    print_err("Expected '%' got '%'.", expected, got);
    assert(false, loc);
}

str_neq :: fn (got: string, not_expected: string, loc := #call_location) {
    if !string_compare(not_expected, got) { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

f32_neq :: fn (got: f32, not_expected: f32, epsilon: f32 = F32_EPSILON, loc := #call_location) {
    if !compare(got, not_expected, epsilon) { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

f64_neq :: fn (got: f64, not_expected: f64, epsilon: f64 = F64_EPSILON, loc := #call_location) {
    if !compare(got, not_expected, epsilon) { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

s64_neq :: fn (got: s64, not_expected: s64, loc := #call_location) {
    if got != not_expected { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

u64_neq :: fn (got: u64, not_expected: u64, loc := #call_location) {
    if got != not_expected { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}
