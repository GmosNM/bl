///************************************************************************************************
// bl
//
// File:   test.bl 
// Author: Martin Dorazil
// Date:   2/11/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "std/debug.bl"
#load "std/string.bl"
#load "std/array.bl"
#load "os/posix/signal.bl"

/*!
test_eq
=======

Declaration
-----------
.. code-block:: c

    test_eq :: fn (got: string, expected: string, loc := #call_location)
    test_eq :: fn (got: s64, expected: s64, loc := #call_location)
    test_eq :: fn (got: u64, expected: u64, loc := #call_location)
    test_eq :: fn (got: f32, expected: f32, loc := #call_location)
    test_eq :: fn (got: f64, expected: f64, loc := #call_location)
    test_eq :: fn (got: *u8, expected: *u8, loc := #call_location)

Description
-----------
Test whether `got` value is equal to `expected` value.
 
Arguments
---------
* `got` Value to be checked.
* `expected` Expected value of `got`.
* `loc` Optional call side location.
*/
test_eq :: fn {
    str_eq;
    s64_eq;
    u64_eq;
    f32_eq;
    f64_eq;
    ptr_eq;
}

/*!
test_neq
========

Declaration
-----------
.. code-block:: c

    test_neq :: fn (got: string, not_expected: string, loc := #call_location)
    test_neq :: fn (got: s64, not_expected: s64, loc := #call_location)
    test_neq :: fn (got: u64, not_expected: u64, loc := #call_location)
    test_neq :: fn (got: f32, not_expected: f32, loc := #call_location)
    test_neq :: fn (got: f64, not_expected: f64, loc := #call_location)
    test_neq :: fn (got: *u8, not_expected: *u8, loc := #call_location)

Description
-----------
Test whether `got` value is not equal to `not_expected` value.
 
Arguments
---------
* `got` Value to be checked.
* `not_expected` Not expected value of `got`.
* `loc` Optional call side location.
*/
test_neq :: fn {
    str_neq;
    s64_neq;
    u64_neq;
    f32_neq;
    f64_neq;
    ptr_neq;
}

/*!
test_true
=========

Declaration
-----------
::

    test_true :: fn (v: bool, loc := #call_location) 

Description
-----------
Test whether `v` value is `true`.
 
Arguments
---------
* `v` Value to be checked.
* `loc` Optional call side location.
*/
test_true :: fn (v: bool, loc := #call_location) {
    if v { return; }
    print_err("Value expected to be true.");
    assert(false, loc);
}

/*!
test_false
==========

Declaration
-----------
::

    test_false :: fn (v: bool, loc := #call_location) 

Description
-----------
Test whether `v` value is `false`.
 
Arguments
---------
* `v` Value to be checked.
* `loc` Optional call side location.
*/
test_false :: fn (v: bool, loc := #call_location) {
    if !v { return; }
    print_err("Value expected to be false.");
    assert(false, loc);
}

/*!
test_null
=========

Declaration
-----------
::

    test_null :: fn (ptr: *u8, loc := #call_location) 

Description
-----------
Test whether `ptr` pointer value is `null`.
 
Arguments
---------
* `ptr` Value to be checked.
* `loc` Optional call side location.

 */
test_null :: fn (ptr: *u8, loc := #call_location) {
    if ptr == null { return; }
    print_err("Pointer is expected to be null.");
    assert(false, loc);
}

/*!
test_not_null
=============

Declaration
-----------
::

    test_not_null :: fn (ptr: *u8, loc := #call_location)

Description
-----------
Test whether `ptr` pointer value is not `null`.

Arguments
---------
* `ptr` Value to be checked.
* `loc` Optional call side location.
*/
test_not_null :: fn (ptr: *u8, loc := #call_location) {
    if ptr != null { return; }
    print_err("Pointer is expected not to be null.");
    assert(false, loc);
}

/*!
test_run
========

Declaration
-----------
::

    test_run :: fn () s32

Description
-----------
Execute all registered test cases in current assembly. The `test_run` function
uses compiler builtin `testcases()` function returning slice of all registered 
test cases in the current assembly (all function with hash directive `#test`).

Test case execution can be used in runtime and compile time, in both cases
function remap default behaviour of `panic()` function call and try to report
all failing tests without execution termination.

Formatted output containing information about every test run status and summary
report is produced during execution of this function. In case of test failure
all needed information about fail source location is reported into standard
output.

Result
------
Number of failed tests.

Example
-------
.. code-block:: c
    
    #load "std/test.bl"
    
    my_test :: fn () #test {
        print("Hello from test case!!!\n");     
    }

    main :: fn () s32 {
        return test_run(); 
    } 

*/
test_run :: fn () s32 {
    sighup :: fn (v: c_int) {};
    _signal(_SIGHUP, &sighup);

    cases :: testcases();
    if cases.len == 0 { return 0; }
        
    print("\n");
    prev_abort_handler :: _context.abort_fn;
    defer _context.abort_fn = prev_abort_handler;

    _context.abort_fn = &abort_handler;
    _ci = 0;

    // setup cases
    array_init(_queue);
    array_reserve(_queue, cases.len);
    defer array_terminate(_queue);

    print("\nTesting start\n");
    print("%\n", TEXT_LINE);

    loop i := 0; i < cases.len; i += 1 {
        array_push(_queue, {:TestRun: &cases[i], false, 0.});
    }

    loop _ci < _queue.len {
        t :: os_thread_create(&worker);
        os_thread_join(t);
    }

    print("\nResults:\n");
    print("%\n", TEXT_LINE);

    fc: s64;
    loop i := 0; i < _queue.len; i += 1 {
        t :: &_queue[i];
        if t.passed { continue; }
        
        fc += 1;
        print("[      | FAIL ] % (% ms)\n", t.case.name, t.runtime_ms);
    }

    perc := 100;
    if fc > 0 { 
        perc = cast(s32) (cast(f32) (_queue.len - fc) / ((cast(f32) _queue.len) * 0.01f));
        print("%\n", TEXT_LINE);
    }

    // @HACK: Cannot print percent, escape sequence cannot be easily detected here.
    print("Executed: %, passed %%.\n", _queue.len, perc, "%");
    print("%\n", TEXT_LINE);
    return auto fc;
}

#private
TestRun :: struct {
    case: *TestCase;
    passed: bool;
    runtime_ms: f64;
}

TEXT_LINE :: "--------------------------------------------------------------------------------";
_queue: [..]TestRun;
_current: *TestRun;
_ci: s64;
_start_time: f64;

abort_handler :: fn () {
    _current.runtime_ms = os_tick_ms() - _start_time;
    _current.passed = false;
    print("[      | FAIL ] % (% ms)\n", _current.case.name, _current.runtime_ms);
    thread :: os_thread_current();
    os_thread_kill(thread, 1);    
}

worker :: fn (args: []Any) {
    loop _ci < _queue.len {
        _current = &_queue[_ci];
        _ci += 1; 

        //print("    RUN  %\n", _current.case.name);

        _start_time = os_tick_ms();
        _current.case.func();
        _current.runtime_ms = os_tick_ms() - _start_time;
        _current.passed = true;
        print("[ PASS |      ] % (% ms)\n", _current.case.name, _current.runtime_ms);
    }
}

str_eq :: fn (got: string, expected: string, loc := #call_location) {
    if string_compare(expected, got) { return; }
    print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
    assert(false, loc);
}

f32_eq :: fn (got: f32, expected: f32, epsilon: f32 = F32_EPSILON, loc := #call_location) {
    if compare(got, expected, epsilon) { return; }
    print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
    assert(false, loc);
}

f64_eq :: fn (got: f64, expected: f64, epsilon: f64 = F64_EPSILON, loc := #call_location) {
    if compare(got, expected, epsilon) { return; }
    print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
    assert(false, loc);
}

s64_eq :: fn (got: s64, expected: s64, loc := #call_location) {
    if got == expected { return; }
    print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
    assert(false, loc);
}

u64_eq :: fn (got: u64, expected: u64, loc := #call_location) {
    if got == expected { return; }
    print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
    assert(false, loc);
}

ptr_neq :: fn (got: *u8, not_expected: *u8, loc := #call_location) {
    if got != not_expected { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

str_neq :: fn (got: string, not_expected: string, loc := #call_location) {
    if !string_compare(not_expected, got) { return; }
    print_err("\nExpected not to be '%'.", not_expected);
    assert(false, loc);
}

f32_neq :: fn (got: f32, not_expected: f32, epsilon: f32 = F32_EPSILON, loc := #call_location) {
    if !compare(got, not_expected, epsilon) { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

f64_neq :: fn (got: f64, not_expected: f64, epsilon: f64 = F64_EPSILON, loc := #call_location) {
    if !compare(got, not_expected, epsilon) { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

s64_neq :: fn (got: s64, not_expected: s64, loc := #call_location) {
    if got != not_expected { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

u64_neq :: fn (got: u64, not_expected: u64, loc := #call_location) {
    if got != not_expected { return; }
    print_err("Expected not to be '%'.", not_expected);
    assert(false, loc);
}

ptr_eq :: fn (got: *u8, expected: *u8, loc := #call_location) {
    if got == expected { return; }
    print_err("Expected '%' got '%'.", expected, got);
    assert(false, loc);
}
