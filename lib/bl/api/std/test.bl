//************************************************************************************************
// bl
//
// File:   test.bl 
// Author: Martin Dorazil
// Date:   2/11/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "std/debug.bl"
#load "std/string.bl"
#load "std/array.bl"

// @DOC
test_str_eq :: fn (got: string, expected: string, loc: *CallLocation = #call_location) {
    if string_compare(expected, got) { return; }
    eprint("Expected '%' got '%'.\n", expected, got);
    assert(false, loc);
}

// @DOC
test_str_neq :: fn (got: string, expected: string, loc: *CallLocation = #call_location) {
    if !string_compare(expected, got) { return; }
    eprint("Expected not to be '%'.\n", expected);
    assert(false, loc);
}

// @DOC
test_f32_eq :: fn (got: f32, expected: f32, epsilon: f32, loc: *CallLocation = #call_location) {
    if f32_compare(got, expected, epsilon) { return; }
    eprint("Expected '%' got '%'.\n", expected, got);
    assert(false, loc);
}

// @DOC
test_f64_eq :: fn (got: f64, expected: f64, epsilon: f64, loc: *CallLocation = #call_location) {
    if f64_compare(got, expected, epsilon) { return; }
    eprint("Expected '%' got '%'.\n", expected, got);
    assert(false, loc);
}

// @DOC
test_s32_eq :: fn (got: s32, expected: s32, loc: *CallLocation = #call_location) {
    if got == expected { return; }
    eprint("Expected '%' got '%'.\n", expected, got);
    assert(false, loc);
}

// @DOC
test_run :: fn () s32 {
    cases :: testcases();
    if cases.len == 0 { return 0; }

    print("\n");
    prev_abort_handler :: _context.abort_fn;
    defer _context.abort_fn = prev_abort_handler;

    _context.abort_fn = &abort_handler;
    _ci = 0;

    // setup cases
    array_init(_queue);
    array_reserve(_queue, cases.len);
    defer array_terminate(_queue);

    print("\nTesting start\n");
    print("%\n", TEXT_LINE);

    loop i := 0; i < cases.len; i += 1 {
        array_push(_queue, {:TestRun: &cases[i], false, 0.});
    }

    loop _ci < _queue.len {
        t :: os_thread_create(&worker);
        os_thread_join(t);
    }

    print("\nResults:\n");
    print("%\n", TEXT_LINE);

    fc: s64;
    loop i := 0; i < _queue.len; i += 1 {
        t :: &_queue[i];
        if t.passed { continue; }
        
        fc += 1;
        print("[      | FAIL ] % (% ms)\n", t.case.name, t.runtime_ms);
    }

    perc := 100;
    if fc > 0 { 
        perc = cast(s32) (cast(f32) (_queue.len - fc) / ((cast(f32) _queue.len) * 0.01f));
        print("%\n", TEXT_LINE);
    }

    // @HACK: Cannot print percent, escape sequence cannot be easily detected here.
    print("Executed: %, passed %%.\n", _queue.len, perc, "%");
    print("%\n", TEXT_LINE);
    return auto fc;
}

#private
TestRun :: struct {
    case: *TestCase;
    passed: bool;
    runtime_ms: f64;
}

TEXT_LINE :: "--------------------------------------------------------------------------------";
_queue: [..]TestRun;
_current: *TestRun;
_ci: s64;
_start_time: f64;

abort_handler :: fn () {
    _current.runtime_ms = os_tick_ms() - _start_time;
    _current.passed = false;
    print("[      | FAIL ] % (% ms)\n", _current.case.name, _current.runtime_ms);
    thread :: os_thread_current();
    os_thread_kill(thread, 1);

    unreachable;
}

worker :: fn (args: []Any) {
    loop _ci < _queue.len {
        _current = &_queue[_ci];
        _ci += 1; 

        //print("    RUN  %\n", _current.case.name);

        _start_time = os_tick_ms();
        _current.case.func();
        _current.runtime_ms = os_tick_ms() - _start_time;
        _current.passed = true;
        print("[ PASS |      ] % (% ms)\n", _current.case.name, _current.runtime_ms);
    }
}
