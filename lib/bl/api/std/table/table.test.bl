#import "std/test"
#import "std/debug_allocator"
#import "std/table"

main :: fn () s32 {
    DebugAllocator.init();
    defer DebugAllocator.terminate();
    return test_run();
}

#private
TEST_COUNT :: 100000;

DATA :: {:[10]string:
         "Melisa Britt",
         "Theodor Cooper",
         "Laylah Simons",
         "Romeo Walls",
         "Carlo Daniel",
         "Maggie Munoz",
         "Tina Hawes",
         "Raiden Garrison",
         "Ikrah Alston",
         "Adela Cornish"};

// =================================================================================================
// Global
// =================================================================================================
g_tbl: std.Table(s32, s32);

test_insert :: fn () #test {
    loop i := 0; i < TEST_COUNT; i += 1 {
        std.tbl_insert(&g_tbl, i, i);
    }
}

test_lookup :: fn () #test {
    loop i := 0; i < TEST_COUNT; i += 1 {
        it :: std.tbl_lookup(&g_tbl, i);
        test_eq(it.key, i);
        test_eq(it.value, i);
    }
}

test_contains :: fn () #test {
    loop i := 0; i < TEST_COUNT; i += 1 {
        test_true(std.tbl_contains(&g_tbl, i));
    }
    test_false(std.tbl_contains(&g_tbl, -1));
    test_false(std.tbl_contains(&g_tbl, -2));
}

test_terminate :: fn () #test {
    std.tbl_terminate(&g_tbl);
}
// =================================================================================================
// Single Tests
// =================================================================================================

test_uninitialized :: fn () #test {
    tbl: std.Table(s32, s32);
    defer std.tbl_terminate(&tbl);

    test_eq(tbl.len, 0);
    test_eq(std.tbl_begin(&tbl), std.tbl_end(&tbl));

    loop i := 0; i < TEST_COUNT; i += 1 {
        it :: std.tbl_lookup(&tbl, i);
        test_eq(it, std.tbl_end(&tbl));
    }

    loop i := 0; i < TEST_COUNT; i += 1 {
        test_false(std.tbl_contains(&tbl, i));
    }

    c := 0;
    loop it := std.tbl_end(&tbl); it != std.tbl_begin(&tbl); std.tbl_iter_prev(&it) {
        c += 1;
    }
    test_eq(c, 0);
    loop it := std.tbl_begin(&tbl); it != std.tbl_end(&tbl); std.tbl_iter_next(&it) {
        c += 1;
    }
    test_eq(c, 0);

    std.tbl_clear(&tbl);
    test_eq(tbl.len, 0);
    test_eq(std.tbl_begin(&tbl), std.tbl_end(&tbl));
}

test_simple_begin_end :: fn () #test {
    tbl: std.Table(s32, s32);
    defer std.tbl_terminate(&tbl);

    std.tbl_insert(&tbl, 10, 20);

    test_eq(tbl.len, 1);
    test_neq(std.tbl_begin(&tbl), std.tbl_end(&tbl));
}

test_clear :: fn () #test {
    tbl: std.Table(s32, s32);
    defer std.tbl_terminate(&tbl);

    loop i := 0; i < TEST_COUNT; i += 1 {
        std.tbl_insert(&tbl, i, i);
    }
    test_eq(tbl.len, TEST_COUNT);

    std.tbl_clear(&tbl);
    test_eq(tbl.len, 0);
    test_eq(std.tbl_begin(&tbl), std.tbl_end(&tbl));

    loop i := 0; i < TEST_COUNT; i += 1 {
        std.tbl_insert(&tbl, i, i);
    }
    test_eq(tbl.len, TEST_COUNT);
}

test_hashing :: fn () #test {
    index :: fn (i: u64) u64 {
        if i % 2 == 0 { return i * -1; }
        return i;
    };

    tbl: std.Table(u64, s32);
    defer std.tbl_terminate(&tbl);

    loop i : u64 = 0; i < auto TEST_COUNT; i += 1 {
        std.tbl_insert(&tbl, index(i), auto i);
    }
    test_eq(tbl.len, TEST_COUNT);

    loop i : u64 = 0; i < auto TEST_COUNT; i += 1 {
        test_true(std.tbl_contains(&tbl, index(i)));
    }
}

test_erase :: fn () #test {
    tbl: std.Table(s32, s32);
    defer std.tbl_terminate(&tbl);

    loop i := 0; i < TEST_COUNT; i += 1 {
        std.tbl_insert(&tbl, i, i);
    }
    test_eq(tbl.len, TEST_COUNT);

    loop i := 0; i < TEST_COUNT; i += 1 {
        test_true(std.tbl_erase(&tbl, i));
    }
    test_eq(tbl.len, 0);
    test_eq(std.tbl_begin(&tbl), std.tbl_end(&tbl));
}

test_erase2 :: fn () #test {
    tbl: std.Table(u64, s32);
    defer std.tbl_terminate(&tbl);

    loop i : u64 = 0; i < auto TEST_COUNT; i += 1 {
        std.tbl_insert(&tbl, Math.U64_MAX - i, auto i);
    }
    test_eq(tbl.len, TEST_COUNT);

    loop i : u64 = 0; i < auto TEST_COUNT; i += 1 {
        test_true(std.tbl_erase(&tbl, Math.U64_MAX - i));
    }
    test_eq(tbl.len, 0);
    test_eq(std.tbl_begin(&tbl), std.tbl_end(&tbl));
}

test_use_after_erase :: fn () #test {
    tbl: std.Table(s32, s32);
    defer std.tbl_terminate(&tbl);

    loop j := 0; j < 10; j += 1 {
        loop i := 0; i < TEST_COUNT / 2; i += 1 {
            std.tbl_insert(&tbl, i, i);
        }
        test_eq(tbl.len, TEST_COUNT / 2);

        loop i := 0; i < TEST_COUNT / 2; i += 1 {
            test_true(std.tbl_erase(&tbl, i));
        }
        test_eq(tbl.len, 0);
        test_eq(std.tbl_begin(&tbl), std.tbl_end(&tbl));
    }
}

test_struct :: fn () #test {
    Elem :: struct {
        a: s32;
        b: string;
        c: bool;
        d: s32;
    };

    tbl: std.Table(s32, Elem);
    defer std.tbl_terminate(&tbl);

    loop i := 0; i < TEST_COUNT; i += 1 {
        std.tbl_insert(&tbl, i, {:Elem: i, "hello", true, i});
    }
    test_eq(tbl.len, TEST_COUNT);
    c := 0;
    loop it := std.tbl_begin(&tbl); it != std.tbl_end(&tbl); std.tbl_iter_next(&it) {
        test_eq(it.value.a, it.value.d);
        c += 1;
    }
    test_eq(c, TEST_COUNT);

    loop i := 0; i < TEST_COUNT; i += 1 {
        test_true(std.tbl_erase(&tbl, i));
    }
    test_eq(tbl.len, 0);
}

test_iteration :: fn () #test {
    tbl: std.Table(s32, s32);
    defer std.tbl_terminate(&tbl);

    loop i := 0; i < TEST_COUNT; i += 1 {
        std.tbl_insert(&tbl, i, i);
    }

    c := 0;
    loop it := std.tbl_begin(&tbl); it != std.tbl_end(&tbl); std.tbl_iter_next(&it) {
        c += 1;
    }
    test_eq(c, TEST_COUNT);
}

test_iteration_reverse :: fn () #test {
    tbl: std.Table(s32, s32);
    defer std.tbl_terminate(&tbl);

    loop i := 0; i < TEST_COUNT; i += 1 {
        std.tbl_insert(&tbl, i, i);
    }

    c := 0;
    loop it := std.tbl_end(&tbl); it != std.tbl_begin(&tbl); std.tbl_iter_prev(&it) {
        c += 1;
    }
    test_eq(c, TEST_COUNT);
}

test_string_keys_1 :: fn () #test {
    tbl: std.Table(string, s32);
    defer std.tbl_terminate(&tbl);

    std.tbl_insert(&tbl, "Martin", 10);

    it :: std.tbl_lookup(&tbl, "Martin");
    test_eq(it.key, "Martin");
    test_eq(it.value, 10);
}

test_string_keys_2 :: fn () #test {
    tbl: std.Table(string, s32);
    defer std.tbl_terminate(&tbl);

    loop i := 0; i < DATA.len; i += 1 {
        std.tbl_insert(&tbl, DATA[i], i);
    }

    loop i := 0; i < DATA.len; i += 1 {
        it :: std.tbl_lookup(&tbl, DATA[i]);
        test_neq(it, std.tbl_end(&tbl));
        test_eq(it.key, DATA[i]);
        test_eq(it.value, i);
    }
}
