//! # Table
//!
//! `#import "std/table"`
//!
//! Tables are generic data containers aka hash tables or hash maps that store data entries
//! as pairs of Keys and Values. Table provides fast lookup on large amount of data.
//!
//! Internally, the table is implemented as a simple flat array of preallocated data slots. New
//! memory is allocated by default for `DEFAULT_ENTRIES_COUNT` slots on the first insertion call.
//! Hash for the insert entry is computed and the entry is stored `hash % entries.len` index into
//! the table `entries` array. Next free slot `index + N` is used in case of collision with already
//! existing entries.
//!
//! Performance of table insert and lookup is getting worse when the table is starting to be full,
//! this metric is represented as a table load factor (calculated as: `load_factor = len / entries.len`).
//! When the `load_factor` is greater than `LOAD_FACTOR` value (i.e. 70%) the whole table is recreated
//! with larger internal `entries` storage (new `entries.len` is calculated as the next power of two of
//! the current `entries.len`). Otherwise the insertion does not cause any memory allocations.
//!
//! Current table implementation is not heavily optimized, this should be improved later, consider
//! using a custom implementation in performance-critical cases.
//!
//! !!! warning
//!     Table entries are not sorted in any particular way so the iteration over the
//!     table does not correspond to the order in which elements were inserted. Which also means
//!     that there is no need to provide reverse iteration api.
//!
//! !!! warning
//!     The key types are limited to numbers and strings (this may change in the future).
//!
//! ### Example
//! ```c
//! #import "std/table"
//!
//! main :: fn () s32 {
//!     using std;
//!     table: Table(string, s32);
//!     defer tbl_terminate(&table);
//!
//!     // Insert some data into the table.
//!     tbl_insert(&table, "Martin", 32);
//!     tbl_insert(&table, "Lisa", 29);
//!     tbl_insert(&table, "John", 40);
//!
//!     // Lookup data by key.
//!     found :: tbl_lookup(&table, "Martin");
//!     if found != tbl_end(&table) {
//!         print("[%] %\n", found.key, found.value);
//!     }
//!
//!     // Iterate over the table
//!     loop it := tbl_begin(&table); it != tbl_end(&table); tbl_iter_next(&table, &it) {
//!         print("[%] %\n", it.key, it.value);
//!     }
//!
//!     return 0;
//! }
//! ```
//!

#scope std

// The implementation is partially based on Jonathan Blow's hash table https://www.youtube.com/watch?v=k9MBMvR2IvI.

/// Create a new **Table** type. The `TKey` must be a number or string type.
///
/// ```c
/// Table :: struct {
///     len: s64;
/// }
/// ```
Table :: fn (TKey: type, TValue: type) type #comptime {
    static_assert(TKey == string || is_number(TKey) || is_pointer(TKey) || TKey == string_view);
    TEntry :: Entry(TKey, TValue);
    return struct {
        entries: []TEntry;
        end: *u8;
        len: s64;
        allocator: *Allocator;
    };
}

/// Create iterator type from **Table** type as pointer to the table entry.
///
/// ```c
/// TableIter :: struct {
///     key: TKey;
///     value: TValue;
/// }
/// ```
TableIter :: fn (TTable: type) type #comptime {
    return *typeof_entry(TTable);
}

/// Initialize the `tbl` table. It's not necessary to call this method in case the table is
/// already zero-initialized. The `expected_size` can be specified as hint telling the table how many
/// elements we're going to store. Memory to hold an internal meta-data is allocated here. The custom
/// `allocator` can be specified.
tbl_init :: fn (tbl: *?T, expected_size := DEFAULT_ENTRIES_COUNT, allocator: *Allocator = null) {
    assert(tbl);
    tbl.allocator = allocator;
    tbl.len = 0;
    resize(tbl, expected_size);
}

/// Release all memory resources used by the table and set the `tbl` instance to the default state.
tbl_terminate :: fn (tbl: *?T) {
    assert(tbl);
    slice_terminate(&tbl.entries, tbl.allocator);
    zeromem(auto tbl, sizeof(T));
}

/// Overloaded table insert function adding new element into the table associated with the `key`.
/// The `key` value must be unique (not already existing in the table), this is checked in debug
/// mode and panic is invoked in case of collision.
///
/// **Overloads:**
/// ```c
/// fn (tbl: *?T, key: tbl_typeof_key(T), value: tbl_typeof_value(T)) TableIter(T) #inline
/// fn (tbl: *?T, key: tbl_typeof_key(T)) TableIter(T) #inline
/// ```
///
/// Function returns iterator pointing to the new entry. Every new entry is allocated in the
/// preallocated `table.entries` storage. Rehashing of the table can be eventually done in case the
/// table's load factor goes over `LOAD_FACTOR`.
///
/// !!! note
///     Iterator's value in case the `value` is not specified is NOT zero initialized.
tbl_insert :: fn { impl_insert_empty; impl_insert; }

/// Checks whether the table `tbl` contains the `key`.
tbl_contains :: fn (tbl: *?T, key: tbl_typeof_key(T)) bool #inline {
    assert(tbl);
    if !is_initialized(tbl) { return false; }
    return lookup_entry(tbl, calculate_hash(key)) != tbl_end(tbl);
}

/// Lookup entry associated with the `key` value in the table and return an iterator pointing to
/// the key-value pair. In case there is no such entry in the table, the function returns an iterator
/// pointing to the `tbl_end()`.
tbl_lookup :: fn (tbl: *?T, key: tbl_typeof_key(T)) TableIter(T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { return tbl_end(tbl); }
    return lookup_entry(tbl, calculate_hash(key));
}

/// Clears the table, but keeps allocated memory.
tbl_clear :: fn (tbl: *?T) #inline {
    assert(tbl);
    loop i := 0; i < tbl.entries.len; i += 1 {
        tbl.entries[i].hash = EMPTY_HASH;
    }
    tbl.len = 0;
}

/// Erase table entry associated with `key`. The `key` must be an existing key in the table, otherwise
/// `panic` is invoked.
///
/// Returns iterator pointing to the next entry or to the `tbl_end()`.
tbl_erase :: fn (tbl: *?T, key: tbl_typeof_key(T)) TableIter(T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { return tbl_end(tbl); }
    it :: lookup_entry(tbl, calculate_hash(key));
    if it == tbl_end(tbl) { panic("Attempt to erase non-existing key '%' from table.", key); }
    return tbl_erase_iter(tbl, it);
}

/// Erase table entry associated with `it` iterator. In case the `it` points to the table end, the
/// function invoke `panic`.
///
/// Returns iterator pointing to the next entry or to the `tbl_end()`.
tbl_erase_iter :: fn (tbl: *?T, it: TableIter(T)) TableIter(T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { return tbl_end(tbl); }
    if it == tbl_end(tbl) { panic("Attempt to erase iterator pointing to the end of the table."); }
    next := it;
    tbl_iter_next(tbl, &next);
    it.hash = DELETED_HASH;
    assert(tbl.len > 0);
    tbl.len -= 1;
    return next;
}

/// Return an iterator pointing to the table beginning.
///
/// !!! note
///     Same as `tbl_end()` in case the table is empty.
tbl_begin :: fn (tbl: *?T) TableIter(T) #inline {
    assert(tbl);
    if tbl.len == 0 { return tbl_end(tbl); }
    loop i := 0; i < tbl.entries.len; i += 1 {
        entry := &tbl.entries[i];
        if entry.hash >= FIRST_VALID_HASH {
            return entry;
        }
    }
    panic();
    return null;
}

/// Return an iterator pointing to the table ending.
tbl_end :: fn (tbl: *?T) TableIter(T) #inline {
    assert(tbl);
    return auto &tbl.end;
}

/// Move the iterator `it` to the next element or to the `tbl_end()`
tbl_iter_next :: fn (tbl: *?TTable, it: *TableIter(TTable)) #inline {
    assert(tbl);
    assert(it && @it);
    if !is_initialized(tbl) { return; }
    if it == auto tbl.end { return; }
    index := ptr_diff(@it, tbl.entries.ptr) / cast(s64) sizeof(typeof_entry(TTable));
    assert(index >= 0);
    assert(index < tbl.entries.len);
    loop i := index+1; i < tbl.entries.len; i += 1 {
        entry := &tbl.entries[i];
        if entry.hash >= FIRST_VALID_HASH {
            @it = entry;
            return;
        }
    }
    @it = tbl_end(tbl);
}

/// Resolve type of key from table type in compiletime.
tbl_typeof_key :: fn (TTable: type) type #comptime {
    return (@TTable.entries.ptr).key;
}

/// Resolve type of value from table type in compiletime.
tbl_typeof_value :: fn (TTable: type) type #comptime {
    return (@TTable.entries.ptr).value;
}

//insert_collision_count: s64;
//lookup_collision_count: s64;

#private
DEFAULT_ENTRIES_COUNT :: 64;
LOAD_FACTOR :: 0.7f #maybe_unused;
EMPTY_HASH : u64 : 0 #maybe_unused;
DELETED_HASH : u64 : 1 #maybe_unused;
FIRST_VALID_HASH : u64 : 2 #maybe_unused;

Entry :: fn (TKey: type, TValue: type) type #comptime {
    return struct {
        hash: u64;
        key: TKey;
        value: TValue;
    };
}

typeof_entry :: fn (T: type) type #comptime {
    return @T.entries.ptr;
}

is_initialized :: fn (tbl: *?T) bool #inline {
    return tbl.entries.ptr;
}

calculate_hash :: fn (key: ?T) u64 #inline {
    is_string :: T == string || T == string_view;
    hash: u64;
    #if is_string {
        hash = auto std.str_hash(key);
    } else {
        // copy-paste from stack overflow, is it good or not???
        // https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
        x: u64 = auto key;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        x = x ^ (x >> 31);
        hash = x;
    }
    if hash < FIRST_VALID_HASH { hash += FIRST_VALID_HASH; }
    return hash;
}

hash_to_index :: fn (entries_len: s64, hash: u64) s64 #inline #maybe_unused {
    return auto (hash % auto entries_len);
}

initial_increment :: fn (tbl: *?T, hash: u64) s64 #inline {
    return auto 1 + hash % (cast(u64) tbl.entries.len - 1);
}

impl_insert :: fn (tbl: *?T, key: tbl_typeof_key(T), value: tbl_typeof_value(T)) TableIter(T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { resize(tbl); }
    #if IS_DEBUG {
        if tbl_contains(tbl, key) { panic("Duplicate key entry '%' in table!", key); }
    }
    entry := insert(tbl, calculate_hash(key), key);
    memcpy(auto &entry.value, auto &value, sizeof(value));
    return entry;
}

impl_insert_empty :: fn (tbl: *?T, key: tbl_typeof_key(T)) TableIter(T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { resize(tbl); }
    return insert(tbl, calculate_hash(key), key);
}

insert :: fn (tbl: *?T, hash: u64, key: tbl_typeof_key(T)) TableIter(T) {
    assert(tbl);
    assert(is_initialized(tbl));
    load_factor :: cast(f32)(tbl.len + 1) / cast(f32)tbl.entries.len;
    if load_factor > LOAD_FACTOR {
        resize(tbl, auto next_pow_2(auto tbl.entries.len));
    }
    index := hash_to_index(tbl.entries.len, hash);
    increment := initial_increment(tbl, hash);
    entry: *typeof_entry(T);
    loop {
        entry = &tbl.entries[index];
        if entry.hash == EMPTY_HASH || entry.hash == DELETED_HASH {
            break;
        }
        //insert_collision_count += 1;
        index += increment;
        increment += 1;
        if index >= tbl.entries.len { index -= tbl.entries.len; }
    }
    entry.hash = hash;
    entry.key = key;
    tbl.len += 1;
    return entry;
}

lookup_entry :: fn (tbl: *?T, hash: u64) *typeof_entry(T) {
    assert(is_initialized(tbl));
    index := hash_to_index(tbl.entries.len, hash);
    increment := initial_increment(tbl, hash);
    loop {
        entry :: &tbl.entries[index];
        if entry.hash == hash { return entry; }
        if entry.hash == 0 { break; }
        //lookup_collision_count += 1;
        index += increment;
        increment += 1;
        if index >= tbl.entries.len { index -= tbl.entries.len; }
    }
    return tbl_end(tbl);
}

resize :: fn (tbl: *?T, new_size : s64 = DEFAULT_ENTRIES_COUNT) {
    old_entries :: tbl.entries;
    assert(new_size > 32);
    slice_init(&tbl.entries, new_size, false, tbl.allocator);
    loop i := 0; i < tbl.entries.len; i += 1 {
        tbl.entries[i].hash = EMPTY_HASH;
    }
    tbl.len = 0;
    loop i := 0; i < old_entries.len; i += 1 {
        old_entry :: &old_entries[i];
        if old_entry.hash < FIRST_VALID_HASH { continue; }
        entry := insert(tbl, old_entry.hash, old_entry.key);
        memcpy(auto &entry.value, auto &old_entry.value, sizeof(old_entry.value));
    }
    slice_terminate(&old_entries, tbl.allocator);
}
