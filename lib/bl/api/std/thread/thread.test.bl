#load "std/test.bl"
#load "std/debug_allocator.bl"

#import "std/thread"

main :: fn () s32 {
    dbgalloc_init();
    defer dbgalloc_terminate();
    return test_run();    
}

#private
thread_create_test :: fn () #test {
    t, err :: thread_create(null);
    test_not_ok(err);
}

_worker_called: s32;

thread_create_test2 :: fn () #test {
    worker :: fn (args: ...) s32 {
        _worker_called += 1;
        return 0;
    };
    
    t, err :: thread_create(&worker);
    test_ok(err);

    code, err2 :: thread_join(t, 1000);
    test_ok(err2);
    test_eq(code, 0);
    test_eq(_worker_called, 1);
    _worker_called = 0;
}

thread_create_test3 :: fn () #test {
    worker :: fn (args: ...) s32 {
        _worker_called += 1;
        return 666;
    };
    
    t, err :: thread_create(&worker);
    test_ok(err);

    code, err2 :: thread_join(t, 1000);
    test_ok(err2);
    test_eq(code, 666);
    test_eq(_worker_called, 1);
    _worker_called = 0;
}

thread_create_test4 :: fn () #test {
    worker :: fn (args: ...) s32 {
        sum: s32;
        loop i := 0; i < args.len; i += 1 {
            arg :: &args[i];
            sum += ^(cast(*s32) arg.data);
        }
        _worker_called += 1;
        return sum;
    };
    
    t, err :: thread_create(&worker, 10, 20, 30);
    test_ok(err);

    code, err2 :: thread_join(t, 1000);
    test_ok(err2);
    test_eq(code, 60);
    test_eq(_worker_called, 1);
    _worker_called = 0;
}