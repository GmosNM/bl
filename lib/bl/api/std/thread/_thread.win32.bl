#load "thread.bl"
#load "os/windows/winapi.bl"

_ImplThread :: _HANDLE;

_thread_impl_create :: fn (entry: ThreadEntryFn, args: ...) (Thread, Error) {
    if !entry { return null, error(ERR_INVALID_HANDLE, "Cannot create thread. Handle is invalid."); }
    tmp: *_ThreadArgs = auto alloc(sizeof(_ThreadArgs));
    tmp.entry = entry;
    tmp.args = args;
    thread :: _CreateThread(null, 0, &thread_entry, auto tmp, 0, null);
    if !thread {
        free(auto tmp);
        ec, estr :: os_get_last_error();
        return null, error(ec, "Cannot create thread: %.", estr);
    }
    return thread, ok();
}

_thread_impl_join :: fn (thread: Thread, timeout_ms := _INFINITE) Error {
    if !thread { error(ERR_INVALID_HANDLE, "Cannot join. Handle is invalid."); }
    if _WaitForSingleObject(thread, timeout_ms) == _WAIT_FAILED {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot join: %.", estr);
    }
    if _CloseHandle(thread) == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot join: %.", estr);
    }
    return ok();
}

#private
_ThreadArgs :: struct {
    entry: ThreadEntryFn;
    args: ...; 
}

thread_entry :: fn (_args: *u8) u32 {
    tmp :: cast(*_ThreadArgs) _args;
    defer free(auto tmp);
    tmp.entry(tmp.args);
    return 0;
}