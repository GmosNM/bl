#scope std_experimental

Table :: fn (TKey: type, TValue: type) type #comptime {
    static_assert(TKey == string || is_number(TKey) || is_pointer(TKey) || TKey == string_view);
    TEntry :: Entry(TKey, TValue);
    return struct {
        entries: []TEntry;
        end: *u8;
        len: s64;
        allocator: *Allocator;
    };
}

/// Create iterator type from **Table** type.
TableIter :: fn (TTable: type) type #comptime {
    return *typeof_entry(TTable);
}

tbl_init :: fn (tbl: *?T, expected_size := DEFAULT_BUCKET_COUNT, allocator: *Allocator = null) {
    assert(tbl);
    tbl.allocator = allocator;
    tbl.len = 0;
    resize(tbl, expected_size);
}

/// Release all memory resources used by the table and set the `tbl` instance to the default state.
tbl_terminate :: fn (tbl: *?T) {
    assert(tbl);
    slice_terminate(&tbl.entries, tbl.allocator);
    zeromem(auto tbl, sizeof(T));
}

tbl_insert :: fn { impl_insert_empty; impl_insert; }

/// Checks whether the table `tbl` contains the `key`.
tbl_contains :: fn (tbl: *?T, key: tbl_typeof_key(T)) bool #inline {
    assert(tbl);
    if !is_initialized(tbl) { return false; }
    return lookup_entry(tbl, calculate_hash(key)) != tbl_end(tbl);
}

tbl_lookup :: fn (tbl: *?T, key: tbl_typeof_key(T)) TableIter(T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { return tbl_end(tbl); }
    return lookup_entry(tbl, calculate_hash(key));
}

/// Clears the table.
tbl_clear :: fn (tbl: *?T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { return; }
    loop it := tbl_begin(tbl); it != tbl_end(tbl); {
        node := it;
        tbl_iter_next(&it);
        free_memory(tbl.allocator, auto node);
    }
    buckets_size :: cast(usize)tbl.buckets.len * sizeof(@tbl.buckets.ptr);
    zeromem(auto tbl.buckets.ptr, buckets_size);
    assert(tbl.head);
    tbl.head.next = auto tbl.head;
    tbl.head.prev = auto tbl.head;
    tbl.len = 0;
}

/// Return an iterator pointing to the table beginning.
tbl_begin :: fn (tbl: *?T) TableIter(T) #inline {
    assert(tbl);
    if tbl.len == 0 { return tbl_end(); }
    return auto tbl.head.next;
}

/// Return an iterator pointing to the table ending.
tbl_end :: fn (tbl: *?T) TableIter(T) #inline {
    assert(tbl);
    return auto &tbl.end;
}

/// Resolve type of key from table type in compiletime.
tbl_typeof_key :: fn (TTable: type) type #comptime {
    return (@TTable.entries.ptr).key;
}

/// Resolve type of value from table type in compiletime.
tbl_typeof_value :: fn (TTable: type) type #comptime {
    return (@TTable.entries.ptr).value;
}

#private
DEFAULT_BUCKET_COUNT :: 64;
LOAD_FACTOR :: 0.7f #maybe_unused;
EMPTY_HASH : u32 : 0;
DELETED_HASH : u32 : 1;
FIRST_VALID_HASH : u32 : 2;

Entry :: fn (TKey: type, TValue: type) type #comptime {
    return struct {
        hash: u32;
        key: TKey;
        value: TValue;
    };
}

typeof_entry :: fn (T: type) type #comptime {
    return @T.entries.ptr;
}

is_initialized :: fn (tbl: *?T) bool #inline {
    return tbl.entries.ptr;
}

calculate_hash :: fn (key: ?T) u32 #inline {
    is_string :: T == string || T == string_view;
    hash: u32;
    #if is_string {
        hash = auto std.str_hash(key);
    } else {
        hash = auto key;
        // copy-paste from stack overflow, is it good or not???
        hash = ((hash >> 16) ^ hash) * 0x45d9f3b;
        hash = ((hash >> 16) ^ hash) * 0x45d9f3b;
        hash = (hash >> 16) ^ hash;
    }
    if hash < FIRST_VALID_HASH { hash += FIRST_VALID_HASH; }
    return hash;
}

hash_to_index :: fn (entries_len: s64, hash: u32) s64 #inline {
    return auto (hash % auto entries_len);
}

impl_insert :: fn (tbl: *?T, key: tbl_typeof_key(T), value: tbl_typeof_value(T)) TableIter(T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { resize(tbl); }
    entry := insert(tbl, calculate_hash(key), key);
    memcpy(auto &entry.value, auto &value, sizeof(value));
    return entry;
}

impl_insert_empty :: fn (tbl: *?T, key: tbl_typeof_key(T)) TableIter(T) #inline {
    assert(tbl);
    if !is_initialized(tbl) { resize(tbl); }
    return insert(tbl, calculate_hash(key), key);
}

insert :: fn (tbl: *?T, hash: u32, key: tbl_typeof_key(T)) TableIter(T) {
    assert(tbl);
    assert(is_initialized(tbl));
    load_factor :: cast(f32)(tbl.len + 1) / cast(f32)tbl.entries.len;
    if load_factor > LOAD_FACTOR {
        resize(tbl, tbl.entries.len * 2);
    }
    start_index :: hash_to_index(tbl.entries.len, hash);
    index := start_index;
    entry: *typeof_entry(T);
    loop {
        entry = &tbl.entries[index];
        if entry.hash == EMPTY_HASH || entry.hash == DELETED_HASH {
            break;
        }
        index += 1;
        if index >= tbl.entries.len { index = 0; }
        assert(index != start_index);
    }
    entry.hash = hash;
    entry.key = key;
    tbl.len += 1;
    return entry;
}

resize :: fn (tbl: *?T, new_size : s64 = DEFAULT_BUCKET_COUNT) {
    old_entries :: tbl.entries;
    assert(new_size > 0);
    slice_init(&tbl.entries, new_size, false, tbl.allocator);
    loop i := 0; i < tbl.entries.len; i += 1 {
        tbl.entries[i].hash = EMPTY_HASH;
    }
    tbl.len = 0;
    loop i := 0; i < old_entries.len; i += 1 {
        old_entry :: &old_entries[i];
        if old_entry.hash == EMPTY_HASH   { continue; }
        if old_entry.hash == DELETED_HASH { continue; }
        // @Incomplete: use insert empty
        entry := insert(tbl, old_entry.hash, old_entry.key);
        memcpy(auto &entry.value, auto &old_entry.value, sizeof(old_entry.value));
    }
    slice_terminate(&old_entries, tbl.allocator);
}

lookup_entry :: fn (tbl: *?T, hash: u32) *typeof_entry(T) {
    assert(is_initialized(tbl));
    start_index :: hash_to_index(tbl.entries.len, hash);
    index := start_index;
    loop {
        entry :: &tbl.entries[index];
        if entry.hash == hash { return entry; }
        if entry.hash == 0 { break; }
        index += 1;
        if index >= tbl.entries.len { index = 0; }
        assert(index != start_index);
    }
    return tbl_end(tbl);
}
