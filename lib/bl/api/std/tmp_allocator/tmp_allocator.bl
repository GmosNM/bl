// =================================================================================================
// bl
//
// File:   tmp_allocator.bl
// Author: Martin Dorazil
// Date:   20/07/21
//
// Copyright 2021 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

//! ===================
//! Temporary Allocator
//! ===================
//! 
//! Temporary allocator is memory allocator supposed to be used in case just temporary memory allocation 
//! is needed; i.e. to build up file path from individual path components. The allocated memory
//! is valid until :ref:`temporary_reset` or :ref:`temporary_release` is called.
//!
//! The allocator makes all allocations in bigger preallocated block; i.e. when allocation is requested 
//! for the first time, new block is allocated with predefined size ``DEFAULT_BLOCK_SIZE``, all following 
//! allocations use the preallocated block if there is enough space. If the block is full and new 
//! requested allocation does not fit, another block is allocated (with size slightly bigger then previous one).
//! When :ref:`temporary_reset` is called, allocator will release all smaller allocated blocks and keeps
//! only the biggest one for later use.
//!
//! Example
//! -------
//! .. literalinclude:: /examples/docs/015.bl
//!    :language: bl
//!
//! .. note:: Temporary allocator has it's internal context allocated per-thread, so the explicit release
//!           of the allocated memory at the thread worker exit is mandatory.
//!
//! .. seealso:: :ref:`tprint`.

/// Temporary allocator instance.
temporary_allocator :: {:Allocator: &temporary_allocator_handler };

/// Reduce allocated memory, but keeps biggest allocated chunk for later use.
///
/// .. warning::  All resources previously allocated by this allocator became invalid after reset.
///
/// .. hint:: Call this method i.e. in every event loop (update) iteration.
temporary_reset :: fn () #inline {
    if !_root { return; }
    do_release(_root.next);
    _root.size = 0;
    _root.next = null;
}

/// Release all memory allocated by temporary allocator, this method is supposed to be called
/// at exit of a program.
///
/// .. warning::  All resources previously allocated by this allocator became invalid after release.
///
/// .. hint:: Call this method before main returns.
temporary_release :: fn () #inline {
    temporary_allocator_handler(null, AllocOp.Release, 0);
    assert(_total_capacity == 0);
    assert(_total_allocated == 0);
}

/// Return total memory used by temporary allocatory in bytes.
/// .. note:: Reports memory usage only for current thread.
temporary_allocated_bytes :: fn () usize #inline {
    return auto _total_allocated;
}

#private
DEFAULT_BLOCK_SIZE : usize : 1024;
DEFAULT_ALIGNMENT : usize : 16; // @INCOMPLETE This is platform depend.

temporary_allocator_handler :: fn (_: *Allocator, operation: AllocOp, size: usize, _ : *u8 = null, _ := String.empty, _ := 0) *u8 {
    switch operation {
        AllocOp.Allocate {
            return allocate(size);
        }
        AllocOp.Free;
        AllocOp.Release {
            do_release(_root);
            _root = null;
        }
        default { panic(); }
    }
    return null;
}

Block :: struct {
    next: *Block;
    capacity: usize;
    size: usize;
    _: u64; // padding
}

_root: *Block  #thread_local;
_total_allocated: usize #thread_local;
_total_capacity: usize #thread_local;

allocate :: fn (size: usize) *u8 {
    if size == 0 { panic("Attempt to allocate zero bytes."); }
    size += DEFAULT_ALIGNMENT;    
    if !_root { // initialize
        _root = allocate_block(Math.max(DEFAULT_BLOCK_SIZE, size));
        _root.size = size;
        return data_ptr(_root);
    }
    
    block := _root;    
    loop block {
        if block.size + size <= block.capacity { // block capable to handle allocation
            ptr :: data_ptr(block, block.size);
            block.size += size;
            return ptr;        
        } 
        block = block.next;
    }
    
    assert(!block);
    block = allocate_block(auto cast(f64)_total_capacity * 1.5);
    block.next = _root;
    block.size = size;
    _root = block;
    return data_ptr(block);
}

allocate_block :: fn (capacity: usize) *Block {
    allocation_size :: capacity+sizeof(Block);
    block := cast(*Block) alloc(allocation_size);
    block.capacity = capacity;
    block.size = 0;
    block.next = null;
    _total_allocated += allocation_size;
    _total_capacity += capacity;
    return block;
}

data_ptr :: fn (block: *Block, offset: usize = 0) *u8 #inline {
    assert(block);
    raw_ptr :: ptr_shift_bytes(block, auto sizeof(Block) + offset);
    aligned_ptr :: align_ptr_up(raw_ptr, DEFAULT_ALIGNMENT);
    return aligned_ptr;
}

do_release :: fn (block: *Block) {
    loop block {
        _total_allocated -= block.capacity+sizeof(Block);
        _total_capacity -= block.capacity;
        next_block :: block.next;
        free(auto block);
        block = next_block;
    }
}
