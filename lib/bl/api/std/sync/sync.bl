//! # Thread synchronization
//! 
//! `#import "std/sync"`
//!
//! Multiplatform implementation of various thread synchronization tools.
//! 
//! !!! todo
//!     Improve documentation.

#scope std

/// Mutex type.
Mutex :: _sync_impl.Mutex;
Semaphore :: _sync_impl.Semaphore;

/// Initialize mutex. Call [mutex_terminate](#mutex_terminate) when mutex is no longer needed.
mutex_init :: fn (mutex: *Mutex) Error #inline {
    return _sync_impl.mutex_init(mutex);
}

/// Terminate mutex.
mutex_terminate :: fn (mutex: *Mutex) Error #inline {
    return _sync_impl.mutex_terminate(mutex);
}

/// Lock mutex and enter critical section.
mutex_lock :: fn (mutex: *Mutex) Error #inline {
    return _sync_impl.mutex_lock(mutex);
}

/// Try to lock the `mutex`. Returns `true` in case the mutex was locked or `false` if `mutex`
/// is already locked or en error occurred.
mutex_try_lock :: fn (mutex: *Mutex) (bool, Error) #inline {
    return _sync_impl.mutex_try_lock(mutex);
}

/// Unlock previously locked mutex and leave critical section.
mutex_unlock :: fn (mutex: *Mutex) Error #inline {
    return _sync_impl.mutex_unlock(mutex);
}

/// Initialize `semaphore` object with `value`.
semaphore_init :: fn (semaphore: *Semaphore, value: u32, name: string_view = "", loc := #call_location) Error #inline {
    return _sync_impl.semaphore_init(semaphore, value, name, loc);
}

/// Terminate `semaphore` object.
semaphore_terminate :: fn (semaphore: Semaphore) Error #inline {
    return _sync_impl.semaphore_terminate(semaphore);
}

semaphore_wait :: fn (semaphore: Semaphore) Error #inline {
    return _sync_impl.semaphore_wait(semaphore);
}

semaphore_trywait :: fn (semaphore: Semaphore) (bool, Error) #inline {
    return _sync_impl.semaphore_try_wait(semaphore);
}

semaphore_post :: fn (semaphore: Semaphore) Error #inline {
    return _sync_impl.semaphore_post(semaphore);
}
