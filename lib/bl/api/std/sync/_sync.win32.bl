#load "sync.bl"

#scope _sync_impl

Mutex :: win32.RTL_CRITICAL_SECTION;
Semaphore :: win32.HANDLE;

mutex_init :: fn (mutex: *Mutex) #inline {
    win32.InitializeCriticalSection(mutex);
}

mutex_terminate :: fn (mutex: *Mutex) #inline {
    win32.DeleteCriticalSection(mutex);
}

mutex_lock :: fn (mutex: *Mutex) #inline {
    win32.EnterCriticalSection(mutex);
}

mutex_try_lock :: fn (mutex: *Mutex) bool #inline {
    return win32.TryEnterCriticalSection(mutex) != 0;
}

mutex_unlock :: fn (mutex: *Mutex) #inline {
    win32.LeaveCriticalSection(mutex);
}

semaphore_init :: fn (semaphore: *Semaphore, value: u32) {
    (@semaphore) = win32.CreateSemaphoreA(null, auto value, auto value, null);
}

semaphore_terminate :: fn (semaphore: Semaphore) {
    win32.CloseHandle(semaphore);
}

semaphore_wait :: fn (semaphore: Semaphore) {
    using win32;
    WaitForSingleObject(semaphore, INFINITE);
}

semaphore_try_wait :: fn (semaphore: Semaphore) bool {
    using win32;
    result :: WaitForSingleObject(semaphore, 0);
    return result != WAIT_TIMEOUT;
}

semaphore_post :: fn (semaphore: Semaphore) {
    using win32;
    ReleaseSemaphore(semaphore, 1, null);
}
