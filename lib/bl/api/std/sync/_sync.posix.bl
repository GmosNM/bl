#import "os/posix/pthread"
#import "os/posix/semaphore"
#load "sync.bl"

#scope _sync_impl

Mutex :: pthread_mutex_t;
Semaphore :: sem_t;

mutex_init :: fn (mutex: *Mutex) Error #inline {
    state :: pthread_mutex_init(mutex, null);
    if state != 0 {
        estr :: cast(*u8) C.strerror(state);
        return error("Cannot init mutex: '%' (%).", estr, state);
    }
    return OK;
}

mutex_terminate :: fn (mutex: *Mutex) Error #inline {
    state :: pthread_mutex_destroy(mutex);
    if state != 0 {
        estr :: cast(*u8) C.strerror(state);
        return error("Cannot terminate mutex: '%' (%).", estr, state);
    }
    return OK;
}

mutex_lock :: fn (mutex: *Mutex) Error #inline {
    state :: pthread_mutex_lock(mutex);
    if state != 0 {
        estr :: cast(*u8) C.strerror(state);
        return error("Cannot lock mutex: '%' (%).", estr, state);
    }
    return OK;
}

mutex_try_lock :: fn (mutex: *Mutex) (bool, Error) #inline {
    state :: pthread_mutex_lock(mutex);
    if state == 0 {
        return true, OK;
    }
    if state == C.EBUSY {
        return false, OK;
    }
    estr :: cast(*u8) C.strerror(state);
    return false, error("Cannot lock mutex: '%' (%).", estr, state);
}

mutex_unlock :: fn (mutex: *Mutex) Error #inline {
    state :: pthread_mutex_unlock(mutex);
    if state != 0 {
        estr :: cast(*u8) C.strerror(state);
        return error("Cannot unlock mutex: '%' (%).", estr, state);
    }
    return OK;
}

semaphore_init :: fn (semaphore: *Semaphore, value: u32) Error {
    state :: sem_init(semaphore, 0, value);
    if state == -1 {
        return os_get_last_error2();
    }
    return OK;
}

semaphore_terminate :: fn (semaphore: *Semaphore) Error {
    state :: sem_destroy(semaphore);
    if state == -1 {
        return os_get_last_error2();
    }
    return OK;
}

semaphore_wait :: fn (semaphore: *Semaphore) Error {
    state :: sem_wait(semaphore);
    if state == -1 {
        return os_get_last_error2();
    }
    return OK;
}

semaphore_try_wait :: fn (semaphore: *Semaphore) (bool, Error) {
    state :: sem_trywait(semaphore);
    if state == -1 {
        ec :: C.errno();
        if ec == C.EAGAIN {
            return false, OK;
        }
        return false, os_get_last_error2();
    }
    return true, OK;
}

semaphore_post :: fn (semaphore: *Semaphore) Error {
    state :: sem_post(semaphore);
    if state == -1 {
        return os_get_last_error2();
    }
    return OK;
}
