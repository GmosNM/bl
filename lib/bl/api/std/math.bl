//************************************************************************************************
// bl
//
// File:   math.bl 
// Author: Martin Dorazil
// Date:   11/3/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

PI          :: 3.141592653589793;
TWO_PI      :: 6.283185307179587;
HALF_PI     :: 1.570796326794897;
F32_EPSILON :: 0.00001f;

S8_MIN  : s8 : -128;
S8_MAX  : s8 : 127;
S16_MIN : s16 : -32768;
S16_MAX : s16 : 32767;
S32_MIN : s32 : -2147483648;
S32_MAX : s32 : 2147483647;
S64_MIN : s64 : -9223372036854775808;
S64_MAX : s64 : 9223372036854775807;

U8_MIN  : u8 : 0;
U8_MAX  : u8 : 255;
U16_MIN : u16 : 0;
U16_MAX : u16 : 65535;
U32_MIN : u32 : 0;
U32_MAX : u32 : 4294967295;
U64_MIN : u64 : 0;
U64_MAX : u64 : 18446744073709551615;

/* Lib C functions */
sin       :: fn (n: f64) f64 #extern;
cos       :: fn (n: f64) f64 #extern;
log10     :: fn (n: f64) f64 #extern;
pow       :: fn (base: f64, exponent: f64) f64 #extern;
sqrt      :: fn (x: f64) f64 #extern;
floor     :: fn (x: f64) f64 #extern;
rand      :: fn () s32 #extern;
srand     :: fn (seed: u32) #extern;
sinf      :: fn (n: f32) f32 #extern;
asinf     :: fn (arg: f32) f32 #extern;
cosf      :: fn (n: f32) f32 #extern;
acosf     :: fn (n: f32) f32 #extern;
powf      :: fn (base: f32, exponent: f32) f32 #extern;
sqrtf     :: fn (x: f32) f32 #extern;
floorf    :: fn (x: f32) f32 #extern;
tanf      :: fn (x: f32) f32 #extern;
atan2f    :: fn (y: f32, x: f32) f32 #extern;
copysignf :: fn (x: f32, y: f32) f32 #extern;
/* Lib C functions */

//************************************************************************************************
// Types
//************************************************************************************************
v2 :: struct {
    x: f32;
    y: f32
};

v3 :: struct {
    x: f32;
    y: f32;
    z: f32;
};

v3_right   :: {:v3: 1.f, 0.f, 0.f};
v3_up      :: {:v3: 0.f, 1.f, 0.f};
v3_forward :: {:v3: 0.f, 0.f, 1.f};

v4 :: struct {
    x: f32;
    y: f32;
    z: f32;
    w: f32;
};

iv2 :: struct {
    x: s32;
    y: s32
};

iv3 :: struct {
    x: s32;
    y: s32;
    z: s32;
};

/**
 * Matrix layout
 * | m[0][0]  m[1][0]  m[2][0]  m[3][0] |
 * | m[0][1]  m[1][1]  m[2][1]  m[3][1] |
 * | m[0][2]  m[1][2]  m[2][2]  m[3][2] |
 * | m[0][3]  m[1][3]  m[2][3]  m[3][3] |
 */
mat4 :: [4][4]f32;

// quaternion
quat :: v4;

//************************************************************************************************
// Functions
//************************************************************************************************

f32_abs :: fn (v: f32) f32 #inline {
    if v < 0.f { return -v; }
    return v;
}

lerp :: fn (a: f32, b: f32, fraction: f32) f32 #inline {
    return a + fraction * (b - a);
};

u32_max :: fn (a: u32, b: u32) u32 #inline {
    if a > b { return a; } 
    return b;
};

u32_min :: fn (a: u32, b: u32) u32 #inline {
    if a < b { return a; } 
    return b;
};

f32_compare :: fn (a: f32, b: f32, epsilon: f32) bool #inline {
    return f32_abs(a - b) < epsilon;
};

degtorad :: fn (deg: f32) f32 #inline {
    return deg / 180.f * cast(f32) PI;
};

radtodeg :: fn (rad: f32) f32 #inline {
    return (180.f * rad) / cast(f32) PI;
};

v2_sub :: fn (a: v2, b: v2) v2 #inline {
    a.x -= b.x;
    a.y -= b.y;
    return a;
};

v2_compare :: fn (a: v2, b: v2, epsilon: f32) bool #inline {
    return f32_compare(a.x, b.x, epsilon) && f32_compare(a.y, b.y, epsilon);
}

v3_compare :: fn (a: v3, b: v3, epsilon: f32) bool {
    return f32_compare(a.x, b.x, epsilon)
        && f32_compare(a.y, b.y, epsilon)
        && f32_compare(a.z, b.z, epsilon);
}

v4_compare :: fn (a: v4, b: v4, epsilon: f32) bool {
    return f32_compare(a.x, b.x, epsilon)
        && f32_compare(a.y, b.y, epsilon)
        && f32_compare(a.z, b.z, epsilon)
        && f32_compare(a.w, b.w, epsilon);
}

v3_length :: fn (v: v3) f32 #inline {
    return sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
};

v3_negate :: fn (v: v3) v3 #inline {
    return {:v3: -v.x, -v.y, -v.z};
};

v3_cross :: fn (a: v3, b: v3) v3 #inline {
    out: v3;
    out.x = a.y * b.z - a.z * b.y;
    out.y = a.z * b.x - a.x * b.z;
    out.z = a.x * b.y - a.y * b.x;
    return out;
};

v3_dot :: fn (a: v3, b: v3) f32 #inline {
    return a.x * b.x + a.y * b.y + a.z * b.z;
};

v3_sub :: fn (a: v3, b: v3) v3 #inline {
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return a;
};

v3_normalize :: fn (a: v3) v3 #inline {
    out := {:v3: 0};
    l := v3_length(a);

    if f32_compare(l, 0.f, F32_EPSILON) { return out; }

    out.x = a.x / l;
    out.y = a.y / l;
    out.z = a.z / l;

    return out;
};

v3_mul_s :: fn (a: v3, s: f32) v3 #inline {
    a.x *= s;
    a.y *= s;
    a.z *= s;
    return a;
};

v3_mul :: fn (a: v3, b: v3) v3 #inline {
    a.x *= b.x;
    a.y *= b.y;
    a.z *= b.z;
    return a;
};

v3_add :: fn (a: v3, b: v3) v3 #inline 
{
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return a;
};

v4_mul :: fn (a: v4, b: v4) v4 #inline {
    a.x *= b.x;
    a.y *= b.y;
    a.z *= b.z;
    a.w *= b.w;
    return a;
};

v4_add :: fn (a: v4, b: v4) v4 #inline 
{
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return a;
};

v4_length :: fn (v: v4) f32 #inline {
    return sqrtf(v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w);
};

v4_normalize :: fn (v: v4) v4 #inline {
    out := {:v4: 0};
    l := v4_length(v);

    if f32_compare(l, 0.f, F32_EPSILON) { return out; }

    out.x = v.x / l;
    out.y = v.y / l;
    out.z = v.z / l;
    out.w = v.w / l;

    return out;
};

v4_negate :: fn (v: v4) v4 #inline {
    return {:v4: -v.x, -v.y, -v.z, -v.w};
};

v4_mul_s :: fn (v: v4, s: f32) v4 #inline {
    return {:v4: v.x * s, v.y * s, v.z * s, v.w * s};
}

v4_div_s :: fn (v: v4, s: f32) v4 #inline {
    if s == 0.f { return {:v4: 0 }; }
    return {:v4: v.x / s, v.y / s, v.z / s, v.w / s};
}

mat4_init :: fn (m00: f32, m10: f32, m20: f32, m30: f32,
                 m01: f32, m11: f32, m21: f32, m31: f32,
                 m02: f32, m12: f32, m22: f32, m32: f32,
                 m03: f32, m13: f32, m23: f32, m33: f32,
                 out_mat: *mat4
                ) #inline
{
    (^out_mat)[0][0] = m00;
    (^out_mat)[0][1] = m01;
    (^out_mat)[0][2] = m02;
    (^out_mat)[0][3] = m03;

    (^out_mat)[1][0] = m10;
    (^out_mat)[1][1] = m11;
    (^out_mat)[1][2] = m12;
    (^out_mat)[1][3] = m13;

    (^out_mat)[2][0] = m20;
    (^out_mat)[2][1] = m21;
    (^out_mat)[2][2] = m22;
    (^out_mat)[2][3] = m23;

    (^out_mat)[3][0] = m30;
    (^out_mat)[3][1] = m31;
    (^out_mat)[3][2] = m32;
    (^out_mat)[3][3] = m33;
};

mat4_identity :: fn (out_mat: *mat4) #inline {
    mat4_init(
        1.f, 0.f, 0.f, 0.f,
        0.f, 1.f, 0.f, 0.f,
        0.f, 0.f, 1.f, 0.f,
        0.f, 0.f, 0.f, 1.f,
        out_mat
    );
};

mat4_zero :: fn (out_mat: *mat4) #inline {
    memset(auto out_mat, 0, sizeof(mat4));
}

mat4_perspective :: fn (fov_rad: f32, aspect: f32, near: f32, far: f32, out_mat: *mat4) #inline {
    mat4_zero(out_mat);
    f1 :: 1.0f / tanf(fov_rad * 0.5f);
    f2 :: 1.0f / (near - far);

    (^out_mat)[0][0] = f1 / aspect;
    (^out_mat)[1][1] = f1;
    (^out_mat)[2][2] = (near + far) * f2;
    (^out_mat)[2][3] =-1.0f;
    (^out_mat)[3][2] = 2.0f * near * far * f2;
};

mat4_look_at :: fn (eye: v3, target: v3, up: v3, out_mat: *mat4) #inline {
    z := v3_sub(target, eye);
    z = v3_normalize(z);

    z = v3_mul_s(z, -1.f);
    x := v3_cross(up, z);
    x = v3_normalize(x);
    y := v3_cross(z, x);

    mat4_init(
        x.x, x.y, x.z, v3_dot(eye, x),
        y.x, y.y, y.z, -v3_dot(eye, y),
        z.x, z.y, z.z, -v3_dot(eye, z),
        0.f, 0.f, 0.f, 1.f,
        out_mat
    );
};

mat4_mul :: fn (a: *mat4, b: *mat4, out_mat: *mat4) {
    loop i := 0; i < 4; i += 1 {
        loop j := 0; j < 4; j += 1 {
            sum := 0.f;
            loop k := 0; k < 4; k += 1 {
                sum += (^a)[k][j] * (^b)[i][k];
            }
            (^out_mat)[i][j] = sum;
        }
    }
};

mat4_determinant :: fn (mat: *mat4) f32 #inline {
    return + (^mat)[0][0]*(((^mat)[1][1]*(((^mat)[2][2]*(^mat)[3][3])-((^mat)[3][2]*(^mat)[2][3]))) - ((^mat)[2][1]*(((^mat)[1][2]*(^mat)[3][3])-((^mat)[3][2]*(^mat)[1][3]))) + ((^mat)[3][1]*(((^mat)[1][2]*(^mat)[2][3])-((^mat)[2][2]*(^mat)[1][3]))))
		   - (^mat)[1][0]*(((^mat)[0][1]*(((^mat)[2][2]*(^mat)[3][3])-((^mat)[3][2]*(^mat)[2][3]))) - ((^mat)[2][1]*(((^mat)[0][2]*(^mat)[3][3])-((^mat)[3][2]*(^mat)[0][3]))) + ((^mat)[3][1]*(((^mat)[0][2]*(^mat)[2][3])-((^mat)[2][2]*(^mat)[0][3]))))
		   + (^mat)[2][0]*(((^mat)[0][1]*(((^mat)[1][2]*(^mat)[3][3])-((^mat)[3][2]*(^mat)[1][3]))) - ((^mat)[1][1]*(((^mat)[0][2]*(^mat)[3][3])-((^mat)[3][2]*(^mat)[0][3]))) + ((^mat)[3][1]*(((^mat)[0][2]*(^mat)[1][3])-((^mat)[1][2]*(^mat)[0][3]))))
		   - (^mat)[3][0]*(((^mat)[0][1]*(((^mat)[1][2]*(^mat)[2][3])-((^mat)[2][2]*(^mat)[1][3]))) - ((^mat)[1][1]*(((^mat)[0][2]*(^mat)[2][3])-((^mat)[2][2]*(^mat)[0][3]))) + ((^mat)[2][1]*(((^mat)[0][2]*(^mat)[1][3])-((^mat)[1][2]*(^mat)[0][3]))));    
}

mat4_inverse :: fn (src_mat: *mat4, out_mat: *mat4) #inline {
	det_inv :: 1.0f / mat4_determinant(src_mat);

	(^out_mat)[0][0] = (((^src_mat)[1][1]*(((^src_mat)[2][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[2][3]))) - ((^src_mat)[2][1]*(((^src_mat)[1][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[1][3]))) + ((^src_mat)[3][1]*(((^src_mat)[1][2]*(^src_mat)[2][3])-((^src_mat)[2][2]*(^src_mat)[1][3]))))*det_inv;
	(^out_mat)[0][1] = -1.0f*(((^src_mat)[0][1]*(((^src_mat)[2][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[2][3]))) - ((^src_mat)[2][1]*(((^src_mat)[0][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[0][3]))) + ((^src_mat)[3][1]*(((^src_mat)[0][2]*(^src_mat)[2][3])-((^src_mat)[2][2]*(^src_mat)[0][3]))))*det_inv;
	(^out_mat)[0][2] = (((^src_mat)[0][1]*(((^src_mat)[1][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[1][3]))) - ((^src_mat)[1][1]*(((^src_mat)[0][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[0][3]))) + ((^src_mat)[3][1]*(((^src_mat)[0][2]*(^src_mat)[1][3])-((^src_mat)[1][2]*(^src_mat)[0][3]))))*det_inv;
	(^out_mat)[0][3] = -1.0f*(((^src_mat)[0][1]*(((^src_mat)[1][2]*(^src_mat)[2][3])-((^src_mat)[2][2]*(^src_mat)[1][3]))) - ((^src_mat)[1][1]*(((^src_mat)[0][2]*(^src_mat)[2][3])-((^src_mat)[2][2]*(^src_mat)[0][3]))) + ((^src_mat)[2][1]*(((^src_mat)[0][2]*(^src_mat)[1][3])-((^src_mat)[1][2]*(^src_mat)[0][3]))))*det_inv;

	(^out_mat)[1][0] = -1.0f*(((^src_mat)[1][0]*(((^src_mat)[2][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[2][3]))) - ((^src_mat)[2][0]*(((^src_mat)[1][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[1][3]))) + ((^src_mat)[3][0]*(((^src_mat)[1][2]*(^src_mat)[2][3])-((^src_mat)[2][2]*(^src_mat)[1][3]))))*det_inv;
	(^out_mat)[1][1] = (((^src_mat)[0][0]*(((^src_mat)[2][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[2][3]))) - ((^src_mat)[2][0]*(((^src_mat)[0][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[0][3]))) + ((^src_mat)[3][0]*(((^src_mat)[0][2]*(^src_mat)[2][3])-((^src_mat)[2][2]*(^src_mat)[0][3]))))*det_inv;
	(^out_mat)[1][2] = -1.0f*(((^src_mat)[0][0]*(((^src_mat)[1][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[1][3]))) - ((^src_mat)[1][0]*(((^src_mat)[0][2]*(^src_mat)[3][3])-((^src_mat)[3][2]*(^src_mat)[0][3]))) + ((^src_mat)[3][0]*(((^src_mat)[0][2]*(^src_mat)[1][3])-((^src_mat)[1][2]*(^src_mat)[0][3]))))*det_inv;
	(^out_mat)[1][3] = (((^src_mat)[0][0]*(((^src_mat)[1][2]*(^src_mat)[2][3])-((^src_mat)[2][2]*(^src_mat)[1][3]))) - ((^src_mat)[1][0]*(((^src_mat)[0][2]*(^src_mat)[2][3])-((^src_mat)[2][2]*(^src_mat)[0][3]))) + ((^src_mat)[2][0]*(((^src_mat)[0][2]*(^src_mat)[1][3])-((^src_mat)[1][2]*(^src_mat)[0][3]))))*det_inv;

	(^out_mat)[2][0] = (((^src_mat)[1][0]*(((^src_mat)[2][1]*(^src_mat)[3][3])-((^src_mat)[3][1]*(^src_mat)[2][3]))) - ((^src_mat)[2][0]*(((^src_mat)[1][1]*(^src_mat)[3][3])-((^src_mat)[3][1]*(^src_mat)[1][3]))) + ((^src_mat)[3][0]*(((^src_mat)[1][1]*(^src_mat)[2][3])-((^src_mat)[2][1]*(^src_mat)[1][3]))))*det_inv;
	(^out_mat)[2][1] = -1.0f*(((^src_mat)[0][0]*(((^src_mat)[2][1]*(^src_mat)[3][3])-((^src_mat)[3][1]*(^src_mat)[2][3]))) - ((^src_mat)[2][0]*(((^src_mat)[0][1]*(^src_mat)[3][3])-((^src_mat)[3][1]*(^src_mat)[0][3]))) + ((^src_mat)[3][0]*(((^src_mat)[0][1]*(^src_mat)[2][3])-((^src_mat)[2][1]*(^src_mat)[0][3]))))*det_inv;
	(^out_mat)[2][2] = (((^src_mat)[0][0]*(((^src_mat)[1][1]*(^src_mat)[3][3])-((^src_mat)[3][1]*(^src_mat)[1][3]))) - ((^src_mat)[1][0]*(((^src_mat)[0][1]*(^src_mat)[3][3])-((^src_mat)[3][1]*(^src_mat)[0][3]))) + ((^src_mat)[3][0]*(((^src_mat)[0][1]*(^src_mat)[1][3])-((^src_mat)[1][1]*(^src_mat)[0][3]))))*det_inv;
	(^out_mat)[2][3] = -1.0f*(((^src_mat)[0][0]*(((^src_mat)[1][1]*(^src_mat)[2][3])-((^src_mat)[2][1]*(^src_mat)[1][3]))) - ((^src_mat)[1][0]*(((^src_mat)[0][1]*(^src_mat)[2][3])-((^src_mat)[2][1]*(^src_mat)[0][3]))) + ((^src_mat)[2][0]*(((^src_mat)[0][1]*(^src_mat)[1][3])-((^src_mat)[1][1]*(^src_mat)[0][3]))))*det_inv;

	(^out_mat)[3][0] = -1.0f*(((^src_mat)[1][0]*(((^src_mat)[2][1]*(^src_mat)[3][2])-((^src_mat)[3][1]*(^src_mat)[2][2]))) - ((^src_mat)[2][0]*(((^src_mat)[1][1]*(^src_mat)[3][2])-((^src_mat)[3][1]*(^src_mat)[1][2]))) + ((^src_mat)[3][0]*(((^src_mat)[1][1]*(^src_mat)[2][2])-((^src_mat)[2][1]*(^src_mat)[1][2]))))*det_inv;
	(^out_mat)[3][1] = (((^src_mat)[0][0]*(((^src_mat)[2][1]*(^src_mat)[3][2])-((^src_mat)[3][1]*(^src_mat)[2][2]))) - ((^src_mat)[2][0]*(((^src_mat)[0][1]*(^src_mat)[3][2])-((^src_mat)[3][1]*(^src_mat)[0][2]))) + ((^src_mat)[3][0]*(((^src_mat)[0][1]*(^src_mat)[2][2])-((^src_mat)[2][1]*(^src_mat)[0][2]))))*det_inv;
	(^out_mat)[3][2] = -1.0f*(((^src_mat)[0][0]*(((^src_mat)[1][1]*(^src_mat)[3][2])-((^src_mat)[3][1]*(^src_mat)[1][2]))) - ((^src_mat)[1][0]*(((^src_mat)[0][1]*(^src_mat)[3][2])-((^src_mat)[3][1]*(^src_mat)[0][2]))) + ((^src_mat)[3][0]*(((^src_mat)[0][1]*(^src_mat)[1][2])-((^src_mat)[1][1]*(^src_mat)[0][2]))))*det_inv;
	(^out_mat)[3][3] = (((^src_mat)[0][0]*(((^src_mat)[1][1]*(^src_mat)[2][2])-((^src_mat)[2][1]*(^src_mat)[1][2]))) - ((^src_mat)[1][0]*(((^src_mat)[0][1]*(^src_mat)[2][2])-((^src_mat)[2][1]*(^src_mat)[0][2]))) + ((^src_mat)[2][0]*(((^src_mat)[0][1]*(^src_mat)[1][2])-((^src_mat)[1][1]*(^src_mat)[0][2]))))*det_inv;
	
}

mat4_scale_s :: fn (s: f32, out_mat: *mat4) {
    (^out_mat)[0][0] *= s; (^out_mat)[0][1] *= s; (^out_mat)[0][2] *= s; (^out_mat)[0][3] *= s;
    (^out_mat)[1][0] *= s; (^out_mat)[1][1] *= s; (^out_mat)[1][2] *= s; (^out_mat)[1][3] *= s;
    (^out_mat)[2][0] *= s; (^out_mat)[2][1] *= s; (^out_mat)[2][2] *= s; (^out_mat)[2][3] *= s;
    (^out_mat)[3][0] *= s; (^out_mat)[3][1] *= s; (^out_mat)[3][2] *= s; (^out_mat)[3][3] *= s;
};

mat4_mul_v4 :: fn (mat: *mat4, v: v4) v4 {
    out: v4;
    out.x = (^mat)[0][0] * v.x + (^mat)[1][0] * v.y + (^mat)[2][0] * v.z + (^mat)[3][0] * v.w;
    out.y = (^mat)[0][1] * v.x + (^mat)[1][1] * v.y + (^mat)[2][1] * v.z + (^mat)[3][1] * v.w;
    out.z = (^mat)[0][2] * v.x + (^mat)[1][2] * v.y + (^mat)[2][2] * v.z + (^mat)[3][2] * v.w;
    out.w = (^mat)[0][3] * v.x + (^mat)[1][3] * v.y + (^mat)[2][3] * v.z + (^mat)[3][3] * v.w;
    return out;
};

// set out_mat to translation matrix
mat4_translation :: fn (translation: v3, out_mat: *mat4) #inline {
    mat4_init(
        1.f, 0.f, 0.f, translation.x,
        0.f, 1.f, 0.f, translation.y,
        0.f, 0.f, 1.f, translation.z,
        0.f, 0.f, 0.f, 1.f,
        out_mat
    );
};

mat4_get_scale :: fn (mat: *mat4) v3 {
    ret: v3;
    tmp_vec := {:v3: (^mat)[0][0], (^mat)[1][0], (^mat)[2][0]};
    ret.x = v3_length(tmp_vec);

    tmp_vec = {:v3: (^mat)[0][1], (^mat)[1][1], (^mat)[2][1]};
    ret.y = v3_length(tmp_vec);

    tmp_vec = {:v3: (^mat)[0][2], (^mat)[1][2], (^mat)[2][2]};
    ret.z = v3_length(tmp_vec);
    return ret;
};

mat4_get_translation :: fn (mat: *mat4) v3 #inline {
    return {:v3: (^mat)[3][0], (^mat)[3][1], (^mat)[3][2]};
};

mat4_get_quat :: fn (mat: *mat4) quat {
    r: f32;
    rinv: f32;
    out: quat;

    trace := (^mat)[0][0] + (^mat)[1][1] + (^mat)[2][2];
    if trace >= 0.0f {
        r       = sqrtf(1.0f + trace);
        rinv    = 0.5f / r;

        out.x = rinv * ((^mat)[1][2] - (^mat)[2][1]);
        out.y = rinv * ((^mat)[2][0] - (^mat)[0][2]);
        out.z = rinv * ((^mat)[0][1] - (^mat)[1][0]);
        out.w = r    * 0.5f;
    } else if ((^mat)[0][0] >= (^mat)[1][1] && (^mat)[0][0] >= (^mat)[2][2]) {
        r       = sqrtf(1.0f - (^mat)[1][1] - (^mat)[2][2] + (^mat)[0][0]);
        rinv    = 0.5f / r;

        out.x = r    * 0.5f;
        out.y = rinv * ((^mat)[0][1] + (^mat)[1][0]);
        out.z = rinv * ((^mat)[0][2] + (^mat)[2][0]);
        out.w = rinv * ((^mat)[1][2] - (^mat)[2][1]);
    } else if ((^mat)[1][1] >= (^mat)[2][2]) {
        r       = sqrtf(1.0f - (^mat)[0][0] - (^mat)[2][2] + (^mat)[1][1]);
        rinv    = 0.5f / r;

        out.x = rinv * ((^mat)[0][1] + (^mat)[1][0]);
        out.y = r    * 0.5f;
        out.z = rinv * ((^mat)[1][2] + (^mat)[2][1]);
        out.w = rinv * ((^mat)[2][0] - (^mat)[0][2]);
    } else {
        r       = sqrtf(1.0f - (^mat)[0][0] - (^mat)[1][1] + (^mat)[2][2]);
        rinv    = 0.5f / r;

        out.x = rinv * ((^mat)[0][2] + (^mat)[2][0]);
        out.y = rinv * ((^mat)[1][2] + (^mat)[2][1]);
        out.z = r    * 0.5f;
        out.w = rinv * ((^mat)[0][1] - (^mat)[1][0]);
    }

    return out;
};

quat_identity :: fn () quat #inline {
    return {:quat: 
        0.f,
        0.f,
        0.f,
        1.f,
    };
};

quat_normalize :: fn (q: quat) quat #inline {
    return v4_normalize(q);
};

quat_to_mat4 :: fn (q: quat, out_mat: *mat4) {
    norm :: v4_length(q); 
    s := 0.f;
    if norm > 0.f { s = 2.f / norm; }

    x :: q.x;
    y :: q.y;
    z :: q.z;
    w :: q.w;

    xx :: s * x * x;   xy :: s * x * y;   wx :: s * w * x;
    yy :: s * y * y;   yz :: s * y * z;   wy :: s * w * y;
    zz :: s * z * z;   xz :: s * x * z;   wz :: s * w * z;

    (^out_mat)[0][0] = 1.0f - yy - zz;
    (^out_mat)[1][1] = 1.0f - xx - zz;
    (^out_mat)[2][2] = 1.0f - xx - yy;

    (^out_mat)[0][1] = xy + wz;
    (^out_mat)[1][2] = yz + wx;
    (^out_mat)[2][0] = xz + wy;

    (^out_mat)[1][0] = xy - wz;
    (^out_mat)[2][1] = yz - wx;
    (^out_mat)[0][2] = xz - wy;

    (^out_mat)[0][3] = 0.0f;
    (^out_mat)[1][3] = 0.0f;
    (^out_mat)[2][3] = 0.0f;
    (^out_mat)[3][0] = 0.0f;
    (^out_mat)[3][1] = 0.0f;
    (^out_mat)[3][2] = 0.0f;
    (^out_mat)[3][3] = 1.0f;
}

quat_look :: fn (eye: v3, ori: quat, out_mat: *mat4) {
    mat4_identity(out_mat);
    quat_to_mat4(ori, out_mat);

    v := {:v4: eye.x, eye.y, eye.z, 1.f};
    v = mat4_mul_v4(out_mat, v);

    (^out_mat)[3][0] = -v.x;
    (^out_mat)[3][1] = -v.y;
    (^out_mat)[3][2] = -v.z;
}

quat_axis_angle :: fn (axis: v3, angle_rad: f32) quat {
    a :: angle_rad * 0.5f;
    c :: cosf(a);
    s :: sinf(a);

    axis = v3_normalize(axis);

    return {:quat:
        s * axis.x,
        s * axis.y,
        s * axis.z,
        c
    };
};

quat_imag :: fn (q: quat) v3 #inline {
    return {:v3: q.x, q.y, q.z };
}

quat_real :: fn (q: quat) f32 #inline {
    return q.w;
}

quat_mul :: fn (q1: quat, q2: quat) quat {
    return {:quat:
            q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
            q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
            q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
            q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
    };
}

quat_rotate_v3 :: fn (q: quat, v: v3) v3 {
    p :: quat_normalize(q);
    u :: quat_imag(p);
    s :: quat_real(p);

    v1 := v3_mul_s(u, 2.0f * v3_dot(u, v));
    v2 := v3_mul_s(v, s * s - v3_dot(u, u));
    v1 = v3_add(v1, v2);
    v2 = v3_cross(u, v);
    v2 = v3_mul_s(v2, 2.f * s);
    return v3_add(v1, v2);
}

quat_forward :: fn (q: quat) v3 {
    x2 :: 2.0f * q.x;
    y2 :: 2.0f * q.y;
    z2 :: 2.0f * q.z;
    x2w :: x2 * q.w;
    y2w :: y2 * q.w;
    x2x :: x2 * q.x;
    z2x :: z2 * q.x;
    y2y :: y2 * q.y;
    z2y :: z2 * q.y;
    return {:v3: z2x + y2w, z2y - x2w, 1.0f - (x2x + y2y)};
}
