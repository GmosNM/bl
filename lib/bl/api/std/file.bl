//************************************************************************************************
// bl
//
// File:   file.bl 
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "std/string.bl"

/*!
File
====

Declaration
-----------
::

    File :: *u8; 

Description
-----------
Opaque file handle. 
*/
File :: *u8; 

/*!
FileOpenMode
============

Declaration
-----------
.. code-block: c 

    FileOpenMode :: enum {
        Read;
        Write;
        Binary
    };

Description
-----------
Used as additional information during file opening.

Variants
--------
* `Read` Open file for reading.
* `Write` Open file for writing.
* `Binary` Open file as binary file.
*/
FileOpenMode :: enum {
    Read;
    Write;
    Binary
};

/*!
file_create
===========

Declaration
-----------
::

    file_create :: fn (filename: string) File 

Description
-----------
Create and open new file or open existing one. Call of file_close is required after opened file is
is no longer needed. This function can return `null` when file cannot be created or opened.

Arguments
---------
* `filename` File name on disk.

Result
------
File handle or null.
*/
file_create :: fn (filename: string) File {
    mode := "w+";
    return c_fopen(auto filename.ptr, auto mode.ptr); 
};

/*!
file_open
=========

Declaration
-----------
::

    file_open :: fn (filename: string, modes: ...FileOpenMode) File

Description
-----------
Open an existing file or create new one. Call of file_close is required after file is is 
no longer needed. This function can return `null` file handle when file is not found or 
cannot be open.

Arguments
---------
* `filename` File name on disk.
* `modes` File open modes can be passed here in any order. 

Result
------
File handle or null.

.. note:: Signature of this procedure will be changed in the future to indicate possible errors
          back to caller (most likely it will take out_file as an parameter and return non-zero 
          number on fail).
*/
file_open :: fn (filename: string, modes: ...FileOpenMode) File {
    mode: [4]u8;

    if modes.len == 0 {
        mode[0] = 'r';
        mode[1] = 'w';
    } else {
        loop i := 0; i < modes.len; i += 1 {
            if i >= mode.len - 1 { break; }
            m := modes[i];
            if m == FileOpenMode.Read { mode[i] = 'r'; }
            if m == FileOpenMode.Write { mode[i] = 'w'; }
            if m == FileOpenMode.Binary { mode[i] = 'b'; }
        }
    }

    return c_fopen(auto filename.ptr, auto mode.ptr); 
};

/*!
file_close
==========

Declaration
-----------
::

    file_close :: fn (file: File)

Description
-----------
Close openned file. 

Arguments
---------
* `file` File to be closed.
*/
file_close :: fn (file: File) {
    if file == null { return; }
    c_fclose(file);
};

/*!
file_read_all
=============

Declaration
-----------
::

    file_read_all :: fn (file: File) string

Description
-----------
Load whole content of the file into the string buffer. Call `string_delete` when 
string buffer is no longer needed. When file is empty, function will return an
empty string.

Arguments
---------
* `file` File to be read.

Result
------
String containing file content or empty string.
*/
file_read_all :: fn (file: File) string {
    c_fseek(file, 0, SEEK_END);
    size := cast(usize) c_ftell(file);
    if size == 0 {
        return string_new();
    }

    c_fseek(file, 0, SEEK_SET);
    tmp := string_new(size + 1* sizeof(u8));
    read := c_fread(tmp.ptr, sizeof(u8), size, file);
    tmp.len = auto read;
    tmp[tmp.len-1] = '\0';
    return tmp;
};

/*!
file_read_all_slice
===================

Declaration
-----------
::

    file_read_all_slice :: fn (file: File) []u8

Description
-----------
Read content of file into slice array of characters. New memory is allocated
for the slice on the heap, call `slice_terminate` when slice is no longer
needed.

Arguments
---------
* `file` File to be read.

Result
------
Slice of characters containing file content.
*/
file_read_all_slice :: fn (file: File) []u8 {
    result: []u8;
    c_fseek(file, 0, SEEK_END);
    size := cast(usize) c_ftell(file);
    if size == 0 {
        return result;
    }

    c_fseek(file, 0, SEEK_SET);
    slice_init(result, auto size);
    read := c_fread(result.ptr, sizeof(u8), size, file);
    result.len = auto read;
    return result;
};

/*!
file_get_size_bytes
===================

Declaration
-----------
::

    file_get_size_bytes :: fn (file: File) usize

Description
-----------
Determinates size of file content in bytes.

Arguments
---------
* `file` File handle.

Result
------
Size of file content in bytes.
*/
file_get_size_bytes :: fn (file: File) usize {
    c_fseek(file, 0, SEEK_END);
    size :: cast(usize) c_ftell(file);
    c_fseek(file, 0, SEEK_SET);
    return size;
}

/*!
file_real_all_binary
====================

Declaration
-----------
::

    file_read_all_binary :: fn (file: File, dest: *u8, size: usize) usize

Description
-----------
Read content of whole binary file into destination buffer and return count of written
bytes. Destination buffer must be valid memory block of sufficient size.

Arguments
---------
* `file` File to be read.
* `dest` Destination buffer.
* `size` Count of bytes which will be copied from file into the buffer.

Result
------
Bytes written into buffer.
*/
file_read_all_binary :: fn (file: File, dest: *u8, size: usize) usize {
    return c_fread(dest, sizeof(u8), size, file);
}

/*!
file_write_binary
=================

Declaration
-----------
::

    file_write_binary :: fn (file: File, data: *u8, size: usize) usize

Description
-----------
Write content of passed buffer into the binary file. File must be valid file handle
openned for writing. Function returns zero written bytes if writing is not possible.

Arguments
---------
* `file` File to be modified.
* `data` Source data buffer.
* `size` Count of bytes to be written.

Result
------
Bytes written into file.
*/
file_write_binary :: fn (file: File, data: *u8, size: usize) usize {
    return c_fwrite(data, sizeof(u8), size, file);
}

/*!
file_write_string
=================

Declaration
-----------
::

    file_write_string :: fn (file: File, data: string) usize

Description
-----------
Write content of passed string into the file. File must be valid file handle 
openned for writing. Function returns zero written bytes if writing is not 
possible.

Arguments
---------
* `file` File to be modified.
* `data` String content.

Result
------
Bytes written into file.
*/
file_write_string :: fn (file: File, data: string) usize {
    return c_fwrite(data.ptr, sizeof(u8), auto data.len, file);
}

/*!
file_remove_ext
===============

Declaration
-----------
::

    file_remove_ext :: fn (filename: *string)

Description
-----------
Removes file name extension. Expects `filename` in format "foo.ext",
does nothing when input `filename` does not contain any extensions or
is empty. Returned string value is just subset of input string, no
allocations and copying is done.

.. note:: This function is simply looking for the first occourence of `.` 
          character and does split at that position.

Arguments
---------
* `filename` File name to be modified.

Result
------
File name without extension.
*/
file_remove_ext :: fn (filename: string) string {
    tmp := {:[]u8: filename.len, filename.ptr};
    loop i := 0; i < tmp.len; i += 1 {
        if tmp[i] == '.' {
            filename.len = i;
            break;
        }
    }

    return filename;
}

/*!
file_get_ext
============

Declaration
-----------
::

    file_get_ext :: fn (filename: string) string

Description
-----------
Return file name extension (string token after last dot separator).

Arguments
---------
* `filename` File name to extract extension from.

Result
------
File extension string.
*/
file_get_ext :: fn (filename: string) string {
    tmp := {:[]u8: filename.len, filename.ptr};
    ext: string;

    e := -1;
    loop i := 0; i < tmp.len; i += 1 {
        if e == 0 { ext.ptr = &tmp[i]; }
        if e > -1  { e += 1; }
            
        if tmp[i] == '.' { e = 0; }
    }

    if e > 0 { ext.len = e; }
    return ext;
}

#private

SEEK_SET :: 0;
SEEK_CUR :: 1;
SEEK_END :: 2;

c_fopen  :: fn (filename: *c_char, mode: *c_char) c_void_ptr #extern "fopen";
c_fclose :: fn (handle: c_void_ptr) c_int #extern "fclose";
c_fseek  :: fn (handle: c_void_ptr, offest: c_int, origin: c_int) c_int #extern "fseek";
c_fread  :: fn (ptr: c_void_ptr, size: c_size_t, count: c_size_t, handle: c_void_ptr) c_size_t #extern "fread";
c_fwrite :: fn (ptr: c_void_ptr, size: c_size_t, count: c_size_t, handle: c_void_ptr) c_size_t #extern "fwrite";
c_ftell  :: fn (handle: c_void_ptr) c_int #extern "ftell";
