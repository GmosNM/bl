//************************************************************************************************
// bl
//
// File:   _builtin.bl
// Author: Martin Dorazil
// Date:   2/11/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "_c.bl"
#load "_memory.bl"

/*!
# OSKind
## Declaration
```c
OSKind :: enum {
    Windows;
    Linux;
    MacOS;
}
```

## Description
  Describe supported platforms.
*/
OSKind :: enum {
    Windows;
    Linux;
    MacOS;
}

/*!
# TypeKind
## Declaration
```c
TypeKind :: enum #compiler {
    Type   :: 1;
    Void   :: 2;
    Int    :: 3;
    Real   :: 4;
    Fn     :: 5;
    Ptr    :: 6;
    Bool   :: 7;
    Array  :: 8;
    Struct :: 9;
    Enum   :: 10;
    Null   :: 11;
    String :: 12;
}
```

## Description
  TypeKind describes kind of BL type returned in TypeInfo structure. This value can be used for 
safe casting.

## Variants
  * `Type` Base type of all types in type system.
  * `Void` Void type. (Implicitly used for functions without return value)
  * `Int` Any integer type: `s8`, `s16`, `s32`, `s64`, `u8`, `u16`, `u32`, `u64`, `usize`.
  * `Real` Any real type: `f32`, `f64`.
  * `Fn` Function type. 
  * `Ptr` Pointer type. 
  * `Bool` Boolean type. 
  * `Array` Array type. 
  * `Struct` Structure type. 
  * `Enum` Enumerator type. 
  * `Null` Null-value type. 
  * `String` String type. 
*/
TypeKind :: enum #compiler {
    Type   :: 1;
    Void   :: 2;
    Int    :: 3;
    Real   :: 4;
    Fn     :: 5;
    Ptr    :: 6;
    Bool   :: 7;
    Array  :: 8;
    Struct :: 9;
    Enum   :: 10;
    Null   :: 11;
    String :: 12;
};

/*!
# TypeInfo
## Declaration
```c
TypeInfo :: struct #compiler {
    kind: TypeKind;
    size_bytes: usize
}
```

## Description
  Base `TypeInfo` structure returned by `typeinfo` operator. This structure pointer can be casted to child type to get more
descriptive information about the type.

## Members
  * `kind` Type info kind.
  * `size_bytes` Size of type in bytes.
*/
TypeInfo :: struct #compiler {
    kind: TypeKind;
    size_bytes: usize
};

/*!
# TypeInfoInt
## Declaration
```c
TypeInfoInt :: struct #base TypeInfo #compiler {
    bit_count: s32;
    is_signed: bool;
}
```

## Description
  Detailed information about integer types: `s8`, `s16`, `s32`, `s64`, `u8`, `u16`, `u32`, `u64`, `usize`.

## Members
  * `bit_count` Size of type in bits.
  * `is_signed` True when type is signed integer type.
*/
TypeInfoInt :: struct #base TypeInfo #compiler {
    bit_count: s32; 
    is_signed: bool;
};

/*!
# TypeInfoReal
## Declaration
```c
TypeInfoReal :: struct #base TypeInfo  #compiler {
    bit_count: s32
}
```

## Description
  Detailed information about real types: `f32`, `f64`.

## Members
  * `bit_count` Size of type in bits.
*/
TypeInfoReal :: struct #base TypeInfo  #compiler {
    bit_count: s32 
};

/*!
# TypeInfoFn
## Declaration
```c
TypeInfoFn :: struct #base TypeInfo #compiler {
    name: string;
    args: []TypeInfoFnArg; 
    ret_type: *TypeInfo;
    is_vargs: bool;
}
```

## Description
  Detailed information about function types.

## Members
  * `name` Function name.
  * `args` Slice of argument type infos.
  * `ret_type` Return type info.
  * `is_vargs` True when function has variable argument list.
*/
TypeInfoFn :: struct #base TypeInfo #compiler {
    name: string;
    args: []TypeInfoFnArg; 
    ret_type: *TypeInfo;
    is_vargs: bool; 
};

/*!
# TypeInfoPtr
## Declaration
```c
TypeInfoPtr :: struct #base TypeInfo #compiler {
    pointee_type: *TypeInfo 
}
```

## Description
  Detailed information about pointer types.

## Members
  * `pointee_type` Underlaying pointed type info.
*/
TypeInfoPtr :: struct #base TypeInfo #compiler {
    pointee_type: *TypeInfo
};

/*!
# TypeInfoArray
## Declaration
```c
TypeInfoArray :: struct #base TypeInfo #compiler {
    name: string;
    elem_type: *TypeInfo; 
    len: s64 
}
```

## Description
  Detailed information about array types.

## Members
  * `name` Array name.
  * `elem_type` Array element type info.
  * `len` Array element count.
*/
TypeInfoArray :: struct #base TypeInfo #compiler {
    name: string;
    elem_type: *TypeInfo; 
    len: s64 
};

/*!
# TypeInfoStruct
## Declaration
```c
TypeInfoStruct :: struct #base TypeInfo #compiler {
    name: string;
    members: []TypeInfoStructMember; 
    is_slice: bool
}
```

## Description
  Detailed information about structure types.

## Members
  * `name` Structure type name.
  * `members` Slice of structure member infos.
  * `is_slice` True when structure is slice.
  * `is_union` True when structure is union type.
*/
TypeInfoStruct :: struct #base TypeInfo #compiler {
    name: string; 
    members: []TypeInfoStructMember; 
    is_slice: bool;
    is_union: bool;

    // CLEANUP: slice cannot be union, better way will be create separate type
    // kind for struct, slice and union, dynamic array could act like regular
    // array in type info.
};

/*!
# TypeInfoEnum
## Declaration
```c
TypeInfoEnum :: struct #base TypeInfo #compiler {
    name: string;
    base_type: *TypeInfo; 
    variants: []TypeInfoEnumVariant
}
```

## Description
  Detailed information about enumerator types.

## Members
  * `name` Enumerator type name.
  * `base_type` Base type info.
  * `variants` Slice of all enumerator variants.
*/
TypeInfoEnum :: struct #base TypeInfo #compiler {
    name: string;
    base_type: *TypeInfo; 
    variants: []TypeInfoEnumVariant
};

/*!
# TypeInfoVoid
## Declaration
```c
TypeInfoVoid :: struct #base TypeInfo #compiler {
}
```

## Description
  Placeholer for information about `void` type.
*/
TypeInfoVoid :: struct #base TypeInfo #compiler {
};

/*!
# TypeInfoNull
## Declaration
```c
TypeInfoNull :: struct #base TypeInfo #compiler {
}
```

## Description
  Placeholer for information about `null` type.
*/
TypeInfoNull :: struct #base TypeInfo #compiler {
};

/*!
# TypeInfoString
## Declaration
```c
TypeInfoString :: struct #base TypeInfo #compiler {
}
```

## Description
  Placeholer for information about `string` type.
*/
TypeInfoString :: struct #base TypeInfo #compiler {
};

/*!
# TypeInfoType
## Declaration
```c
TypeInfoType :: struct #base TypeInfo #compiler {
}
```

## Description
  Placeholer for information about `type` type.
*/
TypeInfoType :: struct #base TypeInfo  #compiler {
};

/*!
# TypeInfoBool
## Declaration
```c
TypeInfoBool :: struct #base TypeInfo #compiler {
}
```

## Description
  Placeholer for information about `bool` type.
*/
TypeInfoBool :: struct #base TypeInfo #compiler {
};

/*!
# TypeInfoStructMember
## Declaration
```c
TypeInfoStructMember :: struct #compiler {
    name: string;
    base_type: *TypeInfo;
    offset_bytes: s32;
    index: s32;
    tags: s32;
    is_base: bool;
}
```

## Description
  Detailed information about structure member.

## Members
  * `name` Member type name.
  * `base_type` Member type info.
  * `offset_bytes` Byte-offset of member inside structure ABI.
  * `index` Order in structure.
  * `tags` 
    User tags contains merge of all tag values assigned to member in structure declaration.
Basically tags behave like a flags value, merge is done by binary `or` of all defined tag values.
User tags can be defined by `#tags` hash directive written after member type in following way:

        Foo :: struct {
            i: s32 #tags TAG1;
            j: s32 #tags TAG1, TAG2;
        };
    
    Where tags must be `compile-time` constant of `s32` type.

        TAG1 :: 0x1;
        TAG2 :: 0x2;

  * `is_base` True when member is inherrited base of the parent structure type.
*/
TypeInfoStructMember :: struct #compiler {
    name: string;
    base_type: *TypeInfo;
    offset_bytes: s32;
    index: s32;
    tags: s32;
    is_base: bool;
};

/*!
# TypeInfoEnumVariant
## Declaration
```c
TypeInfoEnumVariant :: struct #compiler {
    name: string;
    value: s64
}
```

## Description
  Detailed information about enumerator variant.

## Members
  * `name` Member type name.
  * `value` Variant value.
*/
TypeInfoEnumVariant :: struct #compiler {
    name: string;
    value: s64
};

/*!
# TypeInfoFnArg
## Declaration
```c
TypeInfoFnArg :: struct #compiler {
    name: string;
    base_type: *TypeInfo
}
```

## Description
  Detailed information about function's argument.

## Members
  * `name` Member type name.
  * `base_type` Argument type info.
*/
TypeInfoFnArg :: struct #compiler {
    name: string;
    base_type: *TypeInfo
};

/*!
# Any
## Declaration
```c
Any :: struct #compiler {
    type_info: *TypeInfo;
    data: *u8
}
```

## Description
  Any type is special builtin type used for passing value of "any" type as function argument. 

## Members
  * `type_info` Type info associated to data type.
  * `value` Data pointer. (not owner!)
*/
Any :: struct #compiler {
    type_info: *TypeInfo;
    data: *u8
};

/*!
# command_line_arguments
## Declaration
```c
command_line_arguments := {:[]string: 0}
```

## Description
  Contains all arguments passed from command line. First argument is executable name.
*/
command_line_arguments := {:[]string: 0};
