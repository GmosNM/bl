//************************************************************************************************
// bl
//
// File:   string.bl
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "std/print.bl"

StringBlockSize :: 64 - sizeof(BlockHead);

/*
 * @title string_new <<STRING_NEW>>
 * @decl string_new fn () string
 * @desc
 * Create an empty heap allocated string. New string instance has preallocated chunk of memory
 * equal to =StringBlockSize= constant. Use [[STRING_DELETE][=string_delete=]] method to free
 * allocated memory.
 * @ver 0.4.2
 */
string_new :: fn () string {
    return string_new_reserved(0);
};

/*
 * @title string_new_reserved
 * @decl string_new_reserved :: fn (size: usize) string
 * @desc
 * Create an empty heap allocated string with reserved memory size. Use [[STRING_DELETE][=string_delete=]] 
 * method to free allocated memory.
 * @ver 0.4.2
 */
string_new_reserved :: fn (size: usize) string {
    tmp : string;
    tmp.ptr = alloc_block(size);
    tmp.len = 0;

    return tmp;
};

/*
 * @title string_copy 
 *
 * @decl string_copy :: fn (v: string) string 
 * @desc
 * Creates clone of passed string. Returned string is allocated in new memory chunk and must
 * be deleted. Use [[STRING_DELETE][=string_delete=]] method to free allocated memory.
 * @ver 0.4.2
 */
string_copy :: fn (v: string) string {
    tmp : string;
    tmp.ptr = alloc_block(v.len);
    tmp.len = v.len;

    mem_copy(tmp.ptr, v.ptr, v.len);

    return tmp;
};

/*
 * @title string_delete <<STRING_DELETE>>
 *
 * @decl string_delete :: fn (v: string) 
 * @desc
 * Free memory allocated by [[STRING_NEW][=string_new=]] function.
 * @ver 0.4.2
 */
string_delete :: fn (v: string) {
    free_block(v.ptr);
};

/*
 * @title string_clear 
 *
 * @decl string_clear :: fn (v: string) 
 * @desc
 * Clear the string. Memory allocated by string stay untouched. 
 * @ver 0.4.2
 */
string_clear :: fn (v: *string) {
    v.len = 0;
};

/*
 * @title string_append
 *
 * @decl string_append :: fn (v: *string, add: Any) 
 * @desc
 * Append =Any= value to the existing string. New allocation is done only in case when passed string
 * does not have enough space to keep the result. 
 * @ver 0.4.2
 */
string_append :: fn (v: *string, add: Any) {
    new_len : usize = 0;
    add_len : usize = 0;
    add_ptr : *u8   = null;

    if add.type_info.kind == TypeKind.String {
        str := ^ cast(*string) add.data;
        new_len = v.len + str.len;
        add_ptr = str.ptr;
        add_len = str.len;
    } else {
        // other values than string
        buf := {:[PrintMaxLength]u8: 0};
        tmp := {:[]u8: buf.len, buf.ptr };

        bprint(tmp, "%", add);
        add_len = strlen(buf.ptr);
        add_ptr = buf.ptr;
        new_len = v.len + add_len;
    }

    v.ptr = make_more_room_if_needed(v.ptr, new_len);
    mem_copy(cast(*u8) (cast(u64) v.ptr + v.len) , add_ptr, add_len);
    v.len = new_len;
};

/*
 * @title string_concatenate
 *
 * @decl string_concatenate :: fn (args: ...) string 
 * @desc
 * Concatenate passed values into one string. One or more allocation are done when more space is needed.
 * Use [[STRING_DELETE][=string_delete=]] method to free allocated memory.
 * @ver 0.4.2
 */
string_concatenate :: fn (args: ...) string {
    tmp := string_new();
    loop i := 0; i < args.len; i += 1 {
        string_append(&tmp, args[i]);
    }

    return tmp;
};

/*
 * @title string_compare
 *
 * @decl string_compare :: fn (first: string, second: string) bool
 * @desc
 * Compare two input strings and return =true= if they are same.
 * @ver 0.4.2
 */
string_compare :: fn (first: string, second: string) bool {
    if first.len != second.len { return false; } 

    loop i := 0; i < first.len; i += 1 {
        if first[i] != second[i] { return false; }
    }

    return true;
};

/*
 * @title TODO string_compare_n
 * @ver 0.4.2
 */
string_compare_n :: fn (first: string, second: string, n: s32) bool
{
    if first.len < n { return false; }
    if second.len < n { return false; }

    loop i := 0; i < n; i += 1 {
        if first[i] != second[i] { return false; }
    }

    return true;
};

#private

BlockHead :: struct {
    allocated_size: usize
};

make_more_room_if_needed :: fn (ptr: *u8, size: usize) *u8 {
    allocated := get_allocated_size(ptr);
    if size > allocated {
        new_ptr := alloc_block(size);
        mem_copy(new_ptr, ptr, allocated);
        mem_free(get_allocation_ptr(ptr));

        ptr = new_ptr;
    }

    return ptr;
};

alloc_block :: fn (size: usize) *u8 {
    d := size / StringBlockSize + 1;
    size = d * StringBlockSize;

    alloc_size := size + sizeof(BlockHead);
    tmp := cast(*BlockHead) mem_alloc(alloc_size);
    if tmp == null { abort(); }
    tmp.allocated_size = size; 

    return cast(*u8) (cast(usize) tmp + sizeof(BlockHead));
};

free_block :: fn (ptr: *u8) {
    mem_free(get_allocation_ptr(ptr));
};

get_allocation_ptr :: fn (ptr: *u8) *u8 {
    return cast(*u8) ((cast(usize) ptr) - sizeof(BlockHead));
};

get_allocated_size :: fn (ptr: *u8) usize {
    head := cast(*BlockHead) get_allocation_ptr(ptr);
    return head.allocated_size;
};