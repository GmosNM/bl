//************************************************************************************************
// bl
//
// File:   string.bl
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "std/print.bl"

string_empty :: {:string: 0};

/*!
# string_new
  Initialize new dynamic string. Created string is guaranteed to be zero terminated.

!!! WARNING
    Every new string must be deleted by `string_delete` call.

## Declaration
```c
fn () string
```
## Description
  Create new empty string object.
## Result
  New empty string.

## Example
```c
main :: fn () s32 {
    str :: string_new();
    defer string_delete(str);
    string_append(&str, "Hello");

    print("str = %\n", str);
    return 0;
}
```

---

## Declaration
```c
fn (size: usize) string
```
## Description
  Create new string with preallocated space. This type of string
initialization can reduce count of allocations made later by extending
string content. String with length up to `size` require only one memory
allocation.

!!! Hint
    This initialization should be preferred if string length can be predicted.

## Arguments
  * `size`
    Preallocation size in characters.
## Result
  New string.

## Example
```c
main :: fn () s32 {
    str :: string_new(256);
    defer string_delete(str);
    string_append(&str, "Hello");

    print("str = %\n", str);
    return 0;
}
```
---

## Declaration
```c
fn (v: string) string
```
## Description
  Create copy of `v` string.
## Arguments
  * `v`
    String to be copied.
## Result
  New duplicate string.

---

## Declaration
```c
fn (cstr: *u8) string
```
## Description
  Create copy of C zero terminated string.
## Arguments
  * `v`
    Pointer to C string.
## Result
  New duplicate string.
*/
string_new :: fn {
    new;
    new_reserved;
    new_copy;
    new_cstr;
}

/*!
# string_delete
## Declaration
```c
string_delete :: fn (v: string)
```
## Description
  Delete dynamic string.

## Arguments
  * `v`
    String to be deleted.
*/
string_delete :: fn (v: string) {
    if !v.ptr { return; }
    free_block(v.ptr);
};

/*!
# string_clear
## Declaration
```c
string_clear :: fn (v: *string)
```
## Description
  Clear dynamic string but keep allocated storage.

## Arguments
  * `v`
    String to be cleared.
*/
string_clear :: fn (v: *string) {
    v.len = 0;
    set_terminator(^v);
};

/*!
# string_append
## Declaration
```c
string_append :: fn (v: *string, add: Any)
```
## Description
  Append dynamic string with any value. Allocation is done in case there
is not enough space reminding in string.

## Arguments
  * `v`
    String to be cleared.
  * `add`
    Value to be appended.
*/
string_append :: fn (v: *string, add: Any) {
    new_len: s64;
    add_len: s64;
    add_ptr: *u8;

    if add.type_info.kind == TypeKind.String {
        str := ^ cast(*string) add.data;
        new_len = v.len + str.len;
        add_ptr = str.ptr;
        add_len = str.len;
    } else {
        // other values than string
        buf := {:[PRINT_MAX_LENGTH]u8: 0};
        tmp := {:[]u8: buf.len, buf.ptr };

        bprint(tmp, "%", add);
        add_len = auto c_strlen(auto buf.ptr);
        add_ptr = buf.ptr;
        new_len = v.len + add_len;
    }

    v.ptr = make_more_room_if_needed(v.ptr, auto new_len);
    memcpy(cast(*u8) (cast(u64) v.ptr + auto v.len) , add_ptr, auto add_len);
    v.len = new_len;

    set_terminator(^v);
};

/*!
# string_concatenate
## Declaration
```c
string_concatenate :: fn (v: *string, args: ...)
```
## Description
  Append string with multiple values passed as `args`.

## Arguments
  * `v`
    String to be appended.
  * `args`
    String content.
*/
string_concatenate :: fn (v: *string, args: ...) {
    loop i := 0; i < args.len; i += 1 {
        string_append(v, args[i]);
    }
};

/*!
# string_compare
## Declaration
```c
string_compare :: fn (first: string, second: string, n := -1) bool
```
## Description
  Compare two strings in specified range and return `true` 
if they are same otherwise return `false`.
 
## Arguments
  * `first`
    First string to be compared.
  * `second`
    Second string to be compared.
  * `n`
    Optional count of characters to be compared. This value is ignored
    when less than 0 (default is -1).

## Result
  Return `true` if `n` characters in `first` string are same as the same range in `second` string.
*/
string_compare :: fn (first: string, second: string, n := -1) bool
{
    // @CLEANUP: simplify this
    range := n;
    if range < 0 { 
        if first.len != second.len { return false; }
        range = auto max(first.len, second.len); 
    } else if first.len != second.len {
        if first.len < range { return false; }
        if second.len < range { return false; }
    }
    loop i := 0; i < range && i < first.len && i < second.len; i += 1 {
        if first[i] != second[i] { return false; }
    }
    return true;
};

/*!
# string_to_f32
## Declaration
```c
string_to_f32 :: fn (str: string, count := -1) f32
```
## Description
  Convert first `count` characters from string to `f32`.
 
## Arguments
  * `str`
    Float as string.
  * `count`
    Count of characters to be converted.

## Result
  Converted float value.
*/
string_to_f32 :: fn (str: string, count := -1) f32 {
    if count < 0 { count = auto str.len; }
    else if count > str.len { count = auto str.len; }
    n := 0;
    e := 1;
    is_negative := false;
    is_after_comma := false;

    loop count > 0 {
        c :: str[0];
        if c == '-' {
            is_negative = true;
        } else if c == '.' {
            if is_after_comma { break; }
            is_after_comma = true;
        } else if c >= '0' && c <= '9' {
            n = n * 10 + (auto c - '0');
            if is_after_comma {
                e *= 10;
            }
        } else {
            break;
        }

        consume_char(&str);
        count -= 1;
    }

    v := cast(f32) n / cast(f32) e; 
    if is_negative { v = -v; } 
    return v;
}

/*!
# string_to_s64
## Declaration
```c
string_to_s64 :: fn (str: string, count := -1) s64
```
## Description
  Convert first `count` characters from string to `s64`.
 
## Arguments
  * `str`
    Integer as string.
  * `count`
    Count of characters to be converted.

## Result
  Converted integer value.
*/
string_to_s64 :: fn (str: string, count := -1) s64 {
    if count < 0 { count = auto str.len; }
    else if count > str.len { count = auto str.len; }
    n: s64;
    is_negative := false;
    loop count > 0 {
        c :: str[0];
        if c == '-' {
            is_negative = true;
        } else if c >= '0' && c <= '9' {
            n = n * 10 + (auto c - '0');
        } else {
            break;
        }

        consume_char(&str);
        count -= 1;
    }
    if is_negative { n = -n; } 
    return n;
}

/*!
# string_split_by_last 
## Declaration
```c
string_split_by_last :: fn (str: string, delimiter: u8, lhs: *string, rhs: *string) bool
```
## Description
  Split input string `str` into two tokens based on the last occurrence of `delimiter`.
Delimiter is not included in resulting tokens. Result tokens only points into original
memory of the `str`, they are not supposed to be freed.
  When delimiter is not present in the input string function return `false`, `lhs` and
`rhs` buffers are not modified, otherwise function return `true` and sets `lhs` and `rhs`
to found values.
 
## Arguments
  * `str`
    String to be splitted.
  * `delimiter`
    Delimiter to be found.
  * `lhs`
    Optional output left hand side string.
  * `rhs`
    Optional output right hand side string.

## Result
  True when delimiter was found.

## Example
```c
main :: fn () s32 {
    lhs: string;
    rhs: string;
    if string_split_by_last("this/is/my/epic/path", '/', &lhs, &rhs) {
        print("lhs = %\n", lhs);
        print("rhs = %\n", rhs);
    }

    return 0;
}
```
*/
string_split_by_last :: fn (str: string, delimiter: u8, lhs: *string, rhs: *string, di: *s32 = null) bool {
    i := str.len - 1;
    loop ; i >= 0 && str[i] != delimiter; i -= 1 {}

    if i < 0 { // not found
        if lhs { ^lhs = str; }
        if di { (^di) = auto i; }
        return false;
    }

    if lhs {
        lhs.len = i;
        lhs.ptr = str.ptr;
    }

    if rhs {
        rhs.len = str.len - i - 1;
        rhs.ptr = ptr_shift_bytes(str.ptr, auto sizeof(u8) * auto i + 1);
    }

    if di { (^di) = auto i; }
    return true;
}

// @DOC
string_split_by_first :: fn (str: string, delimiter: u8, lhs: *string, rhs: *string, di: *s32 = null) bool {
    i := 0;
    loop ; i < str.len && str[i] != delimiter; i += 1 {}

    if i >= str.len { // not found
        if lhs { ^lhs = str; }
        if di { (^di) = auto i; }
        return false;
    }

    if lhs {
        lhs.len = i;
        lhs.ptr = str.ptr;
    }

    if rhs {
        rhs.len = str.len - i - 1;
        rhs.ptr = ptr_shift_bytes(str.ptr, auto sizeof(u8) * auto i + 1);
    }

    if di { (^di) = auto i; }
    return true;
}

// @DOC
string_split_by :: fn (str: string, delimiter: u8) []string {
    count :: string_count(str, delimiter) + 1;
    ret: []string;
    slice_init(ret, count);
    ri: s32;
    lhs: string;
    rhs: string;
    loop string_split_by_first(str, delimiter, &lhs, &rhs) {
        ret[ri] = lhs;
        ri += 1;
        str = rhs;
    }
    if ri == 0 { ret[ri] = lhs; }
    else       { ret[ri] = rhs; }
    return ret;
}

// @DOC
string_count :: fn (str: string, c: u8) s32 {
    count := 0;
    loop i := 0; i < str.len; i += 1 {
        if str[i] == c { count += 1; }
    }
    return count;
}

// @DOC
string_to_lower :: fn (str: string) {
    c_tolower :: fn (c: s32) s32 #extern "tolower";
    loop i := 0; i < str.len; i += 1 {
        str[i] = auto c_tolower(auto str[i]); 
    }
}

// @DOC
string_to_upper :: fn (str: string) {
    c_toupper :: fn (c: s32) s32 #extern "toupper";
    loop i := 0; i < str.len; i += 1 {
        str[i] = auto c_toupper(auto str[i]); 
    }
}

/*!
# string_replace_all  
## Declaration
```c
string_replace_all :: fn (str: string, c: u8, with := '\0') s32
```
## Description
  Replace all found occurrences of character `c` in the input string with `with`
character and return count of replacements made. This function cannot be used with
constant string literals as input.
 
## Arguments
  * `str`
    Input string.
  * `c`
    Character to be replaced.
  * `with`
    Replacement. If replacement is 0 character, all `c` occourences will be erased
    from the string.

## Result
  Count of replacements made.
*/
string_replace_all :: fn (str: *string, c: u8, with := '\0') s32 {
    replaced := 0;
    loop i := 0; i < (^str).len; i += 1 {
        if (^str)[i] == c { 
            replaced += 1;
            (^str)[i] = with; 
        }
    }
    if with == '\0' {
        shrink_by(str);
    }
    return replaced;
}

string_is_null  :: fn (s: string) bool #inline { return s.ptr == null; }
string_is_empty :: fn (s: string) bool #inline { return s.len == 0; }
string_is_null_or_empty :: fn (s: string) bool #inline { return s.ptr == null || s.len == 0; }

// Some legacy C string libc apis.
c_strlen :: fn (str: *c_char) c_size_t #extern "strlen";
c_strcmp :: fn (first: *c_char, second: *c_char) c_int #extern "strcmp";

#private
STRING_BLOCK_SIZE :: 64 - sizeof(BlockHead);

BlockHead :: struct {
    allocated_size: usize;
    allocator: _AllocFn;
};

new :: fn () string {
    tmp : string #noinit;
    tmp.ptr = alloc_block(0, null);
    tmp.len = 0;

    set_terminator(tmp);
    return tmp;
};

new_reserved :: fn (size: usize) string {
    tmp : string #noinit;
    tmp.ptr = alloc_block(size, null);
    tmp.len = 0;

    set_terminator(tmp);
    return tmp;
};

new_copy :: fn (v: string) string {
    tmp : string #noinit;
    tmp.ptr = alloc_block(auto v.len, null);
    tmp.len = v.len;

    memcpy(tmp.ptr, v.ptr, auto v.len);

    set_terminator(tmp);
    return tmp;
};

new_cstr :: fn (cstr: *u8) string {
    len :: c_strlen(auto cstr);
    tmp: string #noinit;
    tmp.ptr = alloc_block(len, null);
    tmp.len = auto len;

    memcpy(tmp.ptr, cstr, len * sizeof(u8));
    set_terminator(tmp);

    return tmp;
}

make_more_room_if_needed :: fn (ptr: *u8, size: usize) *u8 {
    head :: get_allocated_size(ptr);
    allocated :: head.allocated_size;
    allocator :: head.allocator;
    if size > allocated {
        new_ptr := alloc_block(size, allocator);
        memcpy(new_ptr, ptr, allocated);
        free(get_allocation_ptr(ptr));

        ptr = new_ptr;
    }

    return ptr;
};

alloc_block :: fn (size: usize, allocator: _AllocFn) *u8 {
    if !allocator { allocator = _context.alloc_fn; }
    d := size / STRING_BLOCK_SIZE + 1;
    size = d * STRING_BLOCK_SIZE;

    alloc_size := size + sizeof(BlockHead) + sizeof(u8);
    tmp := cast(*BlockHead) allocator(AllocOp.Allocate, alloc_size, null, #file, #line);
    if tmp == null { panic(); }
    tmp.allocated_size = size; 
    tmp.allocator = allocator;

    return cast(*u8) (cast(usize) tmp + sizeof(BlockHead));
};

free_block :: fn (ptr: *u8) {
    head :: get_allocated_size(ptr);
    allocator :: head.allocator;
    allocator(AllocOp.Free, 0, get_allocation_ptr(ptr), #file, #line);
};

get_allocation_ptr :: fn (ptr: *u8) *u8 {
    return cast(*u8) ((cast(usize) ptr) - sizeof(BlockHead));
};

get_allocated_size :: fn (ptr: *u8) *BlockHead #inline {
    return cast(*BlockHead) get_allocation_ptr(ptr);
};

set_terminator :: fn (v: string) {
    v.len += 1;
    v[v.len - 1] = 0;
    v.len -= 1;
};

consume_char :: fn (s: *string) u8 #inline {
    c :: (^s)[0];
    if s.len > 1 { s.ptr = &(^s)[1]; }
    s.len -= 1;

    return c;
}

shrink_by :: fn (str: *string, c := '\0') {
    tmp := ^str;
    n := 0;
    is := -1;
    loop i := 0; i < tmp.len; i += 1 {
        if tmp[i] == c {
            if is < 0 { is = i; }
            n += 1;
        } else if is > -1 {
            buf :: tmp[is];
            tmp[is] = tmp[i];
            tmp[i] = buf;
            is = -1;
            i = is + 1;
            n = 0;
        }
    }
    tmp.len -= n;
    ^str = tmp;
}