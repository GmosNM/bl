//************************************************************************************************
// bl
//
// File:   core.bl
// Author: Martin Dorazil
// Date:   2/11/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "debug.bl"
#load "print.bl"

/*!
# _AllocFn
## Declaration
```c
_AllocFn :: * fn (size: usize) *u8
```

## Description
  Type of memory allocator function.

## Arguments
  * `size`
    Size of the memory block in bytes. 
*/
_AllocFn :: * fn (size: usize) *u8;

/*!
# _FreeFn
## Declaration
```c
_FreeFn :: * fn (p: *u8)
```

## Description
  Type of memory free function.

## Arguments
  * `ptr`
    Pointer to allocated memory block. 

## Result
  New allocated memory block.
*/
_FreeFn :: * fn (ptr: *u8);

/*!
# _PrintLogFn
## Declaration
```c
_PrintLogFn :: * fn (kind: PrintLogKind, format: string, args: []Any, file: string, line: s32)
```

## Description
  Type of print log function.

## Arguments
  * `kind`
    Kind of report message. 
  * `format`
    Format string. 
  * `args`
    Slice of arguments. 
  * `file`
    Call side filename. 
  * `line`
    Call side line in source file. 
*/
_PrintLogFn :: * fn (kind: PrintLogKind, format: string, args: []Any, file: string, line: s32);

_AbortFn :: * fn ();

/*!
# _Context
## Declaration
```c
_Context :: struct {
    alloc_fn: _AllocFn;
    free_fn: _FreeFn;
    print_log_fn: _PrintLogFn;
}
```

## Description
  Default implicit context type. Implicit context is compiler internal global variable 
containing basic context for whole assembly. This variable is mutable and can 
be modified by user code. 

## Members
  * `alloc_fn`
    Pointer to memory allocator function. 
  * `free_fn`
    Pointer to memory free function. 
  * `print_log_fn`
    Pointer to print log function. 
*/
_Context :: struct {
    /* Default memory allocation function. */
    alloc_fn: _AllocFn;

    /* Defualt memory free function. */
    free_fn: _FreeFn;

    /* Defualt debug log function. */
    print_log_fn: _PrintLogFn;

    abort_fn: _AbortFn;
};

/*!
# _context 
## Declaration
```c
_context := {:_Context: &_mem_alloc_default, &_mem_free_default, &_print_log_default}
```

## Description
  Default implicit context. Implicit context is compiler internal global variable 
containing basic context for whole assembly. This variable is mutable and can 
be modified by user code. For example we can replace default memory allocator
with custom one, this will affect all allocations made later.
*/
_context := {:_Context: 
                &_mem_alloc_default, 
                &_mem_free_default, 
                &_print_log_default, 
                &_os_abort_default,
            };

/*!
# panic
## Declaration
```c
panic :: fn (args: ...)
```

## Description
  Abort execution and eventually print panic message if there is one specified. First
passed argument in 'args' will act like format string and can be eventually followed
by any additional values required.

## Arguments
  * `args`
    Variable argument count of Any type. 

## Example
```c
panic(); // abort without any messages
panic("oops!"); // abort with message prited out.
panic("Failed with error: %", errn); // first argument passed acts like formating string
```
*/
panic :: fn (args: ...) {
    if args.len == 0 {
        unreachable;
    }

    tmp := {:[]Any: args.len, args.ptr };
    format := "no message";

    arg := args[0];
    if arg.type_info.kind == TypeKind.String {
        format = ^cast(*string) arg.data;
        tmp = {:[]Any:
                args.len - 1,
                auto ptr_shift_bytes(auto args.ptr, auto sizeof(arg))};
    }

    _context.print_log_fn(PrintLogKind.Panic, format, tmp, "", 0);

    unreachable;
};
