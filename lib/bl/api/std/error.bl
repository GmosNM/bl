//************************************************************************************************
// bl
//
// File:   error.bl 
// Author: Martin Dorazil
// Date:   19/11/20
//
// Copyright 2020 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

/*!
Error
=====

Declaration
-----------
.. code-block:: c

    _Error :: struct {
        msg: string;
        code: s32;
    }

    Error :: *_Error;

Description
-----------
Error state representation. 

Example
-------
.. literalinclude:: /examples/docs/001.bl
   :language: c 

Related functions
-----------------
* :ref:`is_ok`
* :ref:`is_error`
* :ref:`ok`
* :ref:`error`
*/

OK :: 0;

_Error :: struct {
    msg: string;
    code: s32;
}

Error :: *_Error;

/*!
is_ok
=====

Declaration
-----------
::

    is_ok :: fn (err: Error) bool #inline

Description
-----------
Check whether `err` is no-error valid state.
 
Arguments
---------
* `err` Error.

Result
------
Return `true` when err is OK and not `null`. 
*/
is_ok :: fn (err: Error) bool #inline {
    if !err { return false; }
    return err.code == 0;
}

/*!
is_error
========

Declaration
-----------
::

    is_error :: fn (err: Error, code: s32) bool #inline

Description
-----------
Check whether `err` is representing error `code`.
 
Arguments
---------
* `err` Error.
* `code` Error code.

Result
------
Return `true` when `err` code is equal to `code` and `err` is not `null`. 
*/
is_error :: fn (err: Error, code: s32) bool #inline {
    if !err { return false; }
    return err.code == code;
}

/*!
ok
==

Declaration
-----------
::

    ok :: fn () Error #inline

Description
-----------
Creates no-error :ref:`Error`.
 
Result
------
Valid no-error state. 
*/
ok :: fn () Error #inline {
    return error3(0, "");
}

/*!
error
=====
Overloaded function setting up error state. Error state is global variable holding :ref:`Error` 
instance, `error` function sets desired values and return pointer to this global. That means
the `Error` must be handled immediately after it's returned from failing function since every
`Error` state points to the same memory.

Error creating does not require any HEAP memory alocations.

Declaration
-----------
::

    fn (code: s32) Error #inline

Description
-----------
Sets error code.

Arguments
---------
* `code` Error code.

Result
------
Error.

----

Declaration
-----------
::

    fn (format: string, args: ...) Error #inline

Description
-----------
Sets error state with `ERR_UNKNOWN` code and formatted message.

Arguments
---------
* `format` Message formatting string.
* `args` Values inserted into formatted message.

Result
------
Error.

----

Declaration
-----------
:: 

    fn (code: s32, format: string, args: ...) Error

Description
-----------
Sets error state with `code` and formatted message.

Arguments
---------
* `code` Error code.
* `format` Message formatting string.
* `args` Values inserted into formatted message.

Result
------
Error.
*/
error :: fn {  error1; error2; error3; }

#private
_last_error_msg_buffer: [1024]u8;
_last_error: _Error;

error1 :: fn (code: s32) Error #inline {
    return error3(code, string_empty);
}

error2 :: fn (format: string, args: ...) Error #inline {
    return error3(ERR_UNKNOWN, format, args);
}

error3 :: fn (code: s32, format: string, args: ...) Error {
    e := &_last_error;
    msg_size :: bprint(_last_error_msg_buffer, format, args);
    e.code = code;
    e.msg = {:string: msg_size, _last_error_msg_buffer.ptr};
    return e;
}
