//! # Input/Ouput
//! 
//! `#import "std/io"`
//! 

#scope std

IoMode :: enum #flags { READ; WRITE; }

Stream :: struct {
    vtable: *StreamVTable;
}

StreamVTable :: struct {
    read: *fn(stream: *Stream, dest: *u8, bytes_to_read: s64) (bytes_read: s64, err: Error);
    write: *fn(stream: *Stream, src: *u8, src_size: s64) (bytes: s64, err: Error);
}

// =================================================================================================
// Stream API
// =================================================================================================

write :: fn {
    fn (stream: *Stream, src: *u8, bytes_to_write: s64) (s64, Error) #inline {
        assert(stream);
        assert(stream.vtable);
        if bytes_to_write < 1 { return 0, OK; }
        return stream.vtable.write(stream, src, bytes_to_write);
    };
    fn (stream: *Stream, data: []u8) (s64, Error) #inline {
        assert(stream);
        assert(stream.vtable);
        return stream.vtable.write(stream, data.ptr, data.len);
    };
};

read :: fn {
    fn (stream: *Stream, dest: *u8, bytes_to_read: s64) (s64, Error) #inline {
        assert(stream);
        assert(stream.vtable);
        if bytes_to_read < 1 { return 0, OK; }
        return stream.vtable.read(stream, dest, bytes_to_read);
    };
    fn (stream: *Stream, dest: *[..]u8, bytes_to_read: s64 = std.S64_MAX) (s64, Error) #inline {
        assert(stream);
        assert(stream.vtable);
        tmp: [512]u8 #noinit;
        read_bytes: s64;
        loop bytes_to_read > 0 {
            read, err :: stream.vtable.read(stream, tmp.ptr, min(tmp.len, bytes_to_read));
            if err { return read_bytes, err; }
            if read == 0 { break; }
            read_bytes += read;
            bytes_to_read -= read;
            array_push_all(dest, []u8.{ ptr = tmp.ptr, len = read});
        }
        return read_bytes, OK;
    };
    fn (stream: *Stream, dest: *string, bytes_to_read: s64 = std.S64_MAX) (s64, Error) #inline {
        assert(stream);
        assert(stream.vtable);
        tmp: [512]u8 #noinit;
        read_bytes: s64;
        loop bytes_to_read > 0 {
            read, err :: stream.vtable.read(stream, tmp.ptr, min(tmp.len, bytes_to_read));
            if err { return read_bytes, err; }
            if read == 0 { break; }
            read_bytes += read;
            bytes_to_read -= read;
            str :: string_view.{ ptr = tmp.ptr, len = read };
            str_append(dest, str);
        }
        return read_bytes, OK;
    };
}
