//! # Input/Ouput
//! 
//! `#import "std/io"`
//!
//! Input and output is handled by generic stream interface containing callbacks for read, write and
//! seek operations. The stream itself can contain any data needed (i.e. memory buffer, handle to file,
//! etc.), generic functionality is handled via virtual table containing pointers to the implementation
//! of all needed (supported) stream API functions.
//!
//! ### Example
//!
//! ```c
//! {% include "../examples/arrays.bl" %}
//! ```

#scope std

Stream :: struct {
    vtable: *StreamVTable;
}

StreamVTable :: struct {
    read:  *fn(stream: *Stream, dest: *u8, bytes_to_write: s64) (bytes_read: s64, err: Error);
    write: *fn(stream: *Stream, src: *u8, bytes_to_read: s64) (bytes: s64, err: Error);
    seek:  *fn(stream: *Stream, locator: StreamLocator, offset: s64) (position: s64, err: Error);
}

/// Stream seek offset locator.
StreamLocator :: enum {
    CURRENT;
    BEGIN;
    END;
}

// =================================================================================================
// Writing
// =================================================================================================

/// Write `bytes_to_write` count of bytes from the `str` into the stream. Returns
/// count of actually written bytes or an error.
write :: fn (stream: *Stream, src: *u8, bytes_to_write: s64) (s64, Error) #inline {
    assert(stream);
    assert(stream.vtable);
    if !stream.vtable.write { panic("Stream does not support writing."); }
    if bytes_to_write < 1 { return 0, OK; }
    return stream.vtable.write(stream, src, bytes_to_write);
}

/// Write the data slice into the stream, the `bytes_to_write` can be specified to limit count
/// of written bytes. Returns count of actually written bytes or an error.
write_data :: fn (stream: *Stream, data: []u8, bytes_to_write := std.S64_MAX) (s64, Error) #inline {
    return write(stream, data.ptr, min(data.len, bytes_to_write));
}

/// Write the data string into the stream, the `bytes_to_write` can be specified to limit count
/// of written bytes. Returns count of actually written bytes or an error.
write_string :: fn (stream: *Stream, str: string_view, bytes_to_write := std.S64_MAX) (s64, Error) #inline {
    return write(stream, str.ptr, min(str.len, bytes_to_write));
}

// =================================================================================================
// Reading
// =================================================================================================

/// Read `bytes_to_read` count of bytes from the stream into `dest` memory. Returns count of actually
/// read bytes or an error.
read :: fn (stream: *Stream, dest: *u8, bytes_to_read: s64) (s64, Error) #inline {
    assert(stream);
    assert(stream.vtable);
    if !stream.vtable.read { panic("Stream does not support reading."); }
    if bytes_to_read < 1 { return 0, OK; }
    return stream.vtable.read(stream, dest, bytes_to_read);
}

/// Read `bytes_to_read` count of bytes from the stream into `dest` dynamic array. Returns count of actually
/// read bytes or an error.
read_data :: fn (stream: *Stream, dest: *[..]u8, bytes_to_read: s64 = std.S64_MAX) (s64, Error) {
    tmp: [512]u8 #noinit;
    read_bytes: s64;
    loop bytes_to_read > 0 {
        bytes, err :: read(stream, tmp.ptr, min(tmp.len, bytes_to_read));
        if err { return read_bytes, err; }
        if bytes == 0 { break; }
        read_bytes += bytes;
        bytes_to_read -= bytes;
        array_push_all(dest, []u8.{ ptr = tmp.ptr, len = bytes });
    }
    return read_bytes, OK;
}

/// Read `bytes_to_read` count of bytes from the stream into `dest` stream. Returns count of actually
/// read bytes or an error.
read_string :: fn (stream: *Stream, dest: *string, bytes_to_read: s64 = std.S64_MAX) (s64, Error) {
    tmp: [512]u8 #noinit;
    read_bytes: s64;
    loop bytes_to_read > 0 {
        bytes, err :: read(stream, tmp.ptr, min(tmp.len, bytes_to_read));
        if err { return read_bytes, err; }
        if bytes == 0 { break; }
        read_bytes += bytes;
        bytes_to_read -= bytes;
        str :: string_view.{ ptr = tmp.ptr, len = bytes };
        str_append(dest, str);
    }
    return read_bytes, OK;
}

// =================================================================================================
// Other
// =================================================================================================

/// Set the stream pointer position to the `offset` value relative to the stream `locator`. Returns
/// the pointer position or an error.
seek :: fn (stream: *Stream, locator := StreamLocator.CURRENT, offset: s64 = 0) (position: s64, err: Error) {
    assert(stream);
    assert(stream.vtable);
    if !stream.vtable.seek { panic("Stream does not support position seeking, 'seek' function is missing."); }
    return stream.vtable.seek(stream, locator, offset);
}
