//! # Input/Ouput
//! 
//! `#import "std/io"`
//!
//! Input and output is handled by generic stream interface containing callbacks for read, write and
//! seek operations. The stream itself can contain any data needed (i.e. memory buffer, handle to file,
//! etc.), generic functionality is handled via virtual table containing pointers to the implementation
//! of all needed (supported) stream API functions.
//!
//! ### Example
//!
//! ```c
//! #import "std/io"
//!
//! MyStream :: struct {
//!     vtable: *MyStreamVTable;
//!     buffer: [64]u8;
//!     position: s64;
//! }
//!
//! MyStreamVTable :: struct {
//!     using std;
//!     read: StreamReadFn(MyStream);
//!     write: StreamWriteFn(MyStream);
//! }
//!
//! MY_STRAM_VTABLE :: MyStreamVTable.{
//!     read = &my_read,
//!     write = &my_write
//! };
//!
//! my_read :: fn (stream: *MyStream, dest: *u8, bytes_to_read: s64) (s64, Error) {
//!     using std;
//!     size := min(stream.position, bytes_to_read);
//!     stream.position -= size;
//!     assert(stream.position >= 0);
//!     if size > 0 { memcpy(dest, &stream.buffer[stream.position], auto size); }
//!     return size, OK;
//! }
//!
//! my_write :: fn (stream: *MyStream, src: *u8, bytes_to_write: s64) (s64, Error) {
//!     size :: std.min(stream.buffer.len - stream.position, bytes_to_write);
//!     if size > 0 { memcpy(&stream.buffer[stream.position], src, auto size); }
//!     stream.position += size;
//!     assert(stream.position <= stream.buffer.len);
//!     return size, OK;
//! }
//!
//! main :: fn () s32 {
//!     using std;
//!
//!     stream := MyStream.{ vtable = &MY_STRAM_VTABLE };
//!
//!     write_string(&stream, "Hello");
//!     write_string(&stream, "World");
//!
//!     str := str_new();
//!     defer str_delete(&str);
//!
//!     read_string(&stream, &str);
//!
//!     print("%\n", str);
//!     return 0;
//! }
//! ```

#scope std

/// Stream seek offset locator.
StreamLocator :: enum {
    CURRENT;
    BEGIN;
    END;
}

/// Returns type of the stream read function for the stream of `TStream` type.
StreamReadFn :: fn (TStream: type) type #comptime {
    return *fn(stream: *TStream, dest: *u8, bytes_to_write: s64) (bytes_read: s64, err: Error);
}

/// Returns type of the stream write function for the stream of `TStream` type.
StreamWriteFn :: fn (TStream: type) type #comptime {
    return *fn(stream: *TStream, src: *u8, bytes_to_read: s64) (bytes: s64, err: Error);
}

/// Returns type of the stream seek function for the stream of `TStream` type.
StreamSeekFn :: fn (TStream: type) type #comptime {
    return *fn(stream: *TStream, locator: StreamLocator, offset: s64) (position: s64, err: Error);
}

// =================================================================================================
// Writing
// =================================================================================================

/// Write `bytes_to_write` count of bytes from the `str` into the stream. Returns
/// count of actually written bytes or an error.
write :: fn (stream: *?TStream, src: *u8, bytes_to_write: s64) (s64, Error) #inline {
#if !has_member(@TStream.vtable, "write") {
    compiler_error("Stream does not support writing.");
}
    assert(stream && stream.vtable && stream.vtable.write);
    if bytes_to_write < 1 { return 0, OK; }
    return stream.vtable.write(stream, src, bytes_to_write);
}

/// Write the data slice into the stream, the `bytes_to_write` can be specified to limit count
/// of written bytes. Returns count of actually written bytes or an error.
write_slice :: fn (stream: *?TStream, data: []u8, bytes_to_write := std.S64_MAX) (s64, Error) #inline {
    return write(stream, data.ptr, min(data.len, bytes_to_write));
}

/// Write the data string into the stream, the `bytes_to_write` can be specified to limit count
/// of written bytes. Returns count of actually written bytes or an error.
write_string :: fn (stream: *?TStream, str: string_view, bytes_to_write := std.S64_MAX) (s64, Error) #inline {
    return write(stream, str.ptr, min(str.len, bytes_to_write));
}

// =================================================================================================
// Reading
// =================================================================================================

/// Read `bytes_to_read` count of bytes from the stream into `dest` memory. Returns count of actually
/// read bytes or an error.
read :: fn (stream: *?TStream, dest: *u8, bytes_to_read: s64) (s64, Error) #inline {
#if !has_member(@TStream.vtable, "read") {
        compiler_error("Stream does not support reading.");
}
        assert(stream && stream.vtable && stream.vtable.read);
        if bytes_to_read < 1 { return 0, OK; }
        return stream.vtable.read(stream, dest, bytes_to_read);
}

/// Read `bytes_to_read` count of bytes from the stream into `dest` dynamic array. Returns count of actually
/// read bytes or an error.
read_data :: fn (stream: *?TStream, dest: *[..]u8, bytes_to_read: s64 = std.S64_MAX) (s64, Error) {
    tmp: [512]u8 #noinit;
    read_bytes: s64;
    loop bytes_to_read > 0 {
        bytes, err :: read(stream, tmp.ptr, min(tmp.len, bytes_to_read));
        if err { return read_bytes, err; }
        if bytes == 0 { break; }
        read_bytes += bytes;
        bytes_to_read -= bytes;
        array_push_all(dest, []u8.{ ptr = tmp.ptr, len = bytes });
    }
    return read_bytes, OK;
}

/// Read `bytes_to_read` count of bytes from the stream into `dest` stream. Returns count of actually
/// read bytes or an error.
read_string :: fn (stream: *?TStream, dest: *string, bytes_to_read: s64 = std.S64_MAX) (s64, Error) {
    tmp: [512]u8 #noinit;
    read_bytes: s64;
    loop bytes_to_read > 0 {
        bytes, err :: read(stream, tmp.ptr, min(tmp.len, bytes_to_read));
        if err { return read_bytes, err; }
        if bytes == 0 { break; }
        read_bytes += bytes;
        bytes_to_read -= bytes;
        str :: string_view.{ ptr = tmp.ptr, len = bytes };
        str_append(dest, str);
    }
    return read_bytes, OK;
}

// =================================================================================================
// Other
// =================================================================================================

/// Set the stream pointer position to the `offset` value relative to the stream `locator`. Returns
/// the pointer position or an error.
seek :: fn (stream: *?TStream, locator := StreamLocator.CURRENT, offset: s64 = 0) (position: s64, err: Error) {
#if !has_member(@TStream.vtable, "seek") {
    compiler_error("Stream does not support position seeking, 'seek' function is missing.");
}
    assert(stream && stream.vtable && stream.vtable.seek);
    return stream.vtable.seek(stream, locator, offset);
}
