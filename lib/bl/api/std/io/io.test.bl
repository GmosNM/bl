#import "std/io"
#private

MyStream :: struct {
    vtable: *MyStreamVTable;
    buffer: [64]u8;
    index: s64;
}

MyStreamVTable :: struct {
    using std;

    read: StreamReadFn(MyStream);
    write: StreamWriteFn(MyStream);
    get_position: StreamGetPositionFn(MyStream);
    set_position: StreamSetPositionFn(MyStream);
}

MY_STREAM_VTABLE :: MyStreamVTable.{
    read = &my_read,
    write = &my_write,
    set_position = &my_set_position,
    get_position = &my_get_position,
};

my_read :: fn (stream: *MyStream, dest: *u8, bytes_to_read: s64) (s64, Error) {
    using std;
    size := min(stream.index, bytes_to_read);
    stream.index -= size;
    assert(stream.index >= 0);
    if size > 0 { memcpy(dest, &stream.buffer[stream.index], auto size); }
    return size, OK;
}

my_write :: fn (stream: *MyStream, src: *u8, bytes_to_write: s64) (s64, Error) {
    size :: std.min(stream.buffer.len - stream.index, bytes_to_write);
    if size > 0 { memcpy(&stream.buffer[stream.index], src, auto size); }
    stream.index += size;
    assert(stream.index <= stream.buffer.len);
    return size, OK;
}

my_set_position :: fn (stream: *MyStream, locator: std.StreamLocator, offset: s64) Error {
    using std.StreamLocator;
    switch locator {
        CURRENT { stream.index += offset; }
        BEGIN   { stream.index = offset;  }
        END     { stream.index = stream.buffer.len; }
    }
    return OK;
}

my_get_position :: fn (stream: *MyStream) s64 {
    return stream.index;
}

init_stream :: fn (stream: *MyStream) {
    stream.vtable = &MY_STREAM_VTABLE;
}

write_read_empty :: fn () #test {
    using std;
    stream: MyStream;
    init_stream(&stream);

    written, write_err :: write(&stream, null, 0);
    test_ok(write_err);
    test_eq(written, 0);

    read, read_err :: std.read(&stream, null, 0);
    test_ok(read_err);
    test_eq(read, 0);
}

write_read_string :: fn () #test {
    using std;
    stream: MyStream;
    init_stream(&stream);

    data :: "Hello!";
    loop i := 0; i < 3; i += 1 {
        written, write_err :: write_string(&stream, data);
        test_ok(write_err);
        test_eq(written, 6);
    }
    test_eq(get_position(&stream), 18);

    dest := str_new();
    defer str_delete(&dest);
    read, read_err :: std.read_string(&stream, &dest);
    test_ok(read_err);
    test_eq(read, 18);
    test_eq(get_position(&stream), 0);
}

positions :: fn () #test {
    using std;
    stream: MyStream;
    init_stream(&stream);

    set_position(&stream, StreamLocator.END);
    test_eq(get_position(&stream), stream.buffer.len);
    set_position(&stream, StreamLocator.BEGIN);
    test_eq(get_position(&stream), 0);
}
