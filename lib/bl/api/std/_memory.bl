//************************************************************************************************
// bl
//
// File:   memory.bl
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "std/basic.bl"
#load "std/utils.bl"

/*!
# alloc
## Declaration
```c
alloc :: fn (size: usize) *u8
```

## Description
  Allocates count of bytes on heap using default allocator.
Use `free` to free allocated memory when it's no longer
needed. Cause panic when allocation is not possible. This
function use allocator set in `_context.alloc_fn`

## Arguments
  * `size`
    Bytes to be allocated. 

## Result
  Pointer to begin of the new allocated block of memory.
*/
alloc :: fn (size: usize) *u8 {
    mem :: _context.alloc_fn(size); 
    if !mem { panic("Bad alloc"); }
    return mem;
};

/*!
# calloc
## Declaration
```c
calloc :: fn (num: usize, size: usize) *u8
```

## Description
  Allocates count of bytes on heap using default allocator and
  return pointer to begin of this allocated block. Resulting
  block is set to 0 value.
  Use `free` to free allocated memory when it's no longer
  needed.

## Arguments
  * `num`
    Count of items to be allocated. 
  * `size`
    Item size in bytes. 

## Result
  Pointer to begin of the new allocated block of memory.
*/
calloc :: fn (num: usize, size: usize) *u8 {
    tmp := _context.alloc_fn(size * num);
    return memset(tmp, 0, size * num);
};

/*!
# free
## Declaration
```c
free :: fn (ptr: *u8)
```

## Description
  Free memory alocated on heap. This function use default
  deallocator `_context.free_fn`.

## Arguments
  * `ptr`
    Memory to be deallocated. 
*/
free :: fn (ptr: *u8) {
    _context.free_fn(ptr);
};

/*!
# memcpy
## Declaration
```c
memcpy :: fn (dest: *u8, src: *u8, size: usize)
```

## Description
  Copy memory of defined size from source to destination. Destination
and source size must be at least `size` bytes.

## Arguments
  * `dest`
    Pointer to destination memory. 
  * `src`
    Pointer to source memory. 
  * `size`
    Count of bytes to be copied. 
 */
memcpy :: fn (dest: *u8, src: *u8, size: usize) {
    m := size / sizeof(u64);
    d := size - m * sizeof(u64);

    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        ^tmp = ^cast(*u64) src;

        dest = ptr_shift_bytes(dest, auto sizeof(u64));
        src = ptr_shift_bytes(src, auto sizeof(u64));
    }
    
    loop i : usize = 0; i < d; i += 1 {
        tmp := dest;
        ^dest = ^src;

        dest = ptr_shift_bytes(dest, 1);
        src = ptr_shift_bytes(src, 1);
    }
};

/*!
# memset
## Declaration
```c
memset :: fn (_dest: *u8, v: u8, size: usize) *u8
```

## Description
  Set memory to desired value. Destination size must be at 
least `size` bytes.

## Arguments
  * `_dest`
    Pointer to target memory block. 
  * `v`
    Desired value. 
  * `size`
    Count of bytes to be set. 

## Result
  Pointer to destination memory. 
*/
memset :: fn (_dest: *u8, v: u8, size: usize) *u8 {
    dest := {:[]u8: auto size, _dest};
    loop i := 0; i < dest.len; i += 1 {
        dest[i] = v;
    }

    return dest.ptr;
}

/*!
# make
## Declaration
```c
make :: fn (_v: Any, n: s64) *u8 
```

## Description
  Allocate heap memory for value. This function is more generic version of the
`alloc` function. Data type, pointer variable or slice variable can be passed
as `_v` value. The `n` argument specify how many elements to allocate. Memory
allocated by `make` must be freed by `release` function. Allocated memory block
is always set to default 0 value.

  This way of memory allocation cause some overhead compared to plain `alloc` due to 
conversion to `Any` and more 'generic' behaviour, also setting to 0 have some 
runtime cost. Consider use of `alloc` instead in performance-critical cases.

## Arguments
  * `_v`
    Value to allocate or data type. 
  * `n`
    Number of elements. 

## Result
  Pointer to allocated memory. 

## Example
```c
main :: fn () s32 {
    { // Allocate memory for one number.
        ptr: *s32;
        make(ptr, 1);
        
        (^ptr) = 10;

        // free allocated memory
        release(ptr);
    }

    { // Another way to allocate number
        // We pass type of element to be allocated as value to make.
        // In this case it's s32.
        ptr: *s32 = auto make(s32, 1);
        (^ptr) = 10;
        release(ptr);
    }

    { // Allocate c-like array 
        // We allocate memory for 10 numbers.
        ptr: *s32 = auto make(s32, 10);
        (^ptr) = 10;
        release(ptr);
    }

    { // Allocate slice of 10 numbers
        sl: []s32;
        make(sl, 10);

        loop i := 0; i < sl.len; i += 1 {
            sl[i] = i;
        }

        release(sl);
    }

    return 0;
}
```
*/
make :: fn (_v: Any, n: s64) *u8 #compiler {
    T :: _v.type_info;
    mem: *u8; 

    if n < 0 { panic("Attempt to allocate 0 values by make!"); }

    switch T.kind {
        TypeKind.Ptr {
            elem_size :: (cast(*TypeInfoPtr) T).pointee_type.size_bytes;
            bytes :: elem_size * auto n;
            mem = alloc(bytes);
            memset(mem, 0, bytes);

            dest := cast(**u8) _v.data;
            (^dest) = mem;
        }

        TypeKind.Struct {
            T_struct :: cast(*TypeInfoStruct) T;
            if T_struct.is_slice {
                T_ptr :: cast(*TypeInfoPtr) (cast(*TypeInfoStruct) T).members[1].base_type;

                elem_size :: T_ptr.pointee_type.size_bytes;
                dest := cast(*[]u8) _v.data;
                bytes :: elem_size * auto n;
                dest.ptr = alloc(bytes);
                dest.len = n;

                memset(dest.ptr, 0, bytes); 
                mem = dest.ptr;
            } else {
                panic("Cannot make allocation for destination type '%'!", T.kind);
            }
        }

        TypeKind.Type {
                T_alloc :: cast(*TypeInfo) _v.data;
                elem_size :: T_alloc.size_bytes;
                bytes :: elem_size * auto n;
                mem = alloc(bytes);
                memset(mem, 0, bytes); 
        }

        default {
            panic("Cannot make allocation for destination type '%'!", T.kind);
        }
    }

    return mem;
}

/*!
# make
## Declaration
```c
release :: fn (_v: Any)
```

## Description
  Release memory allocated by `make` call. For more information check out
`make` documentation page.

## Arguments
  * `_v`
    Allocated value. 
*/
release :: fn (_v: Any) #compiler {
    T :: _v.type_info;

    switch T.kind {
        TypeKind.Ptr {
            tmp := cast(**u8) _v.data;
            free(^tmp);
            (^tmp) = null;
        }

        TypeKind.Struct {
            T_struct :: cast(*TypeInfoStruct) T;
            if T_struct.is_slice {
                tmp := cast(*[]u8) _v.data;
                free (tmp.ptr);
                tmp.ptr = null;
                tmp.len = 0;
            } else {
                panic("Cannot release allocation of type '%'!", T.kind);
            }
        }

        default {
            panic("Cannot release allocation of type '%'!", T.kind);
        }
    }
}


_mem_alloc_default :: fn (size: usize) *u8 {
    return c_malloc(size);
}

_mem_free_default :: fn (ptr: *u8) {
    c_free(ptr);
}
