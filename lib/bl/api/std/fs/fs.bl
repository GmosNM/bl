//! # File System
//! 
//! `#import "std/fs"`
//! 
//! File system module for manipulation with files and directories. This module provides an 
//! abstraction over operating system APIs such as creating files and directories, reading and 
//! writing, and scanning the filesystem.

#scope std

// =================================================================================================
// File utils
// =================================================================================================

/// File handle type.
File :: _fs_impl.File;

/// Invalid file handle. This can be used for file handle validation.
FILE_INVALID :: _fs_impl.FILE_INVALID;

/// Specify operation with opened file.
FileOpenMode :: enum #flags {
    /// Open file for reading.
    READ;
    /// Open file for writing and truncate its content.
    WRITE;
    /// Open file for appending (keeps current content).
    APPEND;
    /// Create file if it does not exist.
    CREATE;
}

/// Open an file specified by `filepath`. Function return file handle and `OK` status when file was 
/// opened, otherwise return invalid handle and proper error. File must be closed by [file_close](#stdfile_close)
/// call.
///
/// File open `mode` is optional, any combination of `FileOpenMode` can be used. When `Create` 
/// `mode` is specified, new file is created on `filepath` only if it does not exist, otherwise 
/// already existing file is used. `Read` `mode` is used as default when neither `Read`, `Write` or 
/// `Append` is specified.
///
/// ### Example
///
/// ```
/// #import "std/fs"
/// 
/// main :: fn () s32 {
///     file, err :: std.file_open(#file);
///     defer std.file_close(file);
///     if !is_ok(err) {
///         print_err("%", err);
///         return 1;
///     }
///     return 0;
/// }
/// ```
///
/// **todo*: Mode should be passed as flags in the future.
file_open :: fn (filepath: string_view, mode: FileOpenMode = FileOpenMode.READ) (File, Error) #inline {
    return _fs_impl.open(filepath, mode);
}

/// Close previously openned file. Does nothing when `handle` is not valid.
file_close :: fn (handle: File) #inline {
    _fs_impl.close(handle);
}

/// Try to remove file specified by `filepath` and return `OK` on success, otherwise return error.
file_remove :: fn (filepath: string_view) Error #inline {
    return _fs_impl.remove(filepath);
}

/// Copy existing file from `src` to `dest` and override existing file in destination if `override` 
/// is true. Return `ok` or `error`.
///
/// !!! note
///     `src` and `dest` path can be relative path to current working path set by
///     [set_cwd](#stdset_cwd).
file_copy :: fn (src: string_view, dest: string_view, override := false) Error #inline {
    return _fs_impl.copy(src, dest, override);
}

/// Return file content size in bytes and `OK` status on success, otherwise return zero and proper 
/// error.
file_size :: fn (handle: File) (usize, Error) #inline {
    return _fs_impl.size(handle);
}

/// Return file id.
file_uid :: fn { _fs_impl.get_uid; _fs_impl.get_uid_by_name; }

// =================================================================================================
// Directory utils
// =================================================================================================

/// Create new directory and return `OK` on success. This function does not create directories 
/// recursively.
dir_create :: fn (dirpath: string_view) Error #inline {
    return _fs_impl.dir_create(dirpath);
}

dir_create_all :: fn (dirpath: string_view) Error {
    if str_is_empty(dirpath) { return error(ERR_INVALID_HANDLE, "Dir path is empty!"); }
    if _fs_impl.exist(dirpath) { return ok(); } 
    nodes :: str_split_by(dirpath, '/');
    defer slice_terminate(&nodes);
    path :: str_new(auto dirpath.len);
    defer str_delete(&path);
    loop i := 0; i < nodes.len; i += 1 {
        if nodes[i].len == 0 { continue; }
        str_append(&path, nodes[i]);
        str_append(&path, "/");
        if _fs_impl.exist(path) { continue; } 
        err :: _fs_impl.dir_create(path);
        if !is_ok(err) { return err; }
    }
    return ok();
}

/// Remove directory specified by `dirpath` and return `OK` on success, otherwise return an error.
dir_remove :: fn (dirpath: string_view) Error #inline {
    return _fs_impl.dir_remove(dirpath);
}

/// Filesystem entry description.
Info :: struct {
    /// `True` in case the entry is a directory.
    is_directory: bool;
    /// File or directory name.
    filename: string_view;
    /// File or directory full path.
    filepath: string_view;
}

/// Remove (even non-empty) directory specified by `dirpath` and return `OK` on success, otherwise return
/// an error. Root directory is removed if `remove_root` is `true`. Custom file `filter` function
/// can be specified as needed.
///
/// **Overloads:**
/// ```c
/// fn (dirpath: string_view, remove_root := true) Error #inline
/// fn (dirpath: string_view, remove_root: bool, filter: *fn(info: *Info, ctx: *?T) bool, ctx: *T = null) Error
/// ```
///
/// When the `filter` callback is specified, it's called for each visited file or directory. Returning `true`
/// means the entry should be deleted.
///
/// !!! warning
///     When some files are excluded by the `filter` function the parent directory cannot be removed (it's not empty).
///     Be careful excluding directories.
///
/// !!! note
///     This function recursively remove all nested folders and files in specified sub tree
///     so it can be expensive.
///
dir_remove_all :: fn {
    impl_dir_remove_all;
    impl_dir_remove_all_with_filter;
}

/// Visit file options used in [dir_visit_files](dir_visit_files).
VisitOpt :: struct {
    /// Visit all subfolders when `true`.
    recursive: bool;
    /// Visit the most nested files first.
    leaf_first: bool;
}

/// Visit all files and directories in `dirpath` with specified `visitor` callback called for each found
/// file entry. Optional context `ctx` pointer can be passed into the function.
dir_visit_files :: fn (dirpath: string_view, opt: VisitOpt, visitor: *fn(info: *Info, ctx: *?T) Error, ctx: *T = null) Error #inline {
    assert(visitor);
    return _fs_impl.dir_visit_files(dirpath, opt.recursive, opt.leaf_first, auto visitor, auto ctx);
}

/// Check whether `path` points to valid directory and return true with `OK` state, otherwise return
/// `false` and error.
is_directory :: fn (path: string_view) (bool, Error) #inline {
    return _fs_impl.is_directory(path);
}

// =================================================================================================
// Other
// =================================================================================================

/// Checks whether `name` is valid file name on current platform.
validate_filename :: fn (name: string_view) bool #inline {
    return _fs_impl.validate_filename(name);
}

/// Check whether file or directory exists.
file_exist :: fn (filepath: string_view) bool #inline {
    return _fs_impl.exist(filepath);
}

/// Try to normalize `filepath`, basically try to remove all relative path nodes `..` and `.`. Path 
/// must be valid path (existing) on system. Original `filepath` is extended with current working 
/// directory. Function return `OK` on success or proper error on fail. Original string is not 
/// modified when error occurs.
path_normalize :: fn (filepath: *string) Error #inline {
    return _fs_impl.normalize(filepath);
}

/// Split input `filepath` into head and tail components. The `tail` is the last `filepath` component
/// and the `head` is everything before. Only unix `/` path delimiters are supported. The `tail`
/// component never contains path separators.
///
/// ### Example
///
/// | filepath                | head        | tail         |
/// |-------------------------|-------------|--------------|
/// | C:/foo/bar/file.txt     | C:/foo/bar/ | file.txt     |
/// | file.txt                | -           | file.txt     |
/// | /usr/local/.hidden.file | /usr/local/ | .hidden.file |
/// | /                       | /           | -            |
/// | C:/                     | C:/         | -            |
///
/// !!! note
///     Returned components may not be zero terminated.
path_split :: fn (filepath: string_view) (head: string_view, tail: string_view) {
    if str_is_empty(filepath) { return str_empty, str_empty; }

    head, tail: string_view;
    if !str_split_by_last(filepath, '/', &head, &tail) {
        tail = head;
        head= str_empty;
    } else {
        head.len += 1;
    }
    return head, tail;
}

/// Split input `filepath` into `head` and `ext` components. The `ext` is the file extension  and the `head` is
/// everything before. 
///
/// ### Example
///
/// | filepath                | head               | ext          |
/// |-------------------------|--------------------|--------------|
/// | C:/foo/bar/file.txt     | C:/foo/bar/file    | .txt         |
/// | file.txt                | file               | .txt         |
/// | /usr/local/.hidden.file | /usr/local/.hidden | .file        |
/// | /                       | /                  | -            |
/// | C:/                     | C:/                | -            |
///
/// !!! note
///     Returned components may not be zero terminated.
path_splitext :: fn (filepath: string_view) (head: string_view, ext: string_view) {
    if str_is_empty(filepath) { return str_empty, str_empty; }
    head, ext: string_view;
    index: s32;
    if str_split_by_last(filepath, '.', &head, &ext, &index) {
        ext.ptr = &filepath[index];
        ext.len += 1;
    }
    return head, ext;
}

/// Try to obtain current working directory, result must be released by `std.str_delete`. Path does 
/// not contain last path separator.
get_cwd :: fn () string #inline {
    return _fs_impl.get_cwd();
}

/// Sets current working directory and return `OK` on success, otherwise return error.
set_cwd :: fn (path: string_view) Error #inline {
    return _fs_impl.set_cwd(path);
}

/// Try to obtain system home directory, result must be released by `std.str_delete`. Path does not 
/// contain last path separator.
get_home :: fn () string #inline {
    return _fs_impl.get_home();
}

/// Try to obtain system temporary directory, result must be released by `std.str_delete`. Path does 
/// not contain last path separator.
get_tmp :: fn () string #inline {
    return _fs_impl.get_tmp();
}

#private
default_filter : *fn (_: *Info, _: *u8) bool : null;

impl_dir_remove_all :: fn (dirpath: string_view, remove_root := true) Error #inline {
    return impl_dir_remove_all_with_filter(dirpath, remove_root, default_filter);
}

impl_dir_remove_all_with_filter :: fn (dirpath: string_view, remove_root: bool, filter: *fn(info: *Info, ctx: *?T) bool, ctx: *T = null) Error {
    if str_is_empty(dirpath) { return ok(); }

    Data :: struct {
        filter: *fn(info: *Info, ctx: *u8) bool;
        ctx: *u8;
    };

    visitor :: fn (info: *Info, data: *Data) Error {
        if (!data.filter) || data.filter(info, data.ctx) {
            if (info.is_directory) {
                return _fs_impl.dir_remove(info.filepath);
            }
            return _fs_impl.remove(info.filepath);
        }
        return ok();
    };

    data :: Data.{ filter, ctx };
    err :: dir_visit_files(dirpath, VisitOpt.{ recursive = true, leaf_first = true }, &visitor, &data);
    if !is_ok(err) { return err; }
    if remove_root { return _fs_impl.dir_remove(dirpath); }
    return ok();
}
