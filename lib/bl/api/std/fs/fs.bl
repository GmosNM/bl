//! # File System
//! 
//! `#import "std/fs"`
//! 
//! File system module for manipulation with files and directories. This module provides an 
//! abstraction over operating system APIs such as creating files and directories, reading and 
//! writing, and scanning the filesystem.

#scope std

// =================================================================================================
// File utils
// =================================================================================================

/// File handle type.
File :: _fs_impl.File;

/// Invalid file handle. This can be used for file handle validation.
FILE_INVALID :: _fs_impl.FILE_INVALID;

/// Specify operation with opened file.
FileOpenMode :: enum #flags {
    /// Open file for reading.
    READ;
    /// Open file for writing and truncate its content.
    WRITE;
    /// Open file for appending (keeps current content).
    APPEND;
    /// Create file if it does not exist.
    CREATE;
}

/// Open an file specified by `filepath`. Function return file handle and `OK` status when file was 
/// opened, otherwise return invalid handle and proper error. File must be closed by [close](#close) 
/// call.
///
/// File open `mode` is optional, any combination of `FileOpenMode` can be used. When `Create` 
/// `mode` is specified, new file is created on `filepath` only if it does not exist, otherwise 
/// already existing file is used. `Read` `mode` is used as default when neither `Read`, `Write` or 
/// `Append` is specified.
///
/// ### Example
///
/// ```
/// #import "std/fs"
/// 
/// main :: fn () s32 {
///     file, err :: std.file_open(#file);
///     defer std.file_close(file);
///     if !is_ok(err) {
///         print_err("%", err);
///         return 1;
///     }
///     return 0;
/// }
/// ```
///
/// **todo*: Mode should be passed as flags in the future.
file_open :: fn (filepath: string, mode: FileOpenMode = std.FileOpenMode.READ) (File, Error) #inline {
    return _fs_impl.open(filepath, mode);
}

/// Close previously openned file. Does nothing when `handle` is not valid.
file_close :: fn (handle: File) #inline {
    _fs_impl.close(handle);
}

/// Try to remove file specified by `filepath` and return `OK` on success, otherwise return error.
file_remove :: fn (filepath: string) Error #inline {
    return _fs_impl.remove(filepath);
}

/// Copy existing file from `src` to `dest` and override existing file in destination if `override` 
/// is true. Return `ok` or `error`.
///
/// **note**: `src` and `dest` path can be relative path to current working path set by 
/// [set_cwd](#set_cwd).
file_copy :: fn (src: string, dest: string, override := false) Error #inline {
    return _fs_impl.copy(src, dest, override);
}

/// Return file content size in bytes and `OK` status on success, otherwise return zero and proper 
/// error.
file_size :: fn (handle: File) (usize, Error) #inline {
    return _fs_impl.size(handle);
}

/// Return file id.
file_uid :: fn { _fs_impl.get_uid; _fs_impl.get_uid_by_name; }

// =================================================================================================
// Directory utils
// =================================================================================================

/// Create new directory and return `OK` on success. This function does not create directories 
/// recursively.
dir_create :: fn (dirpath: string) Error #inline {
    return _fs_impl.dir_create(dirpath);
}

dir_create_all :: fn (dirpath: string) Error {
    if std.str_is_empty(dirpath) { return error(ERR_INVALID_HANDLE, "Dir path is empty!"); }
    if _fs_impl.exist(dirpath) { return ok(); } 
    nodes :: std.str_split_by(dirpath, '/');
    defer slice_terminate(&nodes);
    path :: std.str_new(auto dirpath.len);
    defer std.str_delete(path);
    loop i := 0; i < nodes.len; i += 1 {
        if nodes[i].len == 0 { continue; }
        std.str_append(&path, nodes[i]);
        std.str_append(&path, "/");
        if _fs_impl.exist(path) { continue; } 
        err :: _fs_impl.dir_create(path);
        if !is_ok(err) { return err; }
    }
    return ok();
}

/// Remove directory specified by `dirpath` and return `OK` on success, otherwise return an error.
dir_remove :: fn (dirpath: string) Error #inline {
    return _fs_impl.dir_remove(dirpath);
}

/// Specify kind of file system entry.
InfoKind :: enum {
    FILE;
    DIRECTORY;
}

/// Helper container to hold information about file system entry.
Info :: struct {
    kind: InfoKind;
    name: string;
}

InfoList :: []Info;

/// Release allocated file system entry info list.
info_list_delete :: fn (list: InfoList) #inline {
    loop i := 0; i < list.len; i += 1 {
        std.str_delete(list[i].name);
    }
    slice_terminate(&list);
}

/// Remove non-empty directory specified by `dirpath` and return `OK` on success, otherwise return 
/// an error. Root directory is removed if `remove_root` is `true`. Custom file `filter` function 
/// can be specified as needed.
///
/// **note**: This function recursively remove all nested folders and files in specified sub tree 
/// so it can be expensive.
dir_remove_all :: fn (dirpath: string, remove_root := true, filter: DirScanFilterFn = &_default_file_filter) Error {
    if std.str_is_empty(dirpath) { return error(ERR_INVALID_HANDLE, "Dir path is empty!"); }
    if !filter { return error(ERR_INVALID_HANDLE, "Invalid list filter!"); }
    tmp :: std.str_new( dirpath.len);
    defer std.str_delete(tmp);
    list, err :: _fs_impl.dir_scan(dirpath, filter);
    if !is_ok(err) { return err; }
    defer info_list_delete(list);
    loop i := 0; i < list.len; i += 1 {
        node :: &list[i];
        std.str_concat(&tmp, dirpath, "/", node.name);
        switch node.kind {
            InfoKind.DIRECTORY {
                err :: dir_remove_all(tmp);
                if !is_ok(err) { return err; }
            }            
            InfoKind.FILE {
                err :: _fs_impl.remove(tmp);
                if !is_ok(err) { return err; }
            }
        }
        std.str_clear(&tmp);
    }
    if remove_root { return _fs_impl.dir_remove(dirpath); }
    return ok();
}

/// Type of `dir_scan` filter function.
DirScanFilterFn :: *fn(info: *Info) bool;

/// Scan `dirpath` directory and return list of information for every file system entry found on 
/// success. Otherwise return empty list and error. Use [info_list_delete](#info_list_delete) to 
/// release list when there was no error reported by this function.
///
/// Optional `filter` funtion [DirScanFilterFn](#dirscanfilterfn) can be used to filter scan results
/// directly during scanning, it's called for every found entry and only those for whose filter yields 
/// true are added into the output list.
dir_scan :: fn (dirpath: string, filter: DirScanFilterFn = &_default_file_filter) (InfoList, Error) #inline {
    return _fs_impl.dir_scan(dirpath, filter);
}

/// Specify behavior of `dir_copy`.
DirCopyOpt :: struct {
    /// Copy all directories and sub-directories.
    recursive: bool;
    /// Override existing entries.
    override: bool;
    /// Skip already existing entries.
    skip_existing: bool;
}

/// Copy from `src` path to `dest` path with specified `opt` options and return  count of processed 
/// files or error.
///
/// ### Example:
///
/// ```
/// #import "std/fs"
/// 
/// main :: fn () s32 {
///     // Copy options
///     opt: std.DirCopyOpt;
///     // Create destination directory if not exist.
///     opt.recursive = true;
///     // Override all existing entries.
///     opt.override = true;
/// 
///     // Copy content of 'foo' into 'bar'
///     c, err :: std.dir_copy("foo", "bar", &opt, &fn (item: *std.Info) bool {
///         // Filter only txt files
///         if std.str_match(std.path_get_extension(item.name), "txt") { return true; } 
///         return false;
///     });
///     if !is_ok(err) { print("%\n", err); }
///     else { print("Copied % files!\n", c); }
///     return 0;
/// }
/// ```
///
/// @INCOIMPLETE Is using current dir + better descriptions.
dir_copy :: fn (src: string, dest: string, opt: *DirCopyOpt = &DIR_COPY_OPT_DEFAULT, filter: DirScanFilterFn = &_default_file_filter) (s64, Error) {
    cc: s64;
    if !opt                   { return 0, error(ERR_INVALID_HANDLE, "Invalid copy options!"); }
    if std.str_is_empty(src)  { return 0, error(ERR_INVALID_HANDLE, "Source path is empty!"); }
    if std.str_is_empty(dest) { return 0, error(ERR_INVALID_HANDLE, "Destination path is empty!"); }
    if !_fs_impl.exist(src)   { return 0, error(ERR_NOT_FOUND, "Source path '%' not exist!", src); }
    if !_fs_impl.exist(dest) {
        if opt.recursive {
            err :: _fs_impl.dir_create(dest);
            if !is_ok(err) { return 0, err; }
        } else {
            return 0, error(ERR_NOT_FOUND, "Destination path '%' not exist!", dest);
        }
    }
    is_src_valid := _fs_impl.is_directory(src);
    if !is_src_valid { return 0, error("Source '%' is not directory!", src); }
    is_dest_valid := _fs_impl.is_directory(dest);
    if !is_dest_valid { return 0, error("Destination '%' is not directory!", dest); }

    dest_path :: std.str_new(128);
    src_path :: std.str_new(128);
    defer std.str_delete(dest_path);
    defer std.str_delete(src_path);
    std.str_clear_concat(&dest_path, dest, "/", src); 
    if _fs_impl.exist(dest_path) { return 0, error("Destination directory '%' already exist!", dest_path); }
    list, list_err :: _fs_impl.dir_scan(src, filter);
    if !is_ok(list_err) { return 0, list_err; }
    defer info_list_delete(list);
    loop i := 0; i < list.len; i += 1 {
        copy_err: Error;
        _cc: s64;
        std.str_clear_concat(&src_path, src, "/", list[i].name);
        std.str_clear_concat(&dest_path, dest, "/", list[i].name);
        if opt.skip_existing && _fs_impl.exist(dest_path) { continue; }
        switch list[i].kind {
            InfoKind.FILE {
                copy_err = _fs_impl.copy(src_path, dest_path, opt.override);
                _cc = 1;
            }

            InfoKind.DIRECTORY {
                c, err :: dir_copy(src_path, dest_path, opt);
                copy_err = err;
                _cc = c;
            }
        }
        if !is_ok(copy_err) { return 0, copy_err; }
        cc += _cc;
    }
    return cc, ok();
}

/// Check whether `path` points to valid directory and return true with `OK` state, otherwise return 
/// `false` and error.
is_directory :: fn (path: string) (bool, Error) #inline {
    return _fs_impl.is_directory(path);
}

// =================================================================================================
// Other
// =================================================================================================

/// Checks whether `name` is valid file name on current platform.
validate_filename :: fn (name: string) bool #inline {
    return _fs_impl.validate_filename(name);
}

/// Check whether file or directory exists.
path_exist :: fn (filepath: string) bool #inline {
    return _fs_impl.exist(filepath);
}

/// Try to normalize `filepath`, basically try to remove all relative path nodes `..` and `.`. Path 
/// must be valid path (existing) on system. Original `filepath` is extended with current working 
/// directory. Function return `OK` on success or proper error on fail. Original string is not 
/// modified when error occurs.
path_normalize :: fn (filepath: *string) Error #inline {
    return _fs_impl.normalize(filepath);
}

/// Remove file extension (token after first `.`) from the `filename` and return the rest. Function 
/// does not create copy of original `filepath`.
path_remove_extension :: fn (filename: string) string #inline {
    if std.str_is_empty(filename) { return std.str_empty; }
    tmp := filename;
    tmp.len = 0;
    loop i := 0; i < filename.len; i += 1 {
        c :: filename[i];
        if c == '.' && i > 0 { break; }
        tmp.len += 1;
    }
    return tmp;
}

/// Get file extension as a new string (token after first `.`) from the `filename` or empty string in
/// case no extension was found.
///
/// The `.` separator is not included into result string.
path_get_extension :: fn (filename: string) string #inline {
    if std.str_is_empty(filename) { return std.str_empty; }
    if filename[0] == '.' {
        if filename.len == 1 { return std.str_empty; }
        filename.len -= 1; filename.ptr = &filename[1]; 
    }
    rhs: string;
    if std.str_split_by_first(filename, '.', null, &rhs) {
        return std.str_new(rhs);
    }
    return std.str_empty;
}

/// Get directory path from filepath. Function supports only unix path delimiters. Returns directory
/// path as new string or empty string in case path was not found.
path_get_directory :: fn (filepath: string) string #inline {
    if std.str_is_empty(filepath) { return std.str_empty; }
    lhs: string;
    if std.str_split_by_last(filepath, '/', &lhs) {
        return std.str_new(lhs);
    }
    return std.str_empty;
}

/// Try to obtain current working directory, result must be released by `std.str_delete`. Path does 
/// not contain last path separator.
get_cwd :: fn () string #inline {
    return _fs_impl.get_cwd();
}

/// Sets current working directory and return `OK` on success, otherwise return error.
set_cwd :: fn (path: string) Error #inline {
    return _fs_impl.set_cwd(path);
}

/// Try to obtain system home directory, result must be released by `std.str_delete`. Path does not 
/// contain last path separator.
get_home :: fn () string #inline {
    return _fs_impl.get_home();
}

/// Try to obtain system temporary directory, result must be released by `std.str_delete`. Path does 
/// not contain last path separator.
get_tmp :: fn () string #inline {
    return _fs_impl.get_tmp();
}

#private
DIR_COPY_OPT_DEFAULT :: {:DirCopyOpt: 0};

_default_file_filter :: fn (item: *Info) bool {
    return std.str_match(item.name, ".") == false
        && std.str_match(item.name, "..") == false;
}
