#load "fs.bl"

#scope _fs_impl

File :: *u8;
FILE_INVALID : File : null;

exist :: fn (filepath: string_view) bool #inline {
    if filepath.len == 0 { return false; }
    return win32.PathFileExistsA(std.strtoc(filepath)) > 0;
}

open :: fn (filepath: string_view, mode: std.FileOpenMode) (File, Error) {
    if std.str_is_empty(filepath) { return null, error(ERR_INVALID_HANDLE, "File path is empty!"); }
    access, create, append :: modes_to_flags(mode);
    handle :: win32.CreateFile(std.strtoc(filepath), access, 0, null, create, win32.FILE_ATTRIBUTE_NORMAL, null);
    if handle == win32.INVALID_HANDLE_VALUE {
        ec, estr :: os_get_last_error();
        return null, error(ec, "Cannot open file '%': %", filepath, estr);
    }
    write :: is_flag(access, win32.GENERIC_WRITE);
    if write && !append {
        win32.SetEndOfFile(handle);
    } else if write {
        win32.SetFilePointer(handle, 0, null, win32.FILE_END);
    }
    return handle, OK;
}

remove :: fn (filepath: string_view) Error #inline {
    if std.str_is_empty(filepath) { return error(ERR_INVALID_HANDLE, "File path is empty!"); }
    tmp :: win32.DeleteFileA(std.strtoc(filepath));
    if tmp == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot remove file '%': %", filepath, estr);
    }
    return OK;
}

copy :: fn (src: string_view, dest: string_view, override: bool) Error {
    if std.str_is_empty(src) { return error(ERR_INVALID_HANDLE, "File path is empty!"); }
    if std.str_is_empty(dest) { return error(ERR_INVALID_HANDLE, "File path is empty!"); }
    fail_if_exist := 1;
    if  override { fail_if_exist = 0; }
    if win32.CopyFileA(std.strtoc(src), std.strtoc(dest), fail_if_exist) == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot copy file '%' to '%': %", src, dest, estr);
    }
    return OK;
}

close :: fn (handle: File) #inline {
    if !handle { return; }
    win32.CloseHandle(handle);
}

get_uid :: fn (handle: File) (u64, Error) {
    tmp: win32.BY_HANDLE_FILE_INFORMATION;
    if win32.GetFileInformationByHandle(auto handle, &tmp) == 0 {
        ec, estr :: os_get_last_error();
        return 0, error(ec, "Cannot get file information: %", estr);
    }
    uid :: ((cast(u64) tmp.nFileIndexHigh) << 32) + (cast(u64) tmp.nFileIndexLow);
    return uid, OK;
}

get_uid_by_name :: fn (filepath: string_view) (u64, Error) {
    file, err1 :: open(filepath, std.FileOpenMode.READ);
    defer close(file);
    if err1 { return 0, err1; }
    return get_uid(file);
}

size :: fn (handle: File) (usize, Error) #inline {
    size: win32.LARGE_INTEGER #noinit;
    if win32.GetFileSizeEx(auto handle, &size) == 0 {
        ec, estr :: os_get_last_error();
        return 0, error(ec, "Cannot get file size: %", estr);
    }
    return auto size, OK;
}

dir_create :: fn (dirpath: string_view) Error {
    if std.str_is_empty(dirpath) { return error(ERR_INVALID_HANDLE, "Cannot create directory, dirpath is empty."); }
    if win32.CreateDirectoryA(std.strtoc(dirpath), null) == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot create directory '%': %", dirpath, estr);
    }
    return OK;
}

dir_remove :: fn (dirpath: string_view) Error {
    if std.str_is_empty(dirpath) { return error(ERR_INVALID_HANDLE, "Cannot remove directory, dirpath is empty."); }
    if win32.RemoveDirectoryA(std.strtoc(dirpath)) == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot remove directory '%': %", dirpath, estr);
    }
    return OK;
}

is_directory :: fn (path: string_view) (bool, Error) #inline {
    if std.str_is_empty(path) { return false, error(ERR_INVALID_HANDLE, "Path is empty."); }
    attributes :: win32.GetFileAttributesA(std.strtoc(path));
    if attributes == win32.INVALID_FILE_ATTRIBUTES {
        ec, estr :: os_get_last_error();
        return false, error(ec, "Cannot check directory '%': %", path, estr);
    }
    return is_flag(attributes, auto win32.FILE_ATTRIBUTE_DIRECTORY), OK;
}

dir_scan :: fn (dirpath: string_view, filter: std.DirScanFilterFn) (std.InfoList, Error) {
    invalid: std.InfoList;
    if dirpath.len > (win32.MAX_PATH-3) { return invalid, error("Path too long!"); }
    tmp := std.str_new(dirpath);
    defer std.str_delete(&tmp);
    std.str_append(&tmp, "\\*");

    ffd: win32.FIND_DATA;
    h_find := win32.FindFirstFile(std.strtoc(tmp), &ffd);
    if h_find == win32.INVALID_HANDLE_VALUE {
        ec, estr :: os_get_last_error();
        return invalid, error(ec, "Cannot list directory '%': %", dirpath, estr);
    }

    fc := 0;
    loop {
        fc += 1;
        if win32.FindNextFile(h_find, &ffd) == 0 { break; }
    }

    if win32.FindClose(h_find) == 0 {
        ec, estr :: os_get_last_error();
        return invalid, error(ec, "Cannot list directory '%': %", dirpath, estr);
    }
    buf: std.InfoList;
    slice_init(&buf, fc);
    if fc == 0 { return buf, OK; }

    h_find = win32.FindFirstFile(std.strtoc(tmp), &ffd);
    if h_find == win32.INVALID_HANDLE_VALUE { 
        slice_terminate(&buf);
        ec, estr :: os_get_last_error();
        return invalid, error(ec, "Cannot list directory '%': %", dirpath, estr);
    }
    defer win32.FindClose(h_find);

    buf.len = 0;
    loop {
        kind: std.InfoKind #noinit;
        if is_flag(ffd.dwFileAttributes, auto win32.FILE_ATTRIBUTE_DIRECTORY) {
            kind = std.InfoKind.DIRECTORY;
        } else {
            kind = std.InfoKind.FILE;
        }
        name :: std.str_new(ffd.cFileName.ptr);
        push := true;
        info :: std.Info.{kind, name};
        if filter { push = filter(&info); }
        if push {
            buf.len += 1;
            buf[buf.len-1] = info;
        } else {
            std.str_delete(&name);
        }
        if win32.FindNextFile(h_find, &ffd) == 0 { break; }
    }
    return buf, OK;
}

validate_filename :: fn (name: string_view) bool {
    if name.len == 0 { return false; }
    invalid :: "<>:\"/\\|?*\t";
    loop i := 0; i < invalid.len; i += 1 {
        if std.str_count_of(name, invalid[i]) > 0 { return false; }
    }
    return true;
}

get_cwd :: fn () string #inline {
    buf: [OS_PATH_MAX]u8;
    written :: win32.GetCurrentDirectoryA(auto buf.len, auto buf.ptr);
    if written == 0 { return std.str_new(); }
    out :: std.str_new(buf.ptr);
    std.str_replace_all(&out, '\\', '/');
    return remove_last_separator(out);
}

set_cwd :: fn (path: string_view) Error #inline {
    if std.str_is_empty(path) { return error(ERR_INVALID_HANDLE, "Path is empty!"); }
    if win32.SetCurrentDirectoryA(std.strtoc(path)) == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot set current directory to '%': %", path, estr);
    }
    return OK;
}

get_home :: fn () string #inline {
    tmp :: "USERPROFILE";
    cdir :: cast(*u8) C.getenv(auto tmp.ptr);
    if !cdir { return std.str_new(); }
    out :: std.str_new(cdir);
    std.str_replace_all(&out, '\\', '/');
    return remove_last_separator(out);
}

get_tmp :: fn () string #inline {
    buf: [OS_PATH_MAX]u8;
    written :: win32.GetTempPathA(auto buf.len, auto buf.ptr);
    if written == 0 { return std.str_new(); }
    out :: std.str_new(buf.ptr);
    std.str_replace_all(&out, '\\', '/');
    return remove_last_separator(out);
}

normalize :: fn (filepath: *string) Error {
    if !filepath { return error(ERR_INVALID_HANDLE, "File path is null!"); }
    if std.str_is_empty(@filepath) { return error(ERR_INVALID_HANDLE, "File path is empty!"); }
    buf : [OS_PATH_MAX]s8 #noinit;
    if win32.GetFullPathNameA(std.strtoc(@filepath), auto buf.len, buf.ptr, null) == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot normalize '%': %", @filepath, estr);
    }
    if win32.PathFileExistsA(std.strtoc(@filepath)) == 0 {
        ec, estr :: os_get_last_error();
        return error(ec, "Cannot normalize '%': %", @filepath, estr);
    }
    std.str_clear(filepath);
    std.str_append(filepath, std.ctostr(buf.ptr));
    std.str_replace_all(filepath, '\\', '/'); // Fix to unix
    return OK;
}

#private
modes_to_flags :: fn (modes: std.FileOpenMode) (access: u32, create: u32, append: bool) #inline {
    access: u32;
    create: u32;
    append: bool;
    if is_flag(modes, std.FileOpenMode.READ) { access = access | win32.GENERIC_READ; }
    if is_flag(modes, std.FileOpenMode.WRITE) { access = access | win32.GENERIC_WRITE; }
    if is_flag(modes, std.FileOpenMode.APPEND) { access = access | win32.GENERIC_WRITE; append = true; }
    if is_flag(modes, std.FileOpenMode.CREATE) { create = win32.OPEN_ALWAYS; }
    if access == 0 { access = win32.GENERIC_READ; }
    if create == 0 { create = win32.OPEN_EXISTING; }
    return access, create, append;
}

remove_last_separator :: fn (path: string) string {
    if std.str_is_empty(path) { return path; }
    if path[path.len-1] == '/' {
        path[path.len-1] = '\0';
        path.len -= 1;
    }
    return path;
}
