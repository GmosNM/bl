#import "std/test"
#import "std/fs"
#import "std/io"

main :: fn () s32 {
    return test_run();    
}

#private
get_dummy_filepath :: fn (i := 0) string {
    tmp :: std.get_tmp();
    std.str_concat(&tmp, "/deleteme_", i);
    return tmp;
}

fs_exist_test :: fn () #test {
    test_true(std.path_exist(#file));
    test_false(std.path_exist("foobar"));
}

fs_get_home_test :: fn () #test {
    tmp :: std.get_home();
    defer std.str_delete(tmp);
    test_neq(tmp, std.str_empty);
    test_true(std.path_exist(tmp));
    test_true(tmp[tmp.len-1] != '/');

    state, err :: std.is_directory(tmp);
    test_ok(err);
    test_true(state);
}

fs_get_tmp_test :: fn () #test {
    tmp :: std.get_tmp();
    defer std.str_delete(tmp);
    test_neq(tmp, std.str_empty);
    test_true(std.path_exist(tmp));    
    test_true(tmp[tmp.len-1] != '/');

    state, err :: std.is_directory(tmp);
    test_ok(err);
    test_true(state);
}

fs_get_cwd_test :: fn () #test {
    tmp :: std.get_cwd();
    defer std.str_delete(tmp);
    test_neq(tmp, std.str_empty);
    test_true(std.path_exist(tmp));    
    test_true(tmp[tmp.len-1] != '/');

    state, err :: std.is_directory(tmp);
    test_ok(err);
    test_true(state);
}

fs_open_test1 :: fn () #test {
    file, err :: std.file_open("");
    defer std.file_close(file);
    test_is_error(err, ERR_INVALID_HANDLE);    
}
    
fs_open_test2 :: fn () #test {
    file, err :: std.file_open("foobar");
    defer std.file_close(file);
    test_is_error(err, ERR_NOT_FOUND);
}
    
fs_open_test3 :: fn () #test {
    file, err :: std.file_open(#file);    
    defer std.file_close(file);
    test_ok(err);

    // Cannot write to file when Write or Append is not specified.
    written, err2 :: std.write_string(file, "Hello!");
    test_not_ok(err2);
    test_eq(written, 0);
}

fs_file_create_test1 :: fn () #test {
    file, err :: std.file_open("", std.FileOpenMode.CREATE);
    defer std.file_close(file);
    test_is_error(err, ERR_INVALID_HANDLE);    
}

fs_file_create_test2 :: fn () #test {
    filepath :: get_dummy_filepath();
    defer std.str_delete(filepath);
    std.file_remove(filepath);

    {
        file, err :: std.file_open(filepath, std.FileOpenMode.CREATE);
        defer std.file_close(file);
        test_ok(err);

        // Cannot write to file when Write or Append is not specified.
        written, err2 :: std.write_string(file, "Hello!");
        test_not_ok(err2);
        test_eq(written, 0);
    }    

    {
        file, err :: std.file_open(filepath, make_flags(std.FileOpenMode.CREATE, std.FileOpenMode.WRITE));
        defer std.file_close(file);
        test_ok(err);

        written, err2 :: std.write_string(file, "Hello!");
        test_ok(err2);
        test_neq(written, 0);
    }    

    { // This should reuse already created file!
        file, err :: std.file_open(filepath, std.FileOpenMode.CREATE);
        defer std.file_close(file);
        test_ok(err);
        str :: std.read_string(file);
        defer std.str_delete(str);
        test_eq(str, "Hello!");
    }
    std.file_remove(filepath);
}

fs_create_append :: fn () #test {
    filepath :: get_dummy_filepath();
    defer std.str_delete(filepath);
    std.file_remove(filepath);
    { // initial create
        file, err :: std.file_open(filepath, make_flags(std.FileOpenMode.CREATE, std.FileOpenMode.WRITE));
        defer std.file_close(file);
        test_ok(err);
        std.write_string(file, "Hello!");
    }
    { // append
        file, err :: std.file_open(filepath, std.FileOpenMode.APPEND);
        defer std.file_close(file);
        test_ok(err);
        std.write_string(file, "Hello!");
    }
    { // check
        file, err :: std.file_open(filepath);
        defer std.file_close(file);
        test_ok(err);
        str, err2 :: std.read_string(file);
        defer std.str_delete(str);
        test_ok(err2);
        test_eq(str, "Hello!Hello!");
    }
    std.file_remove(filepath);
}

fs_get_uid_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer std.str_delete(filepath);
    std.file_remove(filepath);
    file, err :: std.file_open(filepath, std.FileOpenMode.CREATE);
    defer std.file_close(file);
    test_ok(err);
    uid, err2 :: std.file_uid(file);
    test_ok(err2);
    test_true(uid > 0);
}

fs_get_uid_test2 :: fn () #test {
    filepath :: get_dummy_filepath();
    defer std.str_delete(filepath);
    std.file_remove(filepath);
    file, err :: std.file_open(filepath, std.FileOpenMode.CREATE);
    std.file_close(file);
    test_ok(err);
    uid, err2 :: std.file_uid(filepath);
    test_ok(err2);
    test_true(uid > 0);
}

fs_read_string_test :: fn () #test {
    file, err1 :: std.file_open(#file, std.FileOpenMode.READ);
    defer std.file_close(file);
    test_ok(err1);
    data, err2 := std.read_string(file);
    test_ok(err2);
    defer std.str_delete(data);
    test_neq(data, std.str_empty);
    data.len += 1;
    test_true(data[data.len-1] == '\0');
}

fs_read_string_test2 :: fn () #test {
    data, err := std.read_string(std.FILE_INVALID);
    test_is_error(err, ERR_INVALID_HANDLE);
}

fs_read_slice_test :: fn () #test {
    file, err1 :: std.file_open(#file, std.FileOpenMode.READ);
    test_ok(err1);
    defer std.file_close(file);
    data, err2 := std.read_slice(file);
    test_ok(err2);
    defer slice_terminate(&data);
    test_not_null(data.ptr);
    test_neq(data.len, 0);
}

fs_validate_filename_test :: fn () #test {
    if PLATFORM == Platform.WINDOWS {
        test_false(std.validate_filename("<"));
        test_false(std.validate_filename(">"));
        test_false(std.validate_filename(":")); 
        test_false(std.validate_filename("\""));     
        test_false(std.validate_filename("/"));
        test_false(std.validate_filename("\\"));
        test_false(std.validate_filename("|")); 
        test_false(std.validate_filename("?"));        
        test_false(std.validate_filename("*"));
        test_false(std.validate_filename("\t"));
        test_false(std.validate_filename("foo<"));
        test_true(std.validate_filename("foo_bar-File.txt"));
    } else {
        test_false(std.validate_filename("foo/"));
        test_true(std.validate_filename("foo_bar-File.txt"));
    }
}

fs_normalize_test1 :: fn () #test {
    cwd :: std.get_cwd();
    defer std.str_delete(cwd);
    parent: string;
    test_true(std.str_split_by_last(cwd, '/', &parent, null));
    filepath :: std.str_new("..");
    defer std.str_delete(filepath);
    status :: std.path_normalize(&filepath);
    test_ok(status);
    test_eq(filepath, parent);
}

fs_normalize_test2 :: fn () #test {
    cwd :: std.get_cwd();
    defer std.str_delete(cwd);
    filepath :: std.str_new(".");
    defer std.str_delete(filepath);
    status :: std.path_normalize(&filepath);
    test_ok(status);
    test_eq(filepath, cwd);
}    

fs_normalize_test3 :: fn () #test {
    file :: std.file_open("foo", std.FileOpenMode.CREATE);
    std.file_close(file);
    defer std.file_remove("foo");
    cwd :: std.get_cwd();
    defer std.str_delete(cwd);    
    filepath :: std.str_new("foo");
    std.str_concat(&cwd, "/", filepath);
    defer std.str_delete(filepath);
    status :: std.path_normalize(&filepath);
    test_ok(status);
    test_eq(filepath, cwd);
}

fs_remove_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer std.str_delete(filepath);
    
    std.file_remove(filepath);
    file, err :: std.file_open(filepath, std.FileOpenMode.CREATE);
    test_ok(err);
    std.file_close(file);
    err2 :: std.file_remove(filepath);
    test_ok(err2);
}

fs_size_test :: fn () #test {
    file :: std.file_open(#file);
    defer std.file_close(file);
    size, err :: std.file_size(file);
    test_ok(err);
    test_true(size > 0);
}

fs_read_test :: fn () #test {
    file :: std.file_open(#file);
    defer std.file_close(file);
    buf: [1042]u8 #noinit;
    bytes, err :: std.read(file, buf.ptr, buf.len);
    test_ok(err);
    test_eq(bytes, buf.len);
}

fs_read_buffer_test2 :: fn () #test {
    buf: [1042]u8 #noinit;
    bytes, err :: std.read(std.FILE_INVALID, buf.ptr, buf.len);
    test_is_error(err, ERR_INVALID_HANDLE);
    test_eq(bytes, 0);
}

fs_read_buffer_test3 :: fn () #test {
    file :: std.file_open(#file);
    defer std.file_close(file);
    bytes, err :: std.read(file, null, 0);
    test_is_error(err, ERR_INVALID_HANDLE);
    test_eq(bytes, 0);
}

fs_read_test4 :: fn () #test {
    file :: std.file_open(#file);
    defer std.file_close(file);
    buf: [1024]u8 #noinit;
    bytes, err :: std.read(file, buf.ptr, 100);
    test_ok(err);
    test_eq(bytes, 100);
}

fs_write_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer std.str_delete(filepath);
    std.file_remove(filepath);
    content :: "Hello I'm cool file content!";    
    
    { // write
        file :: std.file_open(filepath, make_flags(std.FileOpenMode.CREATE, std.FileOpenMode.WRITE));
        written, err :: std.write(file, content.ptr, content.len);
        test_ok(err);
        test_eq(written, content.len);
        std.file_close(file);
    }
    { // read
        file :: std.file_open(filepath);
        tmp, err :: std.read_string(file);
        test_ok(err);
        defer std.str_delete(tmp);
        test_eq(tmp, content);
        std.file_close(file);
    }
    std.file_remove(filepath);
}

fs_write_string_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer std.str_delete(filepath);
    std.file_remove(filepath);
    content :: "Hello I'm cool file content!";    
    
    { // write
        file :: std.file_open(filepath, make_flags(std.FileOpenMode.CREATE, std.FileOpenMode.WRITE));
        written, err :: std.write_string(file, content);
        test_ok(err);
        test_eq(written, content.len);
        std.file_close(file);
    }
    { // read
        file :: std.file_open(filepath);
        tmp, err :: std.read_string(file);
        test_ok(err);
        defer std.str_delete(tmp);
        test_eq(tmp, content);
        std.file_close(file);
    }
    std.file_remove(filepath);
}

fs_write_slice_test :: fn () #test {
    filepath :: get_dummy_filepath();
    defer std.str_delete(filepath);
    std.file_remove(filepath);
    content :: {:[5]u8: 'H', 'e', 'l', 'o', 'o' };
    
    { // write
        file :: std.file_open(filepath, make_flags(std.FileOpenMode.CREATE, std.FileOpenMode.WRITE));
        written, err :: std.write_slice(file, content);
        test_ok(err);
        test_eq(written, content.len);
        std.file_close(file);
    }
    { // read
        file :: std.file_open(filepath);
        tmp, err :: std.read_string(file);
        test_ok(err);
        defer std.str_delete(tmp);
        test_eq(tmp.len, content.len);
        std.file_close(file);
    }
    std.file_remove(filepath);
}

fs_copy_test :: fn () #test {
    filepath1 :: get_dummy_filepath(1);
    filepath2 :: get_dummy_filepath(2);
    defer std.str_delete(filepath1);
    defer std.str_delete(filepath2);
    std.file_remove(filepath1);
    std.file_remove(filepath2);
    
    { // new file
        file :: std.file_open(filepath1, std.FileOpenMode.CREATE);
        std.file_close(file);
    }
    { // copy
        err :: std.file_copy(filepath1, filepath2);
        test_ok(err);
        test_true(std.path_exist(filepath1));
        test_true(std.path_exist(filepath2));
    }
    { // copy 2
        err :: std.file_copy(filepath1, filepath2, false);
        test_not_ok(err);
        test_true(std.path_exist(filepath1));
        test_true(std.path_exist(filepath2));
    }

    std.file_remove(filepath1);
    std.file_remove(filepath2);
}

fs_list_dir_test1 :: fn () #test {
    dir :: std.get_cwd();
    defer std.str_delete(dir);
    list, err :: std.dir_scan(dir);
    defer std.info_list_delete(list);
    test_ok(err);
    test_true(list.len > 0);
    loop i := 0; i < list.len; i += 1 {
        test_neq(list[i].name, std.str_empty);
    }
}

fs_list_dir_test2 :: fn () #test {
    dir :: std.get_cwd();
    defer std.str_delete(dir);
    list, err :: std.dir_scan(dir, &fn (info: *std.Info) bool {
        return info.kind == std.InfoKind.DIRECTORY;
    });
    defer std.info_list_delete(list);
    test_ok(err);
    test_true(list.len > 0);
    loop i := 0; i < list.len; i += 1 {
        test_neq(list[i].name, std.str_empty);
        test_true(list[i].kind == std.InfoKind.DIRECTORY);
    }
}

fs_list_dir_test3 :: fn () #test {
    dir :: std.get_cwd();
    defer std.str_delete(dir);
    list, err :: std.dir_scan(dir, &fn (info: *std.Info) bool {
        return info.kind == std.InfoKind.FILE;
    });
    defer std.info_list_delete(list);
    test_ok(err);
    test_true(list.len > 0);
    loop i := 0; i < list.len; i += 1 {
        test_neq(list[i].name, std.str_empty);
        test_true(list[i].kind == std.InfoKind.FILE);
    }
}

fs_is_directory_test1 :: fn () #test {
    tmp :: std.get_tmp();
    defer std.str_delete(tmp);
    state, err :: std.is_directory(tmp);
    test_ok(err);
    test_true(state);
}

fs_is_directory_test2 :: fn () #test {
    state, err :: std.is_directory(#file);
    test_ok(err);
    test_false(state);
}

fs_dir_create_remove_test1 :: fn () #test {
    dir :: std.get_tmp();
    defer std.str_delete(dir);
    std.str_append(&dir, "/__DELETE_ME__");

    std.dir_remove_all(dir);
    state1 :: std.dir_create(dir);
    test_ok(state1);

    state2 :: std.dir_create(dir);
    test_not_ok(state1);

    state3 :: std.dir_remove(dir);
    test_ok(state3);
}

fs_dir_remove_all_test1 :: fn () #test {
    dir :: std.get_tmp();
    defer std.str_delete(dir);
    std.str_append(&dir, "/__DELETE_ME__");
    
    std.dir_remove_all(dir);
    {
        s :: std.dir_create(dir);
        test_ok(s);
    }
    
    {
        file :: std.str_new(dir);
        defer std.str_delete(file);
        std.str_append(&file, "/file.txt");
        f, e :: std.file_open(file, std.FileOpenMode.CREATE);
        test_ok(e);
        std.file_close(f);
    }
    
    state :: std.dir_remove_all(dir);
    test_ok(state);
    test_false(std.path_exist(dir));
}

fs_dir_create_all_test1 :: fn () #test {
    dir :: std.get_tmp();
    defer std.str_delete(dir);
    std.str_append(&dir, "/foo");
    std.dir_remove_all(dir);
    std.str_append(&dir, "/bar/bazz");
    err :: std.dir_create_all(dir);
    test_ok(err);
}

fs_path_split :: fn () #test {
    {
        d, f :: std.path_split("C:/Ahoj/Jak/Se/Vede/foo.txt.bak");
        test_eq(d, "C:/Ahoj/Jak/Se/Vede/");
        test_eq(f, "foo.txt.bak");
    }
    {
        d, f :: std.path_split("foo.txt.bak");
        test_eq(d, "");
        test_eq(f, "foo.txt.bak");
    }
    {
        d, f :: std.path_split(".txt.bak");
        test_eq(d, "");
        test_eq(f, ".txt.bak");
    }
    {
        d, f :: std.path_split("");
        test_eq(d, "");
        test_eq(f, "");
    }
    {
        d, f :: std.path_split(".");
        test_eq(d, "");
        test_eq(f, ".");
    }
    {
        d, f :: std.path_split(".txt");
        test_eq(d, "");
        test_eq(f, ".txt");
    }
    {
        d, f :: std.path_split("..txt");
        test_eq(d, "");
        test_eq(f, "..txt");
    }
    {
        d, f :: std.path_split("/home/usr/.hidden.file");
        test_eq(d, "/home/usr/");
        test_eq(f, ".hidden.file");
    }
    {
        d, f :: std.path_split("/");
        test_eq(d, "/");
        test_eq(f, "");
    }
    {
        d, f :: std.path_split("D:/");
        test_eq(d, "D:/");
        test_eq(f, "");
    }
    {
        d, f :: std.path_split("C:/foo/bar");
        test_eq(d, "C:/foo/");
        test_eq(f, "bar");
    }
    {
        d, f :: std.path_split("C:/foo/bar/");
        test_eq(d, "C:/foo/bar/");
        test_eq(f, "");
    }
}

fs_path_splitext :: fn () #test {
    {
        d, f :: std.path_splitext("C:/Ahoj/Jak/Se/Vede/foo.txt.bak");
        test_eq(d, "C:/Ahoj/Jak/Se/Vede/foo.txt");
        test_eq(f, ".bak");
    }
    {
        d, f :: std.path_splitext("");
        test_eq(d, "");
        test_eq(f, "");
    }
    {
        d, f :: std.path_splitext("foo.txt");
        test_eq(d, "foo");
        test_eq(f, ".txt");
    }
    {
        d, f :: std.path_splitext("foo");
        test_eq(d, "foo");
        test_eq(f, "");
    }
    {
        d, f :: std.path_splitext(".");
        test_eq(d, "");
        test_eq(f, ".");
    }
}