// =================================================================================================
// bl
//
// File:   memory.bl
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

//! # Memory
//! 
//! ```
//! #load "std/memory.bl"
//! ```
//! 
//! Toolset for manipulation with the system memory.
//!
//! ## Memory allocator
//!
//! Memory allocators are used across the entire program to manage allocated memory resources used 
//! in runtime. Since memory allocation can be an expensive operation in some cases, it's good to 
//! provide an explicit API, giving information enough to fix bugs, memory leaks and performance
//! issues.
//!
//! Memory allocator in BL world is just some context [Allocator](#allocator) structure used by an
//! allocator [handler function](#allocfn).
//!
//! Functions like [alloc](#alloc) and [free](#free) internally use allocator set in global executable
//! context `application_context` variable. Global context allocator is by default set to `default_allocator`
//! and can be changed as needed.

#import "std/pool"

/// Default memory allocation alignment.
DEFAULT_ALIGNMENT : usize : alignof(f64);

/// Specify allocator opratation.
AllocOp :: enum {
    /// Allocation of new memory block is required.
    ALLOCATE;
    /// Reallocate previously allocated memory.
    REALLOCATE;
    /// Free of previously allocated memory. This operation is optional (i.e. for pools).
    FREE;
}

/// Allocator handle function type.
AllocFn :: *fn (
    ctx: *Allocator,
    operation: AllocOp,
    size: usize,
    old_size: usize,
    ptr: *u8,
    alignment: usize,
    file: string_view,
    line: s32
) (mem: *u8, err: Error);

/// Default allocator context base.
Allocator :: struct {
    handler: AllocFn;
}

/// Allocates `size` of bytes on heap using default allocator. Use [free](#free) to free allocated memory
/// when it's no longer needed. Cause panic when allocation is not possible or `size` is  zero. This 
/// function use allocator set in `application_context.allocator`
alloc :: fn (size: usize, alignment := DEFAULT_ALIGNMENT, loc := #call_location) *u8 #inline {
    mem, err :: allocate_memory(application_context.allocator, size, alignment, loc);
    if !is_ok(err) { panic(err); }
    return mem;
};

// @Incomplete: document
realloc :: fn (ptr: *u8, old_size: usize, new_size: usize, alignment := DEFAULT_ALIGNMENT, loc := #call_location) *u8 #inline {
    mem, err :: reallocate_memory(application_context.allocator, ptr, old_size, new_size, alignment, loc);
    if !is_ok(err) { panic(err); }
    return mem;
};

/// Free memory using current context allocator.
///
/// **note**: The `ptr` can be `null`.
free :: fn (ptr: *u8, loc := #call_location) #inline {
    free_memory(application_context.allocator, ptr, loc);
};

/// Allocate memory directly using specified `allocator`.
allocate_memory :: fn (allocator: *Allocator, size: usize, alignment := DEFAULT_ALIGNMENT, loc := #call_location) (mem: *u8, err: Error) #inline {
    if !allocator { allocator = application_context.allocator; }
    assert(allocator.handler);
    assert(is_power_of_two(alignment));
    if size == 0 { return null, error("Attempt to allocate 0 bytes."); }
    mem, err :: allocator.handler(allocator, AllocOp.ALLOCATE, size, 0, null, alignment, loc.file, loc.line);
    if !is_ok(err) { return mem, err; }
    assert(is_aligned(mem, alignment));
    return mem, err;
}

// @Incomplete
// @Incomplete: Alignment must be the same as previous one during the reallocation!
reallocate_memory :: fn (allocator: *Allocator, ptr: *u8, old_size: usize, size: usize, alignment := DEFAULT_ALIGNMENT, loc := #call_location) (mem: *u8, err: Error) #inline {
    if !allocator { allocator = application_context.allocator; }
    assert(allocator.handler);
    assert(is_power_of_two(alignment));
    if size == 0 { return null, error("Attempt to allocate 0 bytes."); }
    if ptr {
        if old_size == 0 {
            return ptr, error("Original data ponter for reallocation is set, but original data size is zero!");
        }
        if old_size == size { return ptr, ok(); }
    }
    mem, err :: allocator.handler(allocator, AllocOp.REALLOCATE, size, old_size, ptr, alignment, loc.file, loc.line);
    if !is_ok(err) { return mem, err; }
    assert(is_aligned(mem, alignment));
    return mem, err;
}

/// Free memory previously allocated by specific `allocator`. The `ptr` can be null.
free_memory :: fn (allocator: *Allocator, ptr: *u8, loc := #call_location) #inline {
    if !allocator { allocator = application_context.allocator; }
    assert(allocator.handler);
    if !ptr { return; }
    allocator.handler(allocator, AllocOp.FREE, 0, 0, ptr, 0, loc.file, loc.line);
}

/// Copy memory of defined `size` from `src` to `dest`. Destination and source size must be at least
/// `size` bytes.
memcpy :: fn (dest: *u8, src: *u8, size: usize) {
    m :: size / sizeof(u64);
    d :: size - m * sizeof(u64);
    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        @tmp = @cast(*u64) src;
        dest = ptr_shift_bytes(dest, auto sizeof(u64));
        src = ptr_shift_bytes(src, auto sizeof(u64));
    }
    loop i : usize = 0; i < d; i += 1 {
        @dest = @src;

        dest = ptr_shift_bytes(dest, 1);
        src = ptr_shift_bytes(src, 1);
    }
};

/// Set memory to desired value and return `dest` pointer. Destination size must be at least `size` bytes.
memset :: fn (_dest: *u8, v: u8, size: usize) *u8 {
    dest := []u8.{auto size, _dest};
    loop i := 0; i < dest.len; i += 1 {
        dest[i] = v;
    }
    return _dest;
}

/// Zero out `dest` memory of `size` and return the `dest` pointer.
zeromem :: fn (dest: *u8, size: usize) *u8 {
    ptr :: dest;
    m :: size / sizeof(u64);
    d :: size - m * sizeof(u64);
    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        @tmp = 0;
        dest = auto (cast(u64) dest + sizeof(u64));
    }
    loop i : usize = 0; i < d; i += 1 {
        @dest = 0;
        dest = auto (cast(u64) dest + 1);
    }
    return ptr;
}

init_default :: fn (dest: *?T) *T #inline {
    return auto memset(auto dest, 0, sizeof(T));
}

// This is actually slower on Windows.
// memset :: fn (dest: *u8, v: u8, size: usize) *u8 #intrinsic "memset.p0i8.i64";

/// Swaps content of memory at address `first` and `second`.
swap :: fn (first: *?T, second: *T) #inline {
    tmp :: @first;
    @first = @second;
    @second = tmp;
}

/// Checks whether passed pointer `ptr` is properly aligned by `alignment`.
is_aligned :: fn (ptr: *?T, alignment: usize) bool #inline {
    return cast(usize)ptr % alignment == 0;
}

/// Align pointer `p` to `alignment` and return adjusted pointer and number of bytes needed for 
/// adjustment.
///
/// **warning**: Cause panic when alignment is not power of two.
align_ptr_up :: fn (p: *u8, alignment: usize) (p: *u8, adjustment: usize)
{
    if is_aligned(p, alignment) { return p, 0; }
    mask : usize : alignment - 1;
    assert((alignment & mask) == 0); // pwr of 2
    i_unaligned :: cast(usize)p;
    misalignment :: i_unaligned & mask;
    adj :: alignment - misalignment;
    p  = cast(*u8)(i_unaligned + adj);
    return p, adj;
}

// @Incomplete: Document!
/// Allocate heap memory for `n` elements in `_v` slice. Allocated block is set to zero default value. 
/// Allocated memory must be released by :ref:`slice_terminate` call.
///
/// Zero initialization of allocated memory block can be expensive in case of large allocation.
///
/// ### Example
/// 
/// ```
/// main :: fn () s32 {
///     // Allocate slice of 10 numbers
///     sl: []s32;
///     slice_init(&sl, 10);
/// 
///     loop i := 0; i < sl.len; i += 1 {
///         sl[i] = i;
///     }
/// 
///     // release memory allocated by init
///     slice_terminate(&sl);
///     return 0;
/// }
/// ```
slice_init :: fn (slice: *[]?T, n: s64, zero_initialized := true, allocator: *Allocator = null, loc := #call_location) {
    if n < 0 { panic("Attempt to allocate % elements in slice!", n); }
    if n == 0  {
        slice.ptr = null;
        slice.len = 0;
        return;
    }
    elem_size :: sizeof(T);
    bytes :: elem_size * auto n;
    mem, err :: allocate_memory(allocator, bytes, alignof(T), loc);
    if !is_ok(err) { panic(err); }
    slice.ptr = auto mem;
    slice.len = n;
    if zero_initialized { zeromem(auto slice.ptr, bytes); }
}

/// Release slice memory allocated by [slice_init](#slice_init) call. 
slice_terminate :: fn (slice: *[]?T, allocator: *Allocator = null, loc := #call_location) {
    if slice.ptr {
        free_memory(allocator, auto slice.ptr, loc);
        slice.ptr = null;
    }
    slice.len = 0;
}

/// Create slice subset defined as range `<start-index, end-index)`. Notice that `end` index
/// is excluded from range, so ``slice_range(other, 0, other.len)`` is valid and returns
/// new slice pointing to the same data as `other` slice, and with same size.
/// 
/// Indexing rules:
///
/// ```
/// start >= 0
/// start < slice.len
/// end >= 0
/// end <= slice.len
/// ```
///
/// **warning**: Function cause panic in case combination of `start` and `end` is out of `slice` range.
slice_range :: fn (slice: []?T, start: s64, end: s64 = -1) []T #inline {
    if end < 0 { end = slice.len; }
    len :: end - start;
    if len < 0 || len > slice.len || start < 0 || start >= slice.len {
         panic("Invalid slice range, wanted <%, %) slice size is %.", start, end, slice.len);
    }
    return []T.{len, auto ptr_shift_bytes(slice.ptr, start * cast(s64) sizeof(T))};
}

/// Reduce allocated memory, but keeps biggest allocated chunk for later use.
///
/// **warning**:  All resources previously allocated by this allocator became invalid after reset.
///
/// **hint**: Call this method i.e. in every event loop (update) iteration.
temporary_reset :: fn () #inline {
    std.pool_reset(&temporary_pool);
}

/// Release all memory allocated by temporary allocator, this method is supposed to be called
/// at exit of a program or thread.
///
/// **warning**:  All resources previously allocated by this allocator became invalid after release.
///
/// **hint**: Call this method before main returns.
temporary_release :: fn () #inline {
    std.pool_release(&temporary_pool);
}

/// Default memory allocator using libc malloc internally.
default_allocator :: Allocator.{ handler = &default_allocator_handler };

/// Default temporary allocator instance using pool internally.
default_temporary_allocator :: Allocator.{ handler = &temporary_allocator_handler };

#private

default_allocator_handler :: fn (_: *Allocator, operation: AllocOp, size: usize, _: usize, ptr: *u8, alignment: usize, _: string_view, _: s32) (mem: *u8, err: Error) {
    // @Cleanup: We do properly aligned allocations only on Windows, in case there is not implementation
    // provided on other platforms, we should implement it.
    alignment; // May be unused...
    using AllocOp;
    switch operation {
        ALLOCATE {
            mem: *u8;
#if PLATFORM == Platform.WINDOWS {
            mem = C.aligned_malloc(size, alignment);
} else {
            mem = C.malloc(size);
}
            if !mem { return null, error("Bad allocation."); }
            return mem, ok();
        }
        REALLOCATE {
            mem: *u8;
#if PLATFORM == Platform.WINDOWS {
            mem = C.aligned_realloc(ptr, size, alignment);
} else {
            mem = C.realloc(ptr, size);
}
            if !mem { return null, error("Bad reallocation."); }
            return mem, ok();
        }
        FREE {
#if PLATFORM == Platform.WINDOWS {
            C.aligned_free(ptr);
} else {
            C.free(ptr);
}
        }

        default { panic(); }
    }
    return null, ok();
}

temporary_pool := std.pool_default #thread_local;

temporary_allocator_handler :: fn (_: *Allocator, operation: AllocOp, size: usize, old_size: usize, ptr: *u8, alignment: usize, file: string_view, line: s32) (mem: *u8, err: Error) {
    return temporary_pool.handler(&temporary_pool, operation, size, old_size, ptr, alignment, file, line);
}
