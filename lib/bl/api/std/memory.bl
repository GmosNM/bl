// =================================================================================================
// bl
//
// File:   memory.bl
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

//! ======
//! Memory
//! ======
//! 
//! ::
//! 
//!     #load "std/memory.bl"
//! 
//! Toolset for manipulation with system memory.

/// Allocates count of bytes on heap using default allocator.
/// Use :ref:`free` to free allocated memory when it's no longer
/// needed. Cause panic when allocation is not possible. This
/// function use allocator set in `_context.alloc_fn`
alloc :: fn (size: usize, loc := #call_location) *u8 {
    mem :: _context.alloc_fn(AllocOp.Allocate, size, null, loc.file, loc.line); 
    if !mem { panic("Bad alloc"); }
    return mem;
};

/// Allocates count of bytes on heap using default allocator and
/// return pointer to begin of this allocated block. Resulting
/// block is set to 0 value.
/// Use :ref:`free` to free allocated memory when it's no longer
/// needed.
calloc :: fn (num: usize, size: usize, loc := #call_location) *u8 {
    mem :: _context.alloc_fn(AllocOp.Allocate, size * num, null, loc.file, loc.line); 
    return memset(mem, 0, size * num);
};

/// Free memory alocated on heap. This function use default deallocator 
/// `_context.free_fn`.
free :: fn (ptr: *u8, loc := #call_location) {
    _context.alloc_fn(AllocOp.Free, 0, ptr, loc.file, loc.line); 
};

/// Copy memory of defined `size` from `src` to `dest`. Destination
/// and source size must be at least `size` bytes.
memcpy :: fn (dest: *u8, src: *u8, size: usize) {
    m := size / sizeof(u64);
    d := size - m * sizeof(u64);

    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        ^tmp = ^cast(*u64) src;

        dest = ptr_shift_bytes(dest, auto sizeof(u64));
        src = ptr_shift_bytes(src, auto sizeof(u64));
    }
    
    loop i : usize = 0; i < d; i += 1 {
        ^dest = ^src;

        dest = ptr_shift_bytes(dest, 1);
        src = ptr_shift_bytes(src, 1);
    }
};

/// Set memory to desired value. Destination size must be at 
/// least `size` bytes.
memset :: fn (_dest: *u8, v: u8, size: usize) *u8 {
    dest := {:[]u8: auto size, _dest};
    loop i := 0; i < dest.len; i += 1 {
        dest[i] = v;
    }

    return dest.ptr;
}

/// Allocate heap memory for `n` elements in `_v` slice. Allocated block is set to
/// zero default value. Allocated memory must be released by :ref:`slice_terminate` call.
/// 
/// This way of memory allocation cause some overhead compared to plain `alloc` due to 
/// conversion to `Any` and more 'generic' behaviour, also setting to 0 have some 
/// runtime cost. Consider use of :ref:`alloc` instead in performance-critical cases.
/// 
/// Example
/// -------
/// .. literalinclude:: /examples/docs/008.bl
///    :language: bl
slice_init :: fn (_v: Any, n: s64, loc := #call_location) #compiler {
    if n < 0 { panic("Attempt to allocate 0 values by make!"); }
    T :: cast(*TypeInfoStruct) _v.type_info;
    T_ptr :: cast(*TypeInfoPtr) (cast(*TypeInfoStruct) T).members[1].base_type;

    dest := cast(*[]u8) _v.data;
    if n == 0  {
        dest.ptr = null;
        dest.len = 0;
        return;
    }

    elem_size :: T_ptr.pointee_type.size_bytes;
    bytes :: elem_size * auto n;
    dest.ptr = alloc(bytes, loc);
    dest.len = n;

    memset(dest.ptr, 0, bytes); 
}

/// Release slice memory allocated by :ref:`slice_init` call. 
slice_terminate :: fn (_v: Any, loc := #call_location) #compiler {
    tmp := cast(*[]u8) _v.data;
    if tmp.ptr {
        free (tmp.ptr, loc);
        tmp.ptr = null;
    }
    tmp.len = 0;
}

AllocFn :: *fn (operation: AllocOp, size: usize, ptr : *u8 = null, file := String.empty, line := 0) *u8;

/// Specify allocator opratation.
AllocOp :: enum {
    /// Allocation of new memory block is required. 
    Allocate;
    /// Free of previously allocated memory is required. 
    Free;
    /// Release of all allocated memory is required.
    Release;
}

_default_allocator :: fn (operation: AllocOp, size: usize, ptr : *u8 = null, _:= String.empty, _:= 0) *u8 {
    switch operation {
        AllocOp.Allocate {
            return c_malloc(size);
        }
        AllocOp.Free {
            c_free(ptr);
        }
        AllocOp.Release;
        default { panic(); }
    }
    return null;
}
