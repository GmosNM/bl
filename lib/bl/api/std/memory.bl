//************************************************************************************************
// bl
//
// File:   memory.bl
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

/*!
# alloc
## Declaration
```c
alloc :: fn (size: usize) *u8
```

## Description
  Allocates count of bytes on heap using default allocator.
Use `free` to free allocated memory when it's no longer
needed. Cause panic when allocation is not possible. This
function use allocator set in `_context.alloc_fn`

## Arguments
  * `size`
    Bytes to be allocated. 

## Result
  Pointer to begin of the new allocated block of memory.
*/
alloc :: fn (size: usize, loc := #call_location) *u8 {
    mem :: _context.alloc_fn(AllocOp.Allocate, size, null, loc.file, loc.line); 
    if !mem { panic("Bad alloc"); }
    return mem;
};

/*!
# calloc
## Declaration
```c
calloc :: fn (num: usize, size: usize) *u8
```

## Description
  Allocates count of bytes on heap using default allocator and
  return pointer to begin of this allocated block. Resulting
  block is set to 0 value.
  Use `free` to free allocated memory when it's no longer
  needed.

## Arguments
  * `num`
    Count of items to be allocated. 
  * `size`
    Item size in bytes. 

## Result
  Pointer to begin of the new allocated block of memory.
*/
calloc :: fn (num: usize, size: usize, loc := #call_location) *u8 {
    mem :: _context.alloc_fn(AllocOp.Allocate, size * num, null, loc.file, loc.line); 
    return memset(mem, 0, size * num);
};

/*!
# free
## Declaration
```c
free :: fn (ptr: *u8)
```

## Description
  Free memory alocated on heap. This function use default
  deallocator `_context.free_fn`.

## Arguments
  * `ptr`
    Memory to be deallocated. 
*/
free :: fn (ptr: *u8, loc := #call_location) {
    _context.alloc_fn(AllocOp.Free, 0, ptr, loc.file, loc.line); 
};

/*!
# memcpy
## Declaration
```c
memcpy :: fn (dest: *u8, src: *u8, size: usize)
```

## Description
  Copy memory of defined size from source to destination. Destination
and source size must be at least `size` bytes.

## Arguments
  * `dest`
    Pointer to destination memory. 
  * `src`
    Pointer to source memory. 
  * `size`
    Count of bytes to be copied. 
 */
memcpy :: fn (dest: *u8, src: *u8, size: usize) {
    m := size / sizeof(u64);
    d := size - m * sizeof(u64);

    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        ^tmp = ^cast(*u64) src;

        dest = ptr_shift_bytes(dest, auto sizeof(u64));
        src = ptr_shift_bytes(src, auto sizeof(u64));
    }
    
    loop i : usize = 0; i < d; i += 1 {
        tmp := dest;
        ^dest = ^src;

        dest = ptr_shift_bytes(dest, 1);
        src = ptr_shift_bytes(src, 1);
    }
};

/*!
# memset
## Declaration
```c
memset :: fn (_dest: *u8, v: u8, size: usize) *u8
```

## Description
  Set memory to desired value. Destination size must be at 
least `size` bytes.

## Arguments
  * `_dest`
    Pointer to target memory block. 
  * `v`
    Desired value. 
  * `size`
    Count of bytes to be set. 

## Result
  Pointer to destination memory. 
*/
memset :: fn (_dest: *u8, v: u8, size: usize) *u8 {
    dest := {:[]u8: auto size, _dest};
    loop i := 0; i < dest.len; i += 1 {
        dest[i] = v;
    }

    return dest.ptr;
}

/*!
# slice_init
## Declaration
```c
slice_init :: fn (_v: Any, n: s64)
```

## Description
  Allocate heap memory for `n` elements in `_v` slice. Allocated block is set to
zero default value. Allocated memory must be released by `slice_terminate` call.

  This way of memory allocation cause some overhead compared to plain `alloc` due to 
conversion to `Any` and more 'generic' behaviour, also setting to 0 have some 
runtime cost. Consider use of `alloc` instead in performance-critical cases.

## Arguments
  * `_v`
    Slice to be initialized. 
  * `n`
    Number of elements. 

## Example
```c
main :: fn () s32 {
    // Allocate slice of 10 numbers
    sl: []s32;
    slice_init(sl, 10);

    loop i := 0; i < sl.len; i += 1 {
        sl[i] = i;
    }

    // release memory allocated by init
    slice_terminate(sl);

    return 0;
}
```
*/
slice_init :: fn (_v: Any, n: s64) #compiler {
    if n < 0 { panic("Attempt to allocate 0 values by make!"); }

    T :: cast(*TypeInfoStruct) _v.type_info;
    T_ptr :: cast(*TypeInfoPtr) (cast(*TypeInfoStruct) T).members[1].base_type;

    elem_size :: T_ptr.pointee_type.size_bytes;
    dest := cast(*[]u8) _v.data;
    bytes :: elem_size * auto n;
    dest.ptr = alloc(bytes);
    dest.len = n;

    memset(dest.ptr, 0, bytes); 
}

/*!
# slice_terminate
## Declaration
```c
slice_terminate :: fn (_v: Any)
```

## Description
  Release slice memory allocated by `slice_init` call. For more information check out
`slice_init` documentation page.

## Arguments
  * `_v`
    Allocated slice. 
*/
slice_terminate :: fn (_v: Any) #compiler {
    tmp := cast(*[]u8) _v.data;
    free (tmp.ptr);
    tmp.ptr = null;
    tmp.len = 0;
}

_AllocFn :: *fn (operation: AllocOp, size: usize, ptr : *u8 = null, file := string_empty, line := 0) *u8;

AllocOp :: enum {
    Allocate;
    Free;
    Release;
}

_mem_allocator_default :: fn (operation: AllocOp, size: usize, ptr : *u8 = null, file := string_empty, line := 0) *u8 {
    c_malloc :: fn (size: c_size_t) c_void_ptr #extern "malloc";
    c_free :: fn (ptr: c_void_ptr) #extern "free";
    switch operation {
        AllocOp.Allocate {
            return c_malloc(size);
        }
        AllocOp.Free {
            c_free(ptr);
        }
        AllocOp.Release;
        default { panic(); }
    }
    return null;
}
