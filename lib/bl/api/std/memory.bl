// =================================================================================================
// bl
//
// File:   memory.bl
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

//! # Memory
//! 
//! ```
//! #load "std/memory.bl"
//! ```
//! 
//! Toolset for manipulation with the system memory.
//!
//! ## Memory allocator
//!
//! Memory allocators are used across the entire program to manage allocated memory resources used 
//! in runtime. Since memory allocation can be an expensive operation in some cases, it's good to 
//! provide an explicit API, giving information enough to fix bugs, memory leaks and performance
//! issues.
//!
//! Memory allocator in BL world is just some context [Allocator](#allocator) structure used by an
//! allocator [handler function](#allocfn).
//!
//! Functions like [alloc](#alloc) and [free](#free) internally use allocator set in global executable
//! context `application_context` variable. Global context allocator is by default set to `default_allocator`
//! and can be changed as needed.

#import "std/pool"

/// Default memory allocation alignment.
DEFAULT_ALIGNMENT : usize : alignof(f64);

/// Default memory allocator using libc malloc internally.
default_allocator :: Allocator.{ handler = &default_allocator_handler };

/// Default temporary allocator instance using pool internally.
///
/// The temporary allocator (used i.e. by [tprint](print.md#tprint) function) is useful in cases we
/// don't need to keep allocated memory for a long period of time. In general in such a case we allocate,
/// use and free the memory.
///
/// Temporary allocated memory does not need to be explicitly freed (in fact temporary allocator does not
/// free individual allocations at all even if `free` is called). A large memory block is preallocated instead
/// and every allocation lands into this block. Later (at some safe point of execution) when
/// [temporary_reset](#temporary_reset) is called, all previous allocations done via temporary allocator became
/// invalid (marked as a free space in preallocated block) and can be reused lated.
///
/// When temporary allocator is not needed anymore, [temporary_release](temporary_release) shall be called to
/// free all internally preallocated blocks.
///
/// ### Example
///
/// ```
/// main :: fn () s32 {
///     // Release allocated memory at the end of the scope.
///     defer temporary_release();
///
///     loop i := 0; i < 1000; i += 1 {
///          // Reset the allocator here (all previous alocation are invalid since now).
///         defer temporary_reset();
///
///         // Allocate memory using temporary allocator.
///         int_ptr := cast(*s32) alloc(sizeof(s32), alignof(s32), &default_temporary_allocator);
///
///         // Do something here with allocated memory.
///         @int_ptr = i;
///
///         // There is no need to free allocated memory here.
///     }
///     return 0;
/// }
/// ```
///
/// !!! note
///     The temporary allocator internally use [pool allocator](pool.md#pool_allocator), see the documentation for
///     more details.
///
/// !!! important
///     Temporary allocator instance is thread-local, [temporary_release](#temporary_release) should be called
///     at-exit of all threads if it's used.
default_temporary_allocator :: Allocator.{ handler = &temporary_allocator_handler };

/// Specify allocator opratation.
AllocOp :: enum {
    /// Allocation of new memory block is required.
    ALLOCATE;
    /// Reallocate previously allocated memory.
    REALLOCATE;
    /// Free of previously allocated memory. This operation is optional (i.e. for pools).
    FREE;
}

/// Allocator handle function type.
AllocFn :: *fn (
    ctx: *Allocator,
    operation: AllocOp,
    old_ptr: *u8,
    old_size: usize,
    new_size: usize,
    alignment: usize,
    file: string_view,
    line: s32
) (mem: *u8, err: Error);

/// Default allocator context base. This structure can be used as a base structure for any allocator
/// implementation.
Allocator :: struct {
    /// Pointer to the main allocator handler function.
    handler: AllocFn;
}

/// Allocate memory using specified `allocator`. In case the `allocator` is null, default application context
/// allocator is used.
/// Returns pointer to the newly allocated memory or fails with `Error` in case the allocation is not possible.
/// The allocation `size` must be at least 1 byte and the optional `alignment` must be value of power of two.
alloc :: fn (size: usize, alignment := DEFAULT_ALIGNMENT, allocator: *Allocator = null, loc := #call_location) (mem: *u8, err: Error) #inline {
    if !allocator { allocator = application_context.allocator; }
    assert(allocator.handler);
    assert(is_power_of_two(alignment));
    if size == 0 { return null, error("Attempt to allocate 0 bytes."); }
    mem, err :: allocator.handler(allocator, AllocOp.ALLOCATE, null /* old_ptr */, 0 /* old_size */, size, alignment, loc.file, loc.line);
    if err { return mem, err; }
    assert(is_aligned(mem, alignment));
    return mem, err;
}

/// Reallocate previously allocated memory using the `allocator`. In case the `allocator` is null, default application context
/// allocator is used.
///
/// This function tries to resize previously allocated block if possible, otherwise new allocation is done and the
/// old data (of `old_size`) are copied to the newly allocated memory. No allocation and copying is done in case the
/// `old_size` is the same as `size`.
///
/// Previously allocated block is freed when resize is not possible.
///
/// The allocation `alignment` can be specified but must be the same as previous one in case we try to reallocate.
///
/// !!! note
///     When called with null `old_ptr`, this function behaves the same as [alloc](#alloc) and the `old_size` is ignored.
///
/// !!! warning
///     The exact behaviour depends on the allocator used, in some cases reallocation is not implemented and new allocation
///     is done everytime.
realloc :: fn (old_ptr: *u8, old_size: usize, size: usize, alignment := DEFAULT_ALIGNMENT, allocator: *Allocator = null, loc := #call_location) (mem: *u8, err: Error) #inline {
    if !allocator { allocator = application_context.allocator; }
    assert(allocator.handler);
    assert(is_power_of_two(alignment));
    if size == 0 { return null, error("Attempt to allocate 0 bytes."); }
    if old_ptr {
        if old_size == 0 {
            return old_ptr, error("Original data ponter for reallocation is set, but original data size is zero!");
        }
        if old_size == size { return old_ptr, OK; }
    }
    mem, err :: allocator.handler(allocator, AllocOp.REALLOCATE, old_ptr, old_size, size, alignment, loc.file, loc.line);
    if err { return mem, err; }
    assert(is_aligned(mem, alignment));
    return mem, err;
}

/// Free memory previously allocated by specific `allocator`. In case the `allocator` is null, the defautl application context
/// allocator is used. The `ptr` can be null.
free :: fn (ptr: *u8, allocator: *Allocator = null, loc := #call_location) #inline {
    if !allocator { allocator = application_context.allocator; }
    assert(allocator.handler);
    if !ptr { return; }
    allocator.handler(allocator, AllocOp.FREE, ptr, 0 /* old_size */, 0 /* new_size */, 0 /* alignment */, loc.file, loc.line);
}

/// Copy memory of defined `size` from `src` to `dest`. Destination and source size must be at least
/// `size` bytes.
memcpy :: fn (dest: *u8, src: *u8, size: usize) {
    m :: size / sizeof(u64);
    d :: size - m * sizeof(u64);
    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        @tmp = @cast(*u64) src;
        dest = ptr_shift_bytes(dest, auto sizeof(u64));
        src = ptr_shift_bytes(src, auto sizeof(u64));
    }
    loop i : usize = 0; i < d; i += 1 {
        @dest = @src;

        dest = ptr_shift_bytes(dest, 1);
        src = ptr_shift_bytes(src, 1);
    }
};

/// Set memory to desired value and return `dest` pointer. Destination size must be at least `size` bytes.
memset :: fn (_dest: *u8, v: u8, size: usize) *u8 {
    dest := []u8.{auto size, _dest};
    loop i := 0; i < dest.len; i += 1 {
        dest[i] = v;
    }
    return _dest;
}

// This is actually slower on Windows.
// memset :: fn (dest: *u8, v: u8, size: usize) *u8 #intrinsic "memset.p0i8.i64";

/// Zero out `dest` memory of `size` and return the `dest` pointer.
zeromem :: fn (dest: *u8, size: usize) *u8 {
    ptr :: dest;
    m :: size / sizeof(u64);
    d :: size - m * sizeof(u64);
    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        @tmp = 0;
        dest = auto (cast(u64) dest + sizeof(u64));
    }
    loop i : usize = 0; i < d; i += 1 {
        @dest = 0;
        dest = auto (cast(u64) dest + 1);
    }
    return ptr;
}

/// Swaps content of memory at address `first` and `second`.
swap :: fn (first: *?T, second: *T) #inline {
    tmp :: @first;
    @first = @second;
    @second = tmp;
}

/// Checks whether passed pointer `ptr` is properly aligned by `alignment`.
is_aligned :: fn (ptr: *?T, alignment: usize) bool #inline {
    return cast(usize)ptr % alignment == 0;
}

/// Align pointer `p` to `alignment` and return adjusted pointer and number of bytes needed for 
/// adjustment.
///
/// !!! warning
///     Cause panic when alignment is not power of two.
align_ptr_up :: fn (p: *u8, alignment: usize) (p: *u8, adjustment: usize)
{
    if is_aligned(p, alignment) { return p, 0; }
    mask : usize : alignment - 1;
    assert((alignment & mask) == 0); // pwr of 2
    i_unaligned :: cast(usize)p;
    misalignment :: i_unaligned & mask;
    adj :: alignment - misalignment;
    p  = cast(*u8)(i_unaligned + adj);
    return p, adj;
}

/// Allocate heap memory for `n` elements in the `slice`. Newly allocated slice can be zero initialized
/// by setting `zero_init` to `true`. Custom allocator can be provided as `allocator`, the application context
/// allocator is used in case the `allocator` is null.
///
/// Allocated memory must be released by [slice_terminate](#slice_terminate) call.
///
/// ### Example
/// 
/// ```
/// main :: fn () s32 {
///     // Allocate slice of 10 numbers
///     sl: []s32;
///     slice_init(&sl, 10);
/// 
///     loop i := 0; i < sl.len; i += 1 {
///         sl[i] = i;
///     }
/// 
///     // release memory allocated by init
///     slice_terminate(&sl);
///     return 0;
/// }
/// ```
///
/// !!! note
///     Zero initialization of allocated memory block can be expensive in case of large number of elements.
slice_init :: fn (slice: *[]?T, n: s64, zero_initialized := true, allocator: *Allocator = null, loc := #call_location) {
    if n < 0 { panic("Attempt to allocate % elements in slice!", n); }
    if n == 0  {
        slice.ptr = null;
        slice.len = 0;
        return;
    }
    elem_size :: sizeof(T);
    bytes :: elem_size * auto n;
    mem, err :: alloc(bytes, alignof(T), allocator, loc);
    if err { panic(err); }
    slice.ptr = auto mem;
    slice.len = n;
    if zero_initialized { zeromem(auto slice.ptr, bytes); }
}

/// Release slice memory allocated by [slice_init](#slice_init) call.
/// !!! warning
///     The `allocator` must match the allocator used in ``slice_init``.
slice_terminate :: fn (slice: *[]?T, allocator: *Allocator = null, loc := #call_location) {
    if slice.ptr {
        free(auto slice.ptr, allocator, loc);
        slice.ptr = null;
    }
    slice.len = 0;
}

/// Create slice subset defined as range `<start-index, end-index)`. Notice that `end` index
/// is excluded from range, so ``slice_range(other, 0, other.len)`` is valid and returns
/// new slice pointing to the same data as `other` slice, and with same size.
/// 
/// Indexing rules:
///
/// ```
/// start >= 0
/// start < slice.len
/// end >= 0
/// end <= slice.len
/// ```
///
/// !!! warning
///     Function cause panic in case combination of `start` and `end` is out of `slice` range.
slice_range :: fn (slice: []?T, start: s64, end: s64 = -1) []T #inline {
    if end < 0 { end = slice.len; }
    len :: end - start;
    if len < 0 || len > slice.len || start < 0 || start >= slice.len {
         panic("Invalid slice range, wanted <%, %) slice size is %.", start, end, slice.len);
    }
    return []T.{len, auto ptr_shift_bytes(slice.ptr, start * cast(s64) sizeof(T))};
}

/// Reduce allocated memory in temporary allocator storage, but keeps biggest allocated chunk
/// for the later use.
///
/// !!! warning
///     All resources previously allocated by this allocator became invalid after reset.
///
/// !!! note
///     Call this method i.e. in every event loop (update) iteration.
temporary_reset :: fn () #inline {
    std.pool_reset(&temporary_pool);
}

/// Release all memory allocated by temporary allocator, this method is supposed to be called
/// at exit of a program or thread.
///
/// !!! warning
///     All resources previously allocated by this allocator became invalid after release.
///
/// !!! note
///     Call this method before main returns.
temporary_release :: fn () #inline {
    std.pool_release(&temporary_pool);
}

#private
default_allocator_handler :: fn (
    _: *Allocator,
    operation: AllocOp,
    old_ptr: *u8,
    _: usize, // old_size
    new_size: usize,
    alignment: usize,
    _: string_view,
    _: s32)
(mem: *u8, err: Error) {
    // @Cleanup: We do properly aligned allocations only on Windows, in case there is not implementation
    // provided on other platforms, we should implement it.
    alignment; // May be unused...
    using AllocOp;
    switch operation {
        ALLOCATE {
            mem: *u8;
#if PLATFORM == Platform.WINDOWS {
            mem = C.aligned_malloc(new_size, alignment);
} else {
            mem = C.malloc(new_size);
}
            if !mem { return null, error("Bad allocation."); }
            return mem, OK;
        }
        REALLOCATE {
            mem: *u8;
#if PLATFORM == Platform.WINDOWS {
            mem = C.aligned_realloc(old_ptr, new_size, alignment);
} else {
            mem = C.realloc(old_ptr, new_size);
}
            if !mem { return null, error("Bad reallocation."); }
            return mem, OK;
        }
        FREE {
#if PLATFORM == Platform.WINDOWS {
            C.aligned_free(old_ptr);
} else {
            C.free(old_ptr);
}
        }

        default { panic(); }
    }
    return null, OK;
}

temporary_pool := std.pool_default #thread_local;

temporary_allocator_handler :: fn (
    _: *Allocator,
    operation: AllocOp,
    old_ptr: *u8,
    old_size: usize,
    new_size: usize,
    alignment: usize,
    file: string_view,
    line: s32)
(mem: *u8, err: Error) #inline {
    return temporary_pool.handler(&temporary_pool, operation, old_ptr, old_size, new_size, alignment, file, line);
}
