// =================================================================================================
// bl
//
// File:   memory.bl
// Author: Martin Dorazil
// Date:   13/8/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

//! # Memory
//! 
//! ```
//! #load "std/memory.bl"
//! ```
//! 
//! Toolset for manipulation with system memory.
//!
//! Memory allocator
//! ----------------
//! 
//! Memory allocators are used across the entire program to manage allocated memory resources used 
//! in runtime. Since memory allocation can be an expensive operation in some cases, it's good to 
//! provide an explicit API, giving information enough to fix  bugs, memory leaks and performance 
//! issues.
//!
//! Memory allocator in BL world is just some context :ref:`Allocator` used by an allocator function, 
//! and allocator function itself [AllocFn](#allocfn). The allocator context can hold some data needed by 
//! allocator function and the allocator function is later used to make memory allocations and 
//! deallocations.
//!
//! Functions like [alloc](#alloc) and [free](#free) internally use allocator set in global executable
//! context `_context` variable. Global context allocator is by default set to `default_allocator`
//! and can be changed as needed. Main goal of internal use of  the allocator set in the global 
//! context (used across all modules) is to have full control over what's going on and also give
//! some advanced options to programmer (i.e. create his/her own allocator to have truly full 
//! control over memory management of the program).

/// Allocates `size` of bytes on heap using default allocator. Use `free` to free allocated memory 
/// when it's no longer needed. Cause panic when allocation is not possible or `size` is  zero. This 
/// function use allocator set in `_context.allocator`
alloc :: fn (size: usize, loc := #call_location) *u8 {
    if size == 0 { panic("Attempt to allocate 0 bytes."); }
    mem :: allocate_memory(_context.allocator, size, loc); 
    if !mem { panic("Bad alloc"); }
    return mem;
};

/// Same as `alloc` but allocated memory block is set to zero.
calloc :: fn (num: usize, size: usize, loc := #call_location) *u8 {
    if size == 0 { panic("Attempt to allocate 0 bytes."); }
    mem :: allocate_memory(_context.allocator, size * num, loc); 
    return zeromem(mem, size * num);
};

/// Free memory allocated on heap. This function use allocator set in `_context.allocator` to free 
/// allocated data.
///
/// **warning**: Memory block must be freed by same allocator as used for allocation.
///
/// **note**: Does nothing when passed `ptr` is `null`.
free :: fn (ptr: *u8, loc := #call_location) {
    if !ptr { return; }
    free_memory(_context.allocator, ptr, loc);
};

/// Copy memory of defined `size` from `src` to `dest`. Destination and source size must be at least 
/// `size` bytes.
memcpy :: fn (dest: *u8, src: *u8, size: usize) {
    m :: size / sizeof(u64);
    d :: size - m * sizeof(u64);
    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        @tmp = @cast(*u64) src;
        dest = ptr_shift_bytes(dest, auto sizeof(u64));
        src = ptr_shift_bytes(src, auto sizeof(u64));
    }
    loop i : usize = 0; i < d; i += 1 {
        @dest = @src;

        dest = ptr_shift_bytes(dest, 1);
        src = ptr_shift_bytes(src, 1);
    }
};

/// Set memory to desired value and return `dest` pointer. Destination size must be at least `size` bytes.
memset :: fn (_dest: *u8, v: u8, size: usize) *u8 {
    dest := {:[]u8: auto size, _dest};
    loop i := 0; i < dest.len; i += 1 {
        dest[i] = v;
    }
    return _dest;
}

/// Zero out `dest` memory of `size` and return the `dest` pointer.
zeromem :: fn (dest: *u8, size: usize) *u8 {
    ptr :: dest;
    m :: size / sizeof(u64);
    d :: size - m * sizeof(u64);
    loop i : usize = 0; i < m; i += 1 {
        tmp := cast(*u64) dest;
        @tmp = 0;
        dest = auto (cast(u64) dest + sizeof(u64));
    }
    loop i : usize = 0; i < d; i += 1 {
        @dest = 0;
        dest = auto (cast(u64) dest + 1);
    }
    return ptr;
}

init_default :: fn (dest: *?T) *T #inline {
    return auto memset(auto dest, 0, sizeof(T));
}

// This is actually slower on Windows.
// memset :: fn (dest: *u8, v: u8, size: usize) *u8 #intrinsic "memset.p0i8.i64";

/// Swaps content of memory at address `first` and `second`.
swap :: fn (first: *?T, second: *T) #inline {
    tmp :: @first;
    @first = @second;
    @second = tmp;
}

/// Checks whether passed pointer `ptr` is properly aligned by `alignment`.
is_aligned :: fn (ptr: *?T, alignment: usize) bool #inline {
    return cast(usize)ptr % alignment == 0;
}

/// Align pointer `p` to `alignment` and return adjusted pointer and number of bytes needed for 
/// adjustment.
///
/// **warning**: Cause panic when alignment is not power of two.
align_ptr_up :: fn (p: *u8, alignment: usize) (p: *u8, adjustment: usize)
{
    if is_aligned(p, alignment) { return p, 0; }
    mask : usize : alignment - 1;
    assert((alignment & mask) == 0); // pwr of 2
    i_unaligned :: cast(usize)p;
    misalignment :: i_unaligned & mask;
    adj :: alignment - misalignment;
    p  = cast(*u8)(i_unaligned + adj);
    return p, adj;
}


/// Allocate heap memory for `n` elements in `_v` slice. Allocated block is set to zero default value. 
/// Allocated memory must be released by :ref:`slice_terminate` call.
///
/// Zero initialization of allocated memory block can be expensive in case of large allocation.
///
/// ### Example
/// 
/// ```
/// main :: fn () s32 {
///     // Allocate slice of 10 numbers
///     sl: []s32;
///     slice_init(&sl, 10);
/// 
///     loop i := 0; i < sl.len; i += 1 {
///         sl[i] = i;
///     }
/// 
///     // release memory allocated by init
///     slice_terminate(&sl);
///     return 0;
/// }
/// ```
slice_init :: fn (slice: *[]?T, n: s64, allocator: *Allocator = null, loc := #call_location) {
    if n < 0 { panic("Attempt to allocate % elements in slice!", n); }
    if n == 0  {
        slice.ptr = null;
        slice.len = 0;
        return;
    }
    elem_size :: sizeof(T);
    bytes :: elem_size * auto n;
    slice.ptr = auto allocate_memory(allocator, bytes, loc);
    slice.len = n;
    zeromem(auto slice.ptr, bytes);
}

/// Release slice memory allocated by [slice_init](#slice_init) call. 
slice_terminate :: fn (slice: *[]?T, allocator: *Allocator = null, loc := #call_location) {
    if slice.ptr {
        free_memory(allocator, auto slice.ptr, loc);
        slice.ptr = null;
    }
    slice.len = 0;
}

/// Create slice subset defined as range `<start-index, end-index)`. Notice that `end` index
/// is excluded from range, so ``slice_range(other, 0, other.len)`` is valid and returns
/// new slice pointing to the same data as `other` slice, and with same size.
/// 
/// Indexing rules:
///
/// ```
/// start >= 0
/// start < slice.len
/// end >= 0
/// end <= slice.len
/// ```
///
/// **warning**: Function cause panic in case combination of `start` and `end` is out of `slice` range.
slice_range :: fn (slice: []?T, start: s64, end: s64 = -1) []T #inline {
    if end < 0 { end = slice.len; }
    len :: end - start;
    if len < 0 || len > slice.len || start < 0 || start >= slice.len {
         panic("Invalid slice range, wanted <%, %) slice size is %.", start, end, slice.len);
    }
    return {:[]T: len, auto ptr_shift_bytes(slice.ptr, start * cast(s64) sizeof(T))};
}

/// Specify allocator opratation.
AllocOp :: enum {
    /// Allocation of new memory block is required. 
    ALLOCATE;
    /// Free of previously allocated memory is required. 
    FREE;
    /// Release of all allocated memory if required. This operation is optional and is not supported 
    /// by all allocators.
    RELEASE;
}

/// Default allocator context base.
Allocator :: struct {
    handler: AllocFn;
}

/// Allocator handle function type.
AllocFn :: *fn (ctx: *Allocator, operation: AllocOp, size: usize, ptr : *u8 = null, file := std.str_empty, line := 0) *u8;

/// Allocate memory directly using specified `allocator`. In case the `allocator` is null, global application
/// context allocator is used.
allocate_memory :: fn (allocator: *Allocator, size: usize, loc := #call_location) *u8 #inline {
    if !allocator { allocator = _context.allocator; }
    assert(allocator && allocator.handler);
    return allocator.handler(allocator, AllocOp.ALLOCATE, size, null, loc.file, loc.line);
}

/// Free memory previously allocated by specific `allocator`. In case the `allocator` is null, global application
/// context allocator is used.
free_memory :: fn (allocator: *Allocator, ptr: *u8, loc := #call_location) #inline {
    if !allocator { allocator = _context.allocator; }
    assert(allocator && allocator.handler);
    allocator.handler(allocator, AllocOp.FREE, 0, ptr, loc.file, loc.line);
}

/// Release all memory allocated by `allocator`.
///
/// **warning**: This operation is not supported by all allocators.
release_memory :: fn (allocator: *Allocator, loc := #call_location) #inline {
    assert(allocator && allocator.handler);
    allocator.handler(allocator, AllocOp.RELEASE, 0, null, loc.file, loc.line);
}

/// Default memory allocator using libc malloc internally.
default_allocator :: {:Allocator: &default_allocator_handler };

#private
default_allocator_handler :: fn (_: *Allocator, operation: AllocOp, size: usize, ptr : *u8 = null, _:= std.str_empty, _:= 0) *u8 {
    switch operation {
        AllocOp.ALLOCATE {
            return C.malloc(size);
        }
        AllocOp.FREE {
            C.free(ptr);
        }
        AllocOp.RELEASE;
        default { panic(); }
    }
    return null;
}
