//************************************************************************************************
// bl
//
// File:   build.bl
// Author: Martin Dorazil
// Date:   8/1/20
//
// Copyright 2020 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

//! =====
//! Build
//! =====
//! 
//! ::
//! 
//!     #load "build/build.bl"
//! 
//! Compiler integrated build pipeline.

/// Opaque assembly handle. Assembly is representation of whole program workspace, it can be compiled
/// into executable or binary. Assembly is consist of Units, every unit represents one source file.
Assembly :: *u8;

/// Opaque file unit handle. Unit is representation of single source file which can be loaded into 
/// the :ref:`Assembly`.
Unit :: *u8;

/// Specify assembly build mode. Every :ref:`Assembly` can be compiled with various configuration options.
/// The `BuildMode` can specify which set of options compiler should use.
BuildMode :: enum s32 {
    /// Generates debug symbols and produce binary without any optimizations.
    Debug :: 1;
    /// Fast release mode; no debug symbols are produced, all possible optimizations
    /// are applied to produce binary as fast as possible.
    ReleaseFast :: 2;
    /// Small release mode; no debug symbols are produced, optimizations are applied
    /// to produce binary reasonably fast and as small as possible.
    ReleaseSmall :: 3;
}

/// Add new executable assembly into the current compilation queue. Assembly with
/// specified name is compiled into binary or it can be just executed in compile-time
/// without any output created. Assemblies are compiled after `build_entry` function
/// execution in order they are added.
/// 
/// Example
/// -------
/// ::
/// 
///     build :: fn () #build_entry {
///         exe :: add_executable("MyProgram");
///         add_unit(exe, "src/main.bl");
/// 
///         mode :: get_build_mode(exe);
///         switch mode {
///             BuildMode.Debug {
///                 set_output_dir(exe, "build/debug");
///             }
/// 
///             BuildMode.ReleaseSmall,
///             BuildMode.ReleaseFast {
///                 set_output_dir(exe, "build/release");
///             }
///         }
///     }
add_executable :: fn (name: string) Assembly {
    if name.len == 0 { panic("Invalid executable name!"); }

    return __add_executable(auto name.ptr);
}

/// Add new source file into the assembly. This basically load new source file into
/// the :ref:`Assembly`.
add_unit :: fn (assembly: Assembly, filepath: string) Unit {
    if !assembly { panic("Invalid assembly!"); }
    if filepath.len == 0 { panic("Invalid unit path!"); }

    return __add_unit(assembly, auto filepath.ptr);
}

/// Add path for linker library lookup.
add_lib_path :: fn (assembly: Assembly, path: string) {
    if !assembly { panic("Invalid assembly!"); }
    if path.len == 0 { panic("Invalid library path!"); }

    __add_lib_path(assembly, auto path.ptr);
}

/// Add system library. Only name is required (without extension and prefix).
/// Compiler will lookup for this library in working directory, system `PATH`
/// and `LINKER_LIB_PATH` variable specified in bl.conf file. Linked library
/// can be used also during compile-time execution, in such case all needed
/// symbols are loaded in compile-time. This does not work for `.lib` files
/// on Windows.
/// 
/// Library name platform specific rules:
/// 
///     * On Linux name will be extended by 'lib' prefix and '.so' extension.
///     * On MacOS name will be extended by 'lib' prefix and '.dylib' extension.
///     * On Windows name will be extended only by '.dll' extension.
/// 
/// Example
/// -------
/// ::
/// 
///     build :: fn () #build_entry {
///         exe :: add_executable("MyGame");
///         add_unit(exe, "src/main.bl");
/// 
///         switch OS_KIND {
///             OSKind.Windows { target_windows(exe); }
///             default        { panic("Unknown build target!"); }
///         }
///     }
/// 
///     target_windows :: fn (exe: Assembly) {
///         link_library(exe, "freetype");
///         link_library(exe, "zlib");
///         link_library(exe, "png");
///     }
link_library :: fn (assembly: Assembly, name: string) {
    if !assembly { panic("Invalid assembly!"); }
    if name.len == 0 { panic("Invalid library name!"); }

    __link_library(assembly, auto name.ptr);
}

/// Appends raw string data directly to linker command. Passed option
/// is added without any processing and copatibility validation. 
append_linker_options :: fn (assembly: Assembly, option: string) {
    if !assembly { panic("Invalid assembly!"); }
    if option.len == 0 { return; }
    __append_linker_options(assembly, auto option.ptr);
}

/// Get build mode of the assembly. 
get_build_mode :: fn (assembly: Assembly) BuildMode {
    if !assembly { panic("Invalid assembly!"); }
    return auto __get_build_mode(assembly);
}

/// Set build mode of the assembly. 
set_build_mode :: fn (assembly: Assembly, mode: BuildMode) {
    if !assembly { panic("Invalid assembly!"); }
    __set_build_mode(assembly, auto mode);
}

/// Set build output directory. This is directory where all output files will be
/// written. For example diferent output directory can be set for any build mode.
/// 
/// Directory path `dir`. This can contain non-existing directories separated by `/`,
/// compiler will create all missing directories in passed path.
set_output_dir :: fn (assembly: Assembly, dir: string) {
    if !assembly { panic("Invalid assembly!"); }
    if string_is_empty(dir) { return; }
    __set_output_dir(assembly, auto dir.ptr);
}

/// Enable compile-time execution of all tests declared in assembly.
enable_testing :: fn (assembly: Assembly) {
    __toggle_testing(assembly, 1);
}

/// Specify import module policy in :ref:`set_module_dir` function call. Module dependencies
/// of any assembly can be treated in different ways depending on use case and needs of
/// programmer. Sometimes program stability and maintainability is more important than
/// use of latest versions of modules. These flags can specify how local modules should
/// be updated.
ModuleImportPolicy :: enum s32 {
    // __System     :: 0;
    /// Bundle only missing modules from system into the local module folder and ignore
    /// if there is newer version available. Individual module updates can be done by
    /// renaming old one and re-run compilation.
    Bundle       :: 1;

    /// Bundle all missing modules from system into the local module folder and update
    /// old ones also.
    BundleLatest :: 2;
}

/// Sets module directory `dir` for `assembly`. All imported modules will be copied into
/// this directory according to chosen :ref:`ModuleImportPolicy`.
set_module_dir :: fn (assembly: Assembly, dir: string, policy := ModuleImportPolicy.BundleLatest) {
    if !assembly { panic("Invalid assembly!"); }
    if string_is_empty(dir) { return; }
    __set_module_dir(assembly, auto dir.ptr, auto policy);
}

#private
__add_executable :: fn (name: *c_char) Assembly #extern;
__add_unit :: fn (assembly: Assembly, filepath: *c_char) Unit #extern;
__add_lib_path :: fn (assembly: Assembly, path: *c_char) #extern;
__link_library :: fn (assembly: Assembly, name: *c_char) #extern;
__append_linker_options :: fn (assembly: Assembly, option: *c_char) #extern;
__set_build_mode :: fn (assembly: Assembly, mode: c_int) #extern;
__get_build_mode :: fn (assembly: Assembly) c_int #extern;
__set_output_dir :: fn (assembly: Assembly, dir: *c_char) #extern;
__toggle_testing :: fn (assembly: Assembly, v: c_int) #extern;
__set_module_dir :: fn (assembly: Assembly, dir: *c_char, policy: c_int) #extern;