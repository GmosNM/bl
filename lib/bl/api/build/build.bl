//************************************************************************************************
// bl
//
// File:   build.bl
// Author: Martin Dorazil
// Date:   8/1/20
//
// Copyright 2020 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

//! .. _Build_System:
//!
//! ============
//! Build system
//! ============
//! 
//! ::
//! 
//!     #load "build/build.bl"
//! 
//! Compiler integrated build pipeline. Build pipline can be used to manage whole project compilation 
//! process directly in BL. All you need is to create the build file called `build.bl` and specify the
//! `build_entry` function inside. When `-b` flag is used without need of specifying any files, the
//! compiler will lookup `build.bl` file in the current directory and execute it in compile time. All 
//! compilation steps, assembly input and output can be specified here. Example: :ref:`Build_System_Example`.
//!
//! Example of minimal build.bl:
//! 
//! .. code-block:: bl
//! 
//!    build :: fn () #build_entry {
//!        // create new executable assembly
//!        exe :: add_executable("MyProgram");
//! 
//!        // add 'main.bl' file into the assembly 'exe'
//!        add_unit(exe, "main.bl");
//!    }
//! 
//! Start build pipeline using our build.bl file:
//! 
//! .. code-block:: bash
//! 
//!    $ blc -build
//! 
//! Compiler will automatically use build.bl file as build script and execute build function in compile time.
//! SDK file build/build.bl containing compiler API for build pipeline manipulation is loaded implicitly.
//!
//! .. warning:: Build API is available only in compile-time.
//!
//! Basics
//! ======
//!
//! Create new executable assembly
//! ------------------------------
//! 
//! Assembly is a single build target defined as consisting of build Units representing source files
//! needed for compilation. Itâ€™s basically a target compiled into an executable or binary file. Use
//! :ref:`add_executable` function to specify your assembly. There are several options related to assembly,
//! described later  in this documentation.
//! 
//! .. code-block:: bl
//! 
//!     exe :: add_executable("MyProgram");
//! 
//! Add file into assembly
//! ----------------------
//! 
//! Use :ref:`add_unit` function to add source files into the assembly. There is no need to add all files
//! you want to use, general `load` and `import` will do so automatically. Only `main` or entry files must
//! be included.
//! 
//! .. code-block:: bl
//! 
//!     add_unit(exe, "main.bl");
//! 
//! Specify output directory
//! ------------------------
//! 
//! Output directory is a directory where all compiler-produced files will be written (i.e. native executables).
//! Use :ref:`set_output_dir` function to specify this directory, current directory is used by default.
//!
//! .. code-block:: bl
//! 
//!     set_output_dir(exe, "bin");
//!
//! Command line argumets
//! ---------------------
//! All argumets passed after `-build|-b` compiler flag are automatically forwarded into
//! `command_line_arguments` global variable.

/// Assembly is representation of whole program workspace, it's a consist of Units, every unit represents 
/// one source file.
Assembly :: struct { // !!! ABI sync AssemblyOptions !!!
    /// Specify build mode of the assembly. See :ref:`BuildMode`.
    build_mode: BuildMode;
    /// Specify debug information format used for assembly in debug mode. See :ref:`DebugInfo`.
    debug_info_kind: DebugInfo;
    /// Execute main function of assembly in compile time when true.
    run: bool;
    /// Execute all available unit tests in compile time when true.
    run_tests: bool;
    /// Tells whether copying of all runtime dependencies of executable into the current output
    /// directory set by :ref:`set_output_dir` is enabled. This value is `true` by default on
    /// Windows and `false` by default on Unix platforms. When this feature is enabled, an output
    /// directory will contain all dynamically linked libraries added into the solution by
    /// :ref:`link_library` function call or specified as dependency of imported module.
    ///
    /// No copying is done when library is already present in the output directory (to speed
    /// up compilation times), library updates must be handled manually (for example by deleting
    /// or renaming all libraries you want update).
    ///
    /// When :ref:`ModuleImportPolicy` is set to `Bundle` or `BundleLatest` compiler will lookup
    /// dependencies in project's local modules.
    copy_dependencies: bool;
    /// Verify created llvm module and print the result when true.
    verify_llvm: bool;
    /// Enable funcion interfaces to optimize inputs and outputs to fit register values.
    register_split: bool;
    /// Print lexer output into console.
    print_tokens: bool;
    /// Print parser output into console.
    print_ast: bool;
    /// Emit llvm IR into file.
    emit_llvm: bool;
    /// Emit MIR into file.    
    emit_mir: bool;
    /// Do not create any binary output when true.
    no_bin: bool;
    /// Do not generate LLVM IR when true.
    no_llvm: bool;
    /// Disable semantic analyze of code when true.
    no_analyze: bool;
    /// Check only syntax when true.
    syntax_only: bool;
}

/// Opaque file unit handle. Unit is representation of single source file which can be loaded into 
/// the :ref:`Assembly`.
Unit :: *u8;

/// Specify assembly build mode. Every :ref:`Assembly` can be compiled with various configuration options.
/// The `BuildMode` can specify which set of options compiler should use.
BuildMode :: enum s32 {
    /// Generates debug symbols and produce binary without any optimizations.
    Debug :: 1;
    /// Fast release mode; no debug symbols are produced, all possible optimizations
    /// are applied to produce binary as fast as possible.
    ReleaseFast :: 2;
    /// Small release mode; no debug symbols are produced, optimizations are applied
    /// to produce binary reasonably fast and as small as possible.
    ReleaseSmall :: 3;
}

/// Debug information format.
DebugInfo :: enum s32 {
    Dwarf :: 1;
    Codeview :: 2;
}

/// Add new executable assembly into the current compilation queue. Assembly with
/// specified name is compiled into binary or it can be just executed in compile-time
/// without any output created. Assemblies are compiled after `build_entry` function
/// execution in order they are added.
/// 
/// Example
/// -------
/// ::
/// 
///     build :: fn () #build_entry {
///         exe :: add_executable("MyProgram");
///         add_unit(exe, "src/main.bl");
/// 
///         mode :: get_build_mode(exe);
///         switch mode {
///             BuildMode.Debug {
///                 set_output_dir(exe, "build/debug");
///             }
/// 
///             BuildMode.ReleaseSmall,
///             BuildMode.ReleaseFast {
///                 set_output_dir(exe, "build/release");
///             }
///         }
///     }
add_executable :: fn (name: string) *Assembly {
    if name.len == 0 { panic("Invalid executable name!"); }
    return __add_executable(auto name.ptr);
}

/// Add new shared library target assembly into the current compilation queue.
add_library :: fn (name: string) *Assembly {
    if name.len == 0 { panic("Invalid library name!"); }
    return __add_library(auto name.ptr);
}

/// Add new source file into the assembly. This basically load new source file into
/// the :ref:`Assembly`.
add_unit :: fn (assembly: *Assembly, filepath: string) Unit {
    if !assembly { panic("Invalid assembly!"); }
    if filepath.len == 0 { panic("Invalid unit path!"); }

    return __add_unit(assembly, auto filepath.ptr);
}

/// Add path for linker library lookup.
add_lib_path :: fn (assembly: *Assembly, path: string) {
    if !assembly { panic("Invalid assembly!"); }
    if path.len == 0 { panic("Invalid library path!"); }

    __add_lib_path(assembly, auto path.ptr);
}

/// Add system library. Only name is required (without extension and prefix).
/// Compiler will lookup for this library in working directory, system `PATH`
/// and `LINKER_LIB_PATH` variable specified in `bl.conf` file. Linked library
/// can be used also during compile-time execution, in such case all needed
/// symbols are loaded in compile-time.
///
/// In general there is no need to link libraries manually, all needed dependencies
/// should be handled by module import mechanism, however there is still an option 
/// do it manually.
/// 
/// Library name platform specific rules:
/// 
///     * On Linux name will be extended by 'lib' prefix and '.so' extension.
///     * On MacOS name will be extended by 'lib' prefix and '.dylib' extension.
///     * On Windows name will be extended only by '.dll' extension.
/// 
/// Example
/// -------
/// ::
/// 
///     build :: fn () #build_entry {
///         exe :: add_executable("MyGame");
///         add_unit(exe, "src/main.bl");
/// 
///         switch OS_KIND {
///             OSKind.Windows { target_windows(exe); }
///             default        { panic("Unknown build target!"); }
///         }
///     }
/// 
///     target_windows :: fn (exe: *Assembly) {
///         link_library(exe, "freetype");
///         link_library(exe, "zlib");
///         link_library(exe, "png");
///     }
link_library :: fn (assembly: *Assembly, name: string) {
    if !assembly { panic("Invalid assembly!"); }
    if name.len == 0 { panic("Invalid library name!"); }

    __link_library(assembly, auto name.ptr);
}

/// Appends raw string data directly to linker command. Passed option
/// is added without any processing and copatibility validation. 
append_linker_options :: fn (assembly: *Assembly, option: string) {
    if !assembly { panic("Invalid assembly!"); }
    if option.len == 0 { return; }
    __append_linker_options(assembly, auto option.ptr);
}

/// Set build output directory. This is directory where all output files will be
/// written. For example diferent output directory can be set for any build mode.
/// 
/// Directory path `dir`. This can contain non-existing directories separated by `/`,
/// compiler will create all missing directories in passed path.
///
/// Specified directory will be used also for build temporary files.
set_output_dir :: fn (assembly: *Assembly, dir: string) {
    if !assembly { panic("Invalid assembly!"); }
    if string_is_empty(dir) { return; }
    __set_output_dir(assembly, auto dir.ptr);
}

/// Get output directory specified by :ref:`set_output_dir` or empty string.
get_output_dir :: fn (assembly: *Assembly) string {
    if !assembly { panic("Invalid assembly!"); }
    cdir :: __get_output_dir(assembly);    
    if !cdir { return string_empty; }
    return cstr_to_str(auto cdir);
}

/// Specify import module policy in :ref:`set_module_dir` function call. Module dependencies
/// of any assembly can be treated in different ways depending on use case and needs of
/// programmer. Sometimes program stability and maintainability is more important than
/// use of latest versions of modules. These flags can specify how local modules should
/// be updated.
ModuleImportPolicy :: enum s32 {
    /// Use system modules but prefer local ones in module directory. This option
    /// disables any copying and version check. Local module directory can contain custom
    /// project related modules you don't want to expose to the whole system.
    System :: 0;
 
    /// Bundle only missing modules from system into the local module folder and ignore
    /// if there is newer version available. Individual module updates can be done by
    /// renaming old one and re-run compilation. Custom modules (not comming from main
    /// API folder are kept untouched.)
    Bundle :: 1;

    /// Bundle all missing modules from system into the local module folder and update
    /// old ones also. Custom modules (not comming from main API folder are kept untouched.)
    /// Compiler will create `.bak` backup directory for every module before any updates.
    BundleLatest :: 2;
}

/// Sets module directory `dir` for `assembly`. All imported modules will be copied into
/// this directory according to chosen :ref:`ModuleImportPolicy`. Module policy is set to
/// `System` by default even if this function has not been called.
set_module_dir :: fn (assembly: *Assembly, dir: string, policy := ModuleImportPolicy.System) {
    if !assembly { panic("Invalid assembly!"); }
    if string_is_empty(dir) { return; }
    __set_module_dir(assembly, auto dir.ptr, auto policy);
}

/// Get module directory specified by :ref:`set_module_dir` or default one.
get_module_dir :: fn (assembly: *Assembly) string {
    if !assembly { panic("Invalid assembly!"); }
    cdir :: __get_module_dir(assembly);    
    if !cdir { return string_empty; }
    return cstr_to_str(auto cdir);
}

/// Get module import policy specified by :ref:`set_module_dir` or default one.
get_module_import_policy :: fn (assembly: *Assembly) ModuleImportPolicy {
    if !assembly { panic("Invalid assembly!"); }
    return auto __get_module_import_policy(assembly);    
}

#private
__add_executable :: fn (name: *c_char) *Assembly #extern;
__add_library :: fn (name: *c_char) *Assembly #extern;
__add_unit :: fn (assembly: *Assembly, filepath: *c_char) Unit #extern;
__compile :: fn (assembly: *Assembly) c_int #extern;
__add_lib_path :: fn (assembly: *Assembly, path: *c_char) #extern;
__link_library :: fn (assembly: *Assembly, name: *c_char) #extern;
__append_linker_options :: fn (assembly: *Assembly, option: *c_char) #extern;
__set_output_dir :: fn (assembly: *Assembly, dir: *c_char) #extern;
__get_output_dir :: fn (assembly: *Assembly) *c_char #extern;
__set_module_dir :: fn (assembly: *Assembly, dir: *c_char, policy: c_int) #extern;
__get_module_dir :: fn (assembly: *Assembly) *c_char #extern;
__get_module_import_policy :: fn (assembly: *Assembly) s32 #extern;
