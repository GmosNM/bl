// generated from /Users/travis/Develop/vulkansdk-macos-1.1.114.0/macOS/include/vulkan/vulkan_core.h

#link "vulkan"

VkFlags :: u32;
VkBool32 :: u32;
VkDeviceSize :: u64;
VkSampleMask :: u32;
VkInstance :: *u8;
VkPhysicalDevice :: *u8;
VkDevice :: *u8;
VkQueue :: *u8;
VkSemaphore :: *u8;
VkCommandBuffer :: *u8;
VkFence :: *u8;
VkDeviceMemory :: *u8;
VkBuffer :: *u8;
VkImage :: *u8;
VkEvent :: *u8;
VkQueryPool :: *u8;
VkBufferView :: *u8;
VkImageView :: *u8;
VkShaderModule :: *u8;
VkPipelineCache :: *u8;
VkPipelineLayout :: *u8;
VkRenderPass :: *u8;
VkPipeline :: *u8;
VkDescriptorSetLayout :: *u8;
VkSampler :: *u8;
VkDescriptorPool :: *u8;
VkDescriptorSet :: *u8;
VkFramebuffer :: *u8;
VkCommandPool :: *u8;
VkPerformanceConfigurationINTEL :: *u8;
VkAccelerationStructureNV :: *u8;
VkValidationCacheEXT :: *u8;
VkObjectTableNVX :: *u8;
VkIndirectCommandsLayoutNVX :: *u8; 
VkDebugUtilsMessengerEXT :: *u8;
VkDebugReportCallbackEXT :: *u8;
VkSamplerYcbcrConversion :: *u8;
VkDescriptorUpdateTemplate :: *u8;
VkDisplayKHR :: *u8;
VkDisplayModeKHR :: *u8;
VkSurfaceKHR :: *u8;
VkSwapchainKHR :: *u8;

VK_API_VERSION_1_0 : u32 : 0x400000000;

VK_KHR_SWAPCHAIN_EXTENSION_NAME :: "VK_KHR_swapchain";
VK_LOD_CLAMP_NONE                 : f32 : 1000.0f;
VK_TRUE                           : u32 : 1;
VK_FALSE                          : u32 : 0;
VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  : u32 : 256;
VK_UUID_SIZE                      : u32 : 16;
VK_MAX_MEMORY_TYPES               : u32 : 32;
VK_MAX_MEMORY_HEAPS               : u32 : 16;
VK_MAX_EXTENSION_NAME_SIZE        : u32 : 256;
VK_MAX_DESCRIPTION_SIZE           : u32 : 256;

VkPipelineCacheHeaderVersion :: enum {
    VERSION_ONE :: 1,
    VERSION_BEGIN_RANGE :: 1,
    VERSION_END_RANGE :: 1,
    VERSION_RANGE_SIZE :: 1,
    VERSION_MAX_ENUM :: 2147483647,
};

VkResult :: enum {
    SUCCESS :: 0,
    NOT_READY :: 1,
    TIMEOUT :: 2,
    EVENT_SET :: 3,
    EVENT_RESET :: 4,
    INCOMPLETE :: 5,
    ERROR_OUT_OF_HOST_MEMORY :: -1,
    ERROR_OUT_OF_DEVICE_MEMORY :: -2,
    ERROR_INITIALIZATION_FAILED :: -3,
    ERROR_DEVICE_LOST :: -4,
    ERROR_MEMORY_MAP_FAILED :: -5,
    ERROR_LAYER_NOT_PRESENT :: -6,
    ERROR_EXTENSION_NOT_PRESENT :: -7,
    ERROR_FEATURE_NOT_PRESENT :: -8,
    ERROR_INCOMPATIBLE_DRIVER :: -9,
    ERROR_TOO_MANY_OBJECTS :: -10,
    ERROR_FORMAT_NOT_SUPPORTED :: -11,
    ERROR_FRAGMENTED_POOL :: -12,
    ERROR_OUT_OF_POOL_MEMORY :: -1000069000,
    ERROR_INVALID_EXTERNAL_HANDLE :: -1000072003,
    ERROR_SURFACE_LOST_KHR :: -1000000000,
    ERROR_NATIVE_WINDOW_IN_USE_KHR :: -1000000001,
    SUBOPTIMAL_KHR :: 1000001003,
    ERROR_OUT_OF_DATE_KHR :: -1000001004,
    ERROR_INCOMPATIBLE_DISPLAY_KHR :: -1000003001,
    ERROR_VALIDATION_FAILED_EXT :: -1000011001,
    ERROR_INVALID_SHADER_NV :: -1000012000,
    ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT :: -1000158000,
    ERROR_FRAGMENTATION_EXT :: -1000161000,
    ERROR_NOT_PERMITTED_EXT :: -1000174001,
    ERROR_INVALID_DEVICE_ADDRESS_EXT :: -1000244000,
    ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT :: -1000255000,
    ERROR_OUT_OF_POOL_MEMORY_KHR :: -1000069000,
    ERROR_INVALID_EXTERNAL_HANDLE_KHR :: -1000072003,
    RESULT_BEGIN_RANGE :: -12,
    RESULT_END_RANGE :: 5,
    RESULT_RANGE_SIZE :: 18,
    RESULT_MAX_ENUM :: 2147483647,
};

VkStructureType :: enum {
    APPLICATION_INFO :: 0,
    INSTANCE_CREATE_INFO :: 1,
    DEVICE_QUEUE_CREATE_INFO :: 2,
    DEVICE_CREATE_INFO :: 3,
    SUBMIT_INFO :: 4,
    MEMORY_ALLOCATE_INFO :: 5,
    MAPPED_MEMORY_RANGE :: 6,
    BIND_SPARSE_INFO :: 7,
    FENCE_CREATE_INFO :: 8,
    SEMAPHORE_CREATE_INFO :: 9,
    EVENT_CREATE_INFO :: 10,
    QUERY_POOL_CREATE_INFO :: 11,
    BUFFER_CREATE_INFO :: 12,
    BUFFER_VIEW_CREATE_INFO :: 13,
    IMAGE_CREATE_INFO :: 14,
    IMAGE_VIEW_CREATE_INFO :: 15,
    SHADER_MODULE_CREATE_INFO :: 16,
    PIPELINE_CACHE_CREATE_INFO :: 17,
    PIPELINE_SHADER_STAGE_CREATE_INFO :: 18,
    PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO :: 19,
    PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO :: 20,
    PIPELINE_TESSELLATION_STATE_CREATE_INFO :: 21,
    PIPELINE_VIEWPORT_STATE_CREATE_INFO :: 22,
    PIPELINE_RASTERIZATION_STATE_CREATE_INFO :: 23,
    PIPELINE_MULTISAMPLE_STATE_CREATE_INFO :: 24,
    PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO :: 25,
    PIPELINE_COLOR_BLEND_STATE_CREATE_INFO :: 26,
    PIPELINE_DYNAMIC_STATE_CREATE_INFO :: 27,
    GRAPHICS_PIPELINE_CREATE_INFO :: 28,
    COMPUTE_PIPELINE_CREATE_INFO :: 29,
    PIPELINE_LAYOUT_CREATE_INFO :: 30,
    SAMPLER_CREATE_INFO :: 31,
    DESCRIPTOR_SET_LAYOUT_CREATE_INFO :: 32,
    DESCRIPTOR_POOL_CREATE_INFO :: 33,
    DESCRIPTOR_SET_ALLOCATE_INFO :: 34,
    WRITE_DESCRIPTOR_SET :: 35,
    COPY_DESCRIPTOR_SET :: 36,
    FRAMEBUFFER_CREATE_INFO :: 37,
    RENDER_PASS_CREATE_INFO :: 38,
    COMMAND_POOL_CREATE_INFO :: 39,
    COMMAND_BUFFER_ALLOCATE_INFO :: 40,
    COMMAND_BUFFER_INHERITANCE_INFO :: 41,
    COMMAND_BUFFER_BEGIN_INFO :: 42,
    RENDER_PASS_BEGIN_INFO :: 43,
    BUFFER_MEMORY_BARRIER :: 44,
    IMAGE_MEMORY_BARRIER :: 45,
    MEMORY_BARRIER :: 46,
    LOADER_INSTANCE_CREATE_INFO :: 47,
    LOADER_DEVICE_CREATE_INFO :: 48,
    PHYSICAL_DEVICE_SUBGROUP_PROPERTIES :: 1000094000,
    BIND_BUFFER_MEMORY_INFO :: 1000157000,
    BIND_IMAGE_MEMORY_INFO :: 1000157001,
    PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES :: 1000083000,
    MEMORY_DEDICATED_REQUIREMENTS :: 1000127000,
    MEMORY_DEDICATED_ALLOCATE_INFO :: 1000127001,
    MEMORY_ALLOCATE_FLAGS_INFO :: 1000060000,
    DEVICE_GROUP_RENDER_PASS_BEGIN_INFO :: 1000060003,
    DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO :: 1000060004,
    DEVICE_GROUP_SUBMIT_INFO :: 1000060005,
    DEVICE_GROUP_BIND_SPARSE_INFO :: 1000060006,
    BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO :: 1000060013,
    BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO :: 1000060014,
    PHYSICAL_DEVICE_GROUP_PROPERTIES :: 1000070000,
    DEVICE_GROUP_DEVICE_CREATE_INFO :: 1000070001,
    BUFFER_MEMORY_REQUIREMENTS_INFO_2 :: 1000146000,
    IMAGE_MEMORY_REQUIREMENTS_INFO_2 :: 1000146001,
    IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 :: 1000146002,
    MEMORY_REQUIREMENTS_2 :: 1000146003,
    SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 :: 1000146004,
    PHYSICAL_DEVICE_FEATURES_2 :: 1000059000,
    PHYSICAL_DEVICE_PROPERTIES_2 :: 1000059001,
    FORMAT_PROPERTIES_2 :: 1000059002,
    IMAGE_FORMAT_PROPERTIES_2 :: 1000059003,
    PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 :: 1000059004,
    QUEUE_FAMILY_PROPERTIES_2 :: 1000059005,
    PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 :: 1000059006,
    SPARSE_IMAGE_FORMAT_PROPERTIES_2 :: 1000059007,
    PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 :: 1000059008,
    PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES :: 1000117000,
    RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO :: 1000117001,
    IMAGE_VIEW_USAGE_CREATE_INFO :: 1000117002,
    PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO :: 1000117003,
    RENDER_PASS_MULTIVIEW_CREATE_INFO :: 1000053000,
    PHYSICAL_DEVICE_MULTIVIEW_FEATURES :: 1000053001,
    PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES :: 1000053002,
    PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES :: 1000120000,
    PROTECTED_SUBMIT_INFO :: 1000145000,
    PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES :: 1000145001,
    PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES :: 1000145002,
    DEVICE_QUEUE_INFO_2 :: 1000145003,
    SAMPLER_YCBCR_CONVERSION_CREATE_INFO :: 1000156000,
    SAMPLER_YCBCR_CONVERSION_INFO :: 1000156001,
    BIND_IMAGE_PLANE_MEMORY_INFO :: 1000156002,
    IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO :: 1000156003,
    PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES :: 1000156004,
    SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES :: 1000156005,
    DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO :: 1000085000,
    PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO :: 1000071000,
    EXTERNAL_IMAGE_FORMAT_PROPERTIES :: 1000071001,
    PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO :: 1000071002,
    EXTERNAL_BUFFER_PROPERTIES :: 1000071003,
    PHYSICAL_DEVICE_ID_PROPERTIES :: 1000071004,
    EXTERNAL_MEMORY_BUFFER_CREATE_INFO :: 1000072000,
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO :: 1000072001,
    EXPORT_MEMORY_ALLOCATE_INFO :: 1000072002,
    PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO :: 1000112000,
    EXTERNAL_FENCE_PROPERTIES :: 1000112001,
    EXPORT_FENCE_CREATE_INFO :: 1000113000,
    EXPORT_SEMAPHORE_CREATE_INFO :: 1000077000,
    PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO :: 1000076000,
    EXTERNAL_SEMAPHORE_PROPERTIES :: 1000076001,
    PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES :: 1000168000,
    DESCRIPTOR_SET_LAYOUT_SUPPORT :: 1000168001,
    PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES :: 1000063000,
    SWAPCHAIN_CREATE_INFO_KHR :: 1000001000,
    PRESENT_INFO_KHR :: 1000001001,
    DEVICE_GROUP_PRESENT_CAPABILITIES_KHR :: 1000060007,
    IMAGE_SWAPCHAIN_CREATE_INFO_KHR :: 1000060008,
    BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR :: 1000060009,
    ACQUIRE_NEXT_IMAGE_INFO_KHR :: 1000060010,
    DEVICE_GROUP_PRESENT_INFO_KHR :: 1000060011,
    DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR :: 1000060012,
    DISPLAY_MODE_CREATE_INFO_KHR :: 1000002000,
    DISPLAY_SURFACE_CREATE_INFO_KHR :: 1000002001,
    DISPLAY_PRESENT_INFO_KHR :: 1000003000,
    XLIB_SURFACE_CREATE_INFO_KHR :: 1000004000,
    XCB_SURFACE_CREATE_INFO_KHR :: 1000005000,
    WAYLAND_SURFACE_CREATE_INFO_KHR :: 1000006000,
    ANDROID_SURFACE_CREATE_INFO_KHR :: 1000008000,
    WIN32_SURFACE_CREATE_INFO_KHR :: 1000009000,
    DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT :: 1000011000,
    PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD :: 1000018000,
    DEBUG_MARKER_OBJECT_NAME_INFO_EXT :: 1000022000,
    DEBUG_MARKER_OBJECT_TAG_INFO_EXT :: 1000022001,
    DEBUG_MARKER_MARKER_INFO_EXT :: 1000022002,
    DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV :: 1000026000,
    DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV :: 1000026001,
    DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV :: 1000026002,
    PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT :: 1000028000,
    PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT :: 1000028001,
    PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT :: 1000028002,
    IMAGE_VIEW_HANDLE_INFO_NVX :: 1000030000,
    TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD :: 1000041000,
    STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP :: 1000049000,
    PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV :: 1000050000,
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV :: 1000056000,
    EXPORT_MEMORY_ALLOCATE_INFO_NV :: 1000056001,
    IMPORT_MEMORY_WIN32_HANDLE_INFO_NV :: 1000057000,
    EXPORT_MEMORY_WIN32_HANDLE_INFO_NV :: 1000057001,
    WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV :: 1000058000,
    VALIDATION_FLAGS_EXT :: 1000061000,
    VI_SURFACE_CREATE_INFO_NN :: 1000062000,
    IMAGE_VIEW_ASTC_DECODE_MODE_EXT :: 1000067000,
    PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT :: 1000067001,
    IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR :: 1000073000,
    EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR :: 1000073001,
    MEMORY_WIN32_HANDLE_PROPERTIES_KHR :: 1000073002,
    MEMORY_GET_WIN32_HANDLE_INFO_KHR :: 1000073003,
    IMPORT_MEMORY_FD_INFO_KHR :: 1000074000,
    MEMORY_FD_PROPERTIES_KHR :: 1000074001,
    MEMORY_GET_FD_INFO_KHR :: 1000074002,
    WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR :: 1000075000,
    IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR :: 1000078000,
    EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR :: 1000078001,
    D3D12_FENCE_SUBMIT_INFO_KHR :: 1000078002,
    SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR :: 1000078003,
    IMPORT_SEMAPHORE_FD_INFO_KHR :: 1000079000,
    SEMAPHORE_GET_FD_INFO_KHR :: 1000079001,
    PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR :: 1000080000,
    COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT :: 1000081000,
    PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT :: 1000081001,
    CONDITIONAL_RENDERING_BEGIN_INFO_EXT :: 1000081002,
    PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR :: 1000082000,
    PRESENT_REGIONS_KHR :: 1000084000,
    OBJECT_TABLE_CREATE_INFO_NVX :: 1000086000,
    INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX :: 1000086001,
    CMD_PROCESS_COMMANDS_INFO_NVX :: 1000086002,
    CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX :: 1000086003,
    DEVICE_GENERATED_COMMANDS_LIMITS_NVX :: 1000086004,
    DEVICE_GENERATED_COMMANDS_FEATURES_NVX :: 1000086005,
    PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV :: 1000087000,
    SURFACE_CAPABILITIES_2_EXT :: 1000090000,
    DISPLAY_POWER_INFO_EXT :: 1000091000,
    DEVICE_EVENT_INFO_EXT :: 1000091001,
    DISPLAY_EVENT_INFO_EXT :: 1000091002,
    SWAPCHAIN_COUNTER_CREATE_INFO_EXT :: 1000091003,
    PRESENT_TIMES_INFO_GOOGLE :: 1000092000,
    PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX :: 1000097000,
    PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV :: 1000098000,
    PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT :: 1000099000,
    PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT :: 1000099001,
    PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT :: 1000101000,
    PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT :: 1000101001,
    PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT :: 1000102000,
    PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT :: 1000102001,
    HDR_METADATA_EXT :: 1000105000,
    PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR :: 1000108000,
    FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR :: 1000108001,
    FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR :: 1000108002,
    RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR :: 1000108003,
    ATTACHMENT_DESCRIPTION_2_KHR :: 1000109000,
    ATTACHMENT_REFERENCE_2_KHR :: 1000109001,
    SUBPASS_DESCRIPTION_2_KHR :: 1000109002,
    SUBPASS_DEPENDENCY_2_KHR :: 1000109003,
    RENDER_PASS_CREATE_INFO_2_KHR :: 1000109004,
    SUBPASS_BEGIN_INFO_KHR :: 1000109005,
    SUBPASS_END_INFO_KHR :: 1000109006,
    SHARED_PRESENT_SURFACE_CAPABILITIES_KHR :: 1000111000,
    IMPORT_FENCE_WIN32_HANDLE_INFO_KHR :: 1000114000,
    EXPORT_FENCE_WIN32_HANDLE_INFO_KHR :: 1000114001,
    FENCE_GET_WIN32_HANDLE_INFO_KHR :: 1000114002,
    IMPORT_FENCE_FD_INFO_KHR :: 1000115000,
    FENCE_GET_FD_INFO_KHR :: 1000115001,
    PHYSICAL_DEVICE_SURFACE_INFO_2_KHR :: 1000119000,
    SURFACE_CAPABILITIES_2_KHR :: 1000119001,
    SURFACE_FORMAT_2_KHR :: 1000119002,
    DISPLAY_PROPERTIES_2_KHR :: 1000121000,
    DISPLAY_PLANE_PROPERTIES_2_KHR :: 1000121001,
    DISPLAY_MODE_PROPERTIES_2_KHR :: 1000121002,
    DISPLAY_PLANE_INFO_2_KHR :: 1000121003,
    DISPLAY_PLANE_CAPABILITIES_2_KHR :: 1000121004,
    IOS_SURFACE_CREATE_INFO_MVK :: 1000122000,
    MACOS_SURFACE_CREATE_INFO_MVK :: 1000123000,
    DEBUG_UTILS_OBJECT_NAME_INFO_EXT :: 1000128000,
    DEBUG_UTILS_OBJECT_TAG_INFO_EXT :: 1000128001,
    DEBUG_UTILS_LABEL_EXT :: 1000128002,
    DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT :: 1000128003,
    DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT :: 1000128004,
    ANDROID_HARDWARE_BUFFER_USAGE_ANDROID :: 1000129000,
    ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID :: 1000129001,
    ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID :: 1000129002,
    IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID :: 1000129003,
    MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID :: 1000129004,
    EXTERNAL_FORMAT_ANDROID :: 1000129005,
    PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT :: 1000130000,
    SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT :: 1000130001,
    PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT :: 1000138000,
    PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT :: 1000138001,
    WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT :: 1000138002,
    DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT :: 1000138003,
    SAMPLE_LOCATIONS_INFO_EXT :: 1000143000,
    RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT :: 1000143001,
    PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT :: 1000143002,
    PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT :: 1000143003,
    MULTISAMPLE_PROPERTIES_EXT :: 1000143004,
    IMAGE_FORMAT_LIST_CREATE_INFO_KHR :: 1000147000,
    PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT :: 1000148000,
    PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT :: 1000148001,
    PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT :: 1000148002,
    PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV :: 1000149000,
    PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV :: 1000152000,
    PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV :: 1000154000,
    PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV :: 1000154001,
    DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT :: 1000158000,
    DRM_FORMAT_MODIFIER_PROPERTIES_EXT :: 1000158001,
    PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT :: 1000158002,
    IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT :: 1000158003,
    IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT :: 1000158004,
    IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT :: 1000158005,
    VALIDATION_CACHE_CREATE_INFO_EXT :: 1000160000,
    SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT :: 1000160001,
    DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT :: 1000161000,
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT :: 1000161001,
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT :: 1000161002,
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT :: 1000161003,
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT :: 1000161004,
    PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV :: 1000164000,
    PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV :: 1000164001,
    PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV :: 1000164002,
    PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV :: 1000164005,
    RAY_TRACING_PIPELINE_CREATE_INFO_NV :: 1000165000,
    ACCELERATION_STRUCTURE_CREATE_INFO_NV :: 1000165001,
    GEOMETRY_NV :: 1000165003,
    GEOMETRY_TRIANGLES_NV :: 1000165004,
    GEOMETRY_AABB_NV :: 1000165005,
    BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV :: 1000165006,
    WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV :: 1000165007,
    ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV :: 1000165008,
    PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV :: 1000165009,
    RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV :: 1000165011,
    ACCELERATION_STRUCTURE_INFO_NV :: 1000165012,
    PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV :: 1000166000,
    PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV :: 1000166001,
    PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT :: 1000170000,
    FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT :: 1000170001,
    DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT :: 1000174000,
    PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR :: 1000177000,
    IMPORT_MEMORY_HOST_POINTER_INFO_EXT :: 1000178000,
    MEMORY_HOST_POINTER_PROPERTIES_EXT :: 1000178001,
    PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT :: 1000178002,
    PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR :: 1000180000,
    CALIBRATED_TIMESTAMP_INFO_EXT :: 1000184000,
    PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD :: 1000185000,
    DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD :: 1000189000,
    PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT :: 1000190000,
    PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT :: 1000190001,
    PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT :: 1000190002,
    PRESENT_FRAME_TOKEN_GGP :: 1000191000,
    PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT :: 1000192000,
    PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR :: 1000196000,
    PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR :: 1000197000,
    PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR :: 1000199000,
    SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR :: 1000199001,
    PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV :: 1000201000,
    PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV :: 1000202000,
    PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV :: 1000202001,
    PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV :: 1000203000,
    PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV :: 1000204000,
    PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV :: 1000205000,
    PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV :: 1000205002,
    CHECKPOINT_DATA_NV :: 1000206000,
    QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV :: 1000206001,
    PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS2_FEATURES_INTEL :: 1000209000,
    QUERY_POOL_CREATE_INFO_INTEL :: 1000210000,
    INITIALIZE_PERFORMANCE_API_INFO_INTEL :: 1000210001,
    PERFORMANCE_MARKER_INFO_INTEL :: 1000210002,
    PERFORMANCE_STREAM_MARKER_INFO_INTEL :: 1000210003,
    PERFORMANCE_OVERRIDE_INFO_INTEL :: 1000210004,
    PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL :: 1000210005,
    PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR :: 1000211000,
    PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT :: 1000212000,
    DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD :: 1000213000,
    SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD :: 1000213001,
    IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA :: 1000214000,
    METAL_SURFACE_CREATE_INFO_EXT :: 1000217000,
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT :: 1000218000,
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT :: 1000218001,
    RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT :: 1000218002,
    PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT :: 1000221000,
    PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT :: 1000237000,
    PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT :: 1000238000,
    MEMORY_PRIORITY_ALLOCATE_INFO_EXT :: 1000238001,
    SURFACE_PROTECTED_CAPABILITIES_KHR :: 1000239000,
    PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV :: 1000240000,
    PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT :: 1000244000,
    BUFFER_DEVICE_ADDRESS_INFO_EXT :: 1000244001,
    BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT :: 1000244002,
    IMAGE_STENCIL_USAGE_CREATE_INFO_EXT :: 1000246000,
    VALIDATION_FEATURES_EXT :: 1000247000,
    PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV :: 1000249000,
    COOPERATIVE_MATRIX_PROPERTIES_NV :: 1000249001,
    PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV :: 1000249002,
    PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV :: 1000250000,
    PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV :: 1000250001,
    FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV :: 1000250002,
    PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT :: 1000251000,
    PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT :: 1000252000,
    PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR :: 1000253000,
    SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT :: 1000255000,
    SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT :: 1000255002,
    SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT :: 1000255001,
    HEADLESS_SURFACE_CREATE_INFO_EXT :: 1000256000,
    PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT :: 1000261000,
    PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT :: 1000276000,
    PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT :: 1000281000,
    PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT :: 1000281001,
    PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES :: 1000120000,
    PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES :: 1000063000,
    DEBUG_REPORT_CREATE_INFO_EXT :: 1000011000,
    RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR :: 1000053000,
    PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR :: 1000053001,
    PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR :: 1000053002,
    PHYSICAL_DEVICE_FEATURES_2_KHR :: 1000059000,
    PHYSICAL_DEVICE_PROPERTIES_2_KHR :: 1000059001,
    FORMAT_PROPERTIES_2_KHR :: 1000059002,
    IMAGE_FORMAT_PROPERTIES_2_KHR :: 1000059003,
    PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR :: 1000059004,
    QUEUE_FAMILY_PROPERTIES_2_KHR :: 1000059005,
    PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR :: 1000059006,
    SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR :: 1000059007,
    PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR :: 1000059008,
    MEMORY_ALLOCATE_FLAGS_INFO_KHR :: 1000060000,
    DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR :: 1000060003,
    DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR :: 1000060004,
    DEVICE_GROUP_SUBMIT_INFO_KHR :: 1000060005,
    DEVICE_GROUP_BIND_SPARSE_INFO_KHR :: 1000060006,
    BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR :: 1000060013,
    BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR :: 1000060014,
    PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR :: 1000070000,
    DEVICE_GROUP_DEVICE_CREATE_INFO_KHR :: 1000070001,
    PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR :: 1000071000,
    EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR :: 1000071001,
    PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR :: 1000071002,
    EXTERNAL_BUFFER_PROPERTIES_KHR :: 1000071003,
    PHYSICAL_DEVICE_ID_PROPERTIES_KHR :: 1000071004,
    EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR :: 1000072000,
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR :: 1000072001,
    EXPORT_MEMORY_ALLOCATE_INFO_KHR :: 1000072002,
    PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR :: 1000076000,
    EXTERNAL_SEMAPHORE_PROPERTIES_KHR :: 1000076001,
    EXPORT_SEMAPHORE_CREATE_INFO_KHR :: 1000077000,
    PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR :: 1000083000,
    DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR :: 1000085000,
    SURFACE_CAPABILITIES2_EXT :: 1000090000,
    PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR :: 1000112000,
    EXTERNAL_FENCE_PROPERTIES_KHR :: 1000112001,
    EXPORT_FENCE_CREATE_INFO_KHR :: 1000113000,
    PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR :: 1000117000,
    RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR :: 1000117001,
    IMAGE_VIEW_USAGE_CREATE_INFO_KHR :: 1000117002,
    PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR :: 1000117003,
    PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR :: 1000120000,
    PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR :: 1000120000,
    MEMORY_DEDICATED_REQUIREMENTS_KHR :: 1000127000,
    MEMORY_DEDICATED_ALLOCATE_INFO_KHR :: 1000127001,
    BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR :: 1000146000,
    IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR :: 1000146001,
    IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR :: 1000146002,
    MEMORY_REQUIREMENTS_2_KHR :: 1000146003,
    SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR :: 1000146004,
    SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR :: 1000156000,
    SAMPLER_YCBCR_CONVERSION_INFO_KHR :: 1000156001,
    BIND_IMAGE_PLANE_MEMORY_INFO_KHR :: 1000156002,
    IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR :: 1000156003,
    PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR :: 1000156004,
    SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR :: 1000156005,
    BIND_BUFFER_MEMORY_INFO_KHR :: 1000157000,
    BIND_IMAGE_MEMORY_INFO_KHR :: 1000157001,
    PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR :: 1000168000,
    DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR :: 1000168001,
    PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT :: 1000244000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 48,
    RANGE_SIZE :: 49,
    MAX_ENUM :: 2147483647,
};

VkSystemAllocationScope :: enum {
    SCOPE_COMMAND :: 0,
    SCOPE_OBJECT :: 1,
    SCOPE_CACHE :: 2,
    SCOPE_DEVICE :: 3,
    SCOPE_INSTANCE :: 4,
    SCOPE_BEGIN_RANGE :: 0,
    SCOPE_END_RANGE :: 4,
    SCOPE_RANGE_SIZE :: 5,
    SCOPE_MAX_ENUM :: 2147483647,
};

VkInternalAllocationType :: enum {
    EXECUTABLE :: 0,
    BEGIN_RANGE :: 0,
    END_RANGE :: 0,
    RANGE_SIZE :: 1,
    MAX_ENUM :: 2147483647,
};

VkFormat :: enum {
    UNDEFINED :: 0,
    R4G4_UNORM_PACK8 :: 1,
    R4G4B4A4_UNORM_PACK16 :: 2,
    B4G4R4A4_UNORM_PACK16 :: 3,
    R5G6B5_UNORM_PACK16 :: 4,
    B5G6R5_UNORM_PACK16 :: 5,
    R5G5B5A1_UNORM_PACK16 :: 6,
    B5G5R5A1_UNORM_PACK16 :: 7,
    A1R5G5B5_UNORM_PACK16 :: 8,
    R8_UNORM :: 9,
    R8_SNORM :: 10,
    R8_USCALED :: 11,
    R8_SSCALED :: 12,
    R8_UINT :: 13,
    R8_SINT :: 14,
    R8_SRGB :: 15,
    R8G8_UNORM :: 16,
    R8G8_SNORM :: 17,
    R8G8_USCALED :: 18,
    R8G8_SSCALED :: 19,
    R8G8_UINT :: 20,
    R8G8_SINT :: 21,
    R8G8_SRGB :: 22,
    R8G8B8_UNORM :: 23,
    R8G8B8_SNORM :: 24,
    R8G8B8_USCALED :: 25,
    R8G8B8_SSCALED :: 26,
    R8G8B8_UINT :: 27,
    R8G8B8_SINT :: 28,
    R8G8B8_SRGB :: 29,
    B8G8R8_UNORM :: 30,
    B8G8R8_SNORM :: 31,
    B8G8R8_USCALED :: 32,
    B8G8R8_SSCALED :: 33,
    B8G8R8_UINT :: 34,
    B8G8R8_SINT :: 35,
    B8G8R8_SRGB :: 36,
    R8G8B8A8_UNORM :: 37,
    R8G8B8A8_SNORM :: 38,
    R8G8B8A8_USCALED :: 39,
    R8G8B8A8_SSCALED :: 40,
    R8G8B8A8_UINT :: 41,
    R8G8B8A8_SINT :: 42,
    R8G8B8A8_SRGB :: 43,
    B8G8R8A8_UNORM :: 44,
    B8G8R8A8_SNORM :: 45,
    B8G8R8A8_USCALED :: 46,
    B8G8R8A8_SSCALED :: 47,
    B8G8R8A8_UINT :: 48,
    B8G8R8A8_SINT :: 49,
    B8G8R8A8_SRGB :: 50,
    A8B8G8R8_UNORM_PACK32 :: 51,
    A8B8G8R8_SNORM_PACK32 :: 52,
    A8B8G8R8_USCALED_PACK32 :: 53,
    A8B8G8R8_SSCALED_PACK32 :: 54,
    A8B8G8R8_UINT_PACK32 :: 55,
    A8B8G8R8_SINT_PACK32 :: 56,
    A8B8G8R8_SRGB_PACK32 :: 57,
    A2R10G10B10_UNORM_PACK32 :: 58,
    A2R10G10B10_SNORM_PACK32 :: 59,
    A2R10G10B10_USCALED_PACK32 :: 60,
    A2R10G10B10_SSCALED_PACK32 :: 61,
    A2R10G10B10_UINT_PACK32 :: 62,
    A2R10G10B10_SINT_PACK32 :: 63,
    A2B10G10R10_UNORM_PACK32 :: 64,
    A2B10G10R10_SNORM_PACK32 :: 65,
    A2B10G10R10_USCALED_PACK32 :: 66,
    A2B10G10R10_SSCALED_PACK32 :: 67,
    A2B10G10R10_UINT_PACK32 :: 68,
    A2B10G10R10_SINT_PACK32 :: 69,
    R16_UNORM :: 70,
    R16_SNORM :: 71,
    R16_USCALED :: 72,
    R16_SSCALED :: 73,
    R16_UINT :: 74,
    R16_SINT :: 75,
    R16_SFLOAT :: 76,
    R16G16_UNORM :: 77,
    R16G16_SNORM :: 78,
    R16G16_USCALED :: 79,
    R16G16_SSCALED :: 80,
    R16G16_UINT :: 81,
    R16G16_SINT :: 82,
    R16G16_SFLOAT :: 83,
    R16G16B16_UNORM :: 84,
    R16G16B16_SNORM :: 85,
    R16G16B16_USCALED :: 86,
    R16G16B16_SSCALED :: 87,
    R16G16B16_UINT :: 88,
    R16G16B16_SINT :: 89,
    R16G16B16_SFLOAT :: 90,
    R16G16B16A16_UNORM :: 91,
    R16G16B16A16_SNORM :: 92,
    R16G16B16A16_USCALED :: 93,
    R16G16B16A16_SSCALED :: 94,
    R16G16B16A16_UINT :: 95,
    R16G16B16A16_SINT :: 96,
    R16G16B16A16_SFLOAT :: 97,
    R32_UINT :: 98,
    R32_SINT :: 99,
    R32_SFLOAT :: 100,
    R32G32_UINT :: 101,
    R32G32_SINT :: 102,
    R32G32_SFLOAT :: 103,
    R32G32B32_UINT :: 104,
    R32G32B32_SINT :: 105,
    R32G32B32_SFLOAT :: 106,
    R32G32B32A32_UINT :: 107,
    R32G32B32A32_SINT :: 108,
    R32G32B32A32_SFLOAT :: 109,
    R64_UINT :: 110,
    R64_SINT :: 111,
    R64_SFLOAT :: 112,
    R64G64_UINT :: 113,
    R64G64_SINT :: 114,
    R64G64_SFLOAT :: 115,
    R64G64B64_UINT :: 116,
    R64G64B64_SINT :: 117,
    R64G64B64_SFLOAT :: 118,
    R64G64B64A64_UINT :: 119,
    R64G64B64A64_SINT :: 120,
    R64G64B64A64_SFLOAT :: 121,
    B10G11R11_UFLOAT_PACK32 :: 122,
    E5B9G9R9_UFLOAT_PACK32 :: 123,
    D16_UNORM :: 124,
    X8_D24_UNORM_PACK32 :: 125,
    D32_SFLOAT :: 126,
    S8_UINT :: 127,
    D16_UNORM_S8_UINT :: 128,
    D24_UNORM_S8_UINT :: 129,
    D32_SFLOAT_S8_UINT :: 130,
    BC1_RGB_UNORM_BLOCK :: 131,
    BC1_RGB_SRGB_BLOCK :: 132,
    BC1_RGBA_UNORM_BLOCK :: 133,
    BC1_RGBA_SRGB_BLOCK :: 134,
    BC2_UNORM_BLOCK :: 135,
    BC2_SRGB_BLOCK :: 136,
    BC3_UNORM_BLOCK :: 137,
    BC3_SRGB_BLOCK :: 138,
    BC4_UNORM_BLOCK :: 139,
    BC4_SNORM_BLOCK :: 140,
    BC5_UNORM_BLOCK :: 141,
    BC5_SNORM_BLOCK :: 142,
    BC6H_UFLOAT_BLOCK :: 143,
    BC6H_SFLOAT_BLOCK :: 144,
    BC7_UNORM_BLOCK :: 145,
    BC7_SRGB_BLOCK :: 146,
    ETC2_R8G8B8_UNORM_BLOCK :: 147,
    ETC2_R8G8B8_SRGB_BLOCK :: 148,
    ETC2_R8G8B8A1_UNORM_BLOCK :: 149,
    ETC2_R8G8B8A1_SRGB_BLOCK :: 150,
    ETC2_R8G8B8A8_UNORM_BLOCK :: 151,
    ETC2_R8G8B8A8_SRGB_BLOCK :: 152,
    EAC_R11_UNORM_BLOCK :: 153,
    EAC_R11_SNORM_BLOCK :: 154,
    EAC_R11G11_UNORM_BLOCK :: 155,
    EAC_R11G11_SNORM_BLOCK :: 156,
    ASTC_4x4_UNORM_BLOCK :: 157,
    ASTC_4x4_SRGB_BLOCK :: 158,
    ASTC_5x4_UNORM_BLOCK :: 159,
    ASTC_5x4_SRGB_BLOCK :: 160,
    ASTC_5x5_UNORM_BLOCK :: 161,
    ASTC_5x5_SRGB_BLOCK :: 162,
    ASTC_6x5_UNORM_BLOCK :: 163,
    ASTC_6x5_SRGB_BLOCK :: 164,
    ASTC_6x6_UNORM_BLOCK :: 165,
    ASTC_6x6_SRGB_BLOCK :: 166,
    ASTC_8x5_UNORM_BLOCK :: 167,
    ASTC_8x5_SRGB_BLOCK :: 168,
    ASTC_8x6_UNORM_BLOCK :: 169,
    ASTC_8x6_SRGB_BLOCK :: 170,
    ASTC_8x8_UNORM_BLOCK :: 171,
    ASTC_8x8_SRGB_BLOCK :: 172,
    ASTC_10x5_UNORM_BLOCK :: 173,
    ASTC_10x5_SRGB_BLOCK :: 174,
    ASTC_10x6_UNORM_BLOCK :: 175,
    ASTC_10x6_SRGB_BLOCK :: 176,
    ASTC_10x8_UNORM_BLOCK :: 177,
    ASTC_10x8_SRGB_BLOCK :: 178,
    ASTC_10x10_UNORM_BLOCK :: 179,
    ASTC_10x10_SRGB_BLOCK :: 180,
    ASTC_12x10_UNORM_BLOCK :: 181,
    ASTC_12x10_SRGB_BLOCK :: 182,
    ASTC_12x12_UNORM_BLOCK :: 183,
    ASTC_12x12_SRGB_BLOCK :: 184,
    G8B8G8R8_422_UNORM :: 1000156000,
    B8G8R8G8_422_UNORM :: 1000156001,
    G8_B8_R8_3PLANE_420_UNORM :: 1000156002,
    G8_B8R8_2PLANE_420_UNORM :: 1000156003,
    G8_B8_R8_3PLANE_422_UNORM :: 1000156004,
    G8_B8R8_2PLANE_422_UNORM :: 1000156005,
    G8_B8_R8_3PLANE_444_UNORM :: 1000156006,
    R10X6_UNORM_PACK16 :: 1000156007,
    R10X6G10X6_UNORM_2PACK16 :: 1000156008,
    R10X6G10X6B10X6A10X6_UNORM_4PACK16 :: 1000156009,
    G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 :: 1000156010,
    B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 :: 1000156011,
    G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 :: 1000156012,
    G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 :: 1000156013,
    G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 :: 1000156014,
    G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 :: 1000156015,
    G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 :: 1000156016,
    R12X4_UNORM_PACK16 :: 1000156017,
    R12X4G12X4_UNORM_2PACK16 :: 1000156018,
    R12X4G12X4B12X4A12X4_UNORM_4PACK16 :: 1000156019,
    G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 :: 1000156020,
    B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 :: 1000156021,
    G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 :: 1000156022,
    G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 :: 1000156023,
    G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 :: 1000156024,
    G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 :: 1000156025,
    G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 :: 1000156026,
    G16B16G16R16_422_UNORM :: 1000156027,
    B16G16R16G16_422_UNORM :: 1000156028,
    G16_B16_R16_3PLANE_420_UNORM :: 1000156029,
    G16_B16R16_2PLANE_420_UNORM :: 1000156030,
    G16_B16_R16_3PLANE_422_UNORM :: 1000156031,
    G16_B16R16_2PLANE_422_UNORM :: 1000156032,
    G16_B16_R16_3PLANE_444_UNORM :: 1000156033,
    PVRTC1_2BPP_UNORM_BLOCK_IMG :: 1000054000,
    PVRTC1_4BPP_UNORM_BLOCK_IMG :: 1000054001,
    PVRTC2_2BPP_UNORM_BLOCK_IMG :: 1000054002,
    PVRTC2_4BPP_UNORM_BLOCK_IMG :: 1000054003,
    PVRTC1_2BPP_SRGB_BLOCK_IMG :: 1000054004,
    PVRTC1_4BPP_SRGB_BLOCK_IMG :: 1000054005,
    PVRTC2_2BPP_SRGB_BLOCK_IMG :: 1000054006,
    PVRTC2_4BPP_SRGB_BLOCK_IMG :: 1000054007,
    G8B8G8R8_422_UNORM_KHR :: 1000156000,
    B8G8R8G8_422_UNORM_KHR :: 1000156001,
    G8_B8_R8_3PLANE_420_UNORM_KHR :: 1000156002,
    G8_B8R8_2PLANE_420_UNORM_KHR :: 1000156003,
    G8_B8_R8_3PLANE_422_UNORM_KHR :: 1000156004,
    G8_B8R8_2PLANE_422_UNORM_KHR :: 1000156005,
    G8_B8_R8_3PLANE_444_UNORM_KHR :: 1000156006,
    R10X6_UNORM_PACK16_KHR :: 1000156007,
    R10X6G10X6_UNORM_2PACK16_KHR :: 1000156008,
    R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR :: 1000156009,
    G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR :: 1000156010,
    B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR :: 1000156011,
    G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR :: 1000156012,
    G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR :: 1000156013,
    G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR :: 1000156014,
    G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR :: 1000156015,
    G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR :: 1000156016,
    R12X4_UNORM_PACK16_KHR :: 1000156017,
    R12X4G12X4_UNORM_2PACK16_KHR :: 1000156018,
    R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR :: 1000156019,
    G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR :: 1000156020,
    B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR :: 1000156021,
    G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR :: 1000156022,
    G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR :: 1000156023,
    G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR :: 1000156024,
    G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR :: 1000156025,
    G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR :: 1000156026,
    G16B16G16R16_422_UNORM_KHR :: 1000156027,
    B16G16R16G16_422_UNORM_KHR :: 1000156028,
    G16_B16_R16_3PLANE_420_UNORM_KHR :: 1000156029,
    G16_B16R16_2PLANE_420_UNORM_KHR :: 1000156030,
    G16_B16_R16_3PLANE_422_UNORM_KHR :: 1000156031,
    G16_B16R16_2PLANE_422_UNORM_KHR :: 1000156032,
    G16_B16_R16_3PLANE_444_UNORM_KHR :: 1000156033,
    BEGIN_RANGE :: 0,
    END_RANGE :: 184,
    RANGE_SIZE :: 185,
    MAX_ENUM :: 2147483647,
};

VkImageType :: enum {
    _1D :: 0,
    _2D :: 1,
    _3D :: 2,
    BEGIN_RANGE :: 0,
    END_RANGE :: 2,
    RANGE_SIZE :: 3,
    MAX_ENUM :: 2147483647,
};

VkImageTiling :: enum {
    OPTIMAL :: 0,
    LINEAR :: 1,
    DRM_FORMAT_MODIFIER_EXT :: 1000158000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkPhysicalDeviceType :: enum {
    TYPE_OTHER :: 0,
    TYPE_INTEGRATED_GPU :: 1,
    TYPE_DISCRETE_GPU :: 2,
    TYPE_VIRTUAL_GPU :: 3,
    TYPE_CPU :: 4,
    TYPE_BEGIN_RANGE :: 0,
    TYPE_END_RANGE :: 4,
    TYPE_RANGE_SIZE :: 5,
    TYPE_MAX_ENUM :: 2147483647,
};

VkQueryType :: enum {
    OCCLUSION :: 0,
    PIPELINE_STATISTICS :: 1,
    TIMESTAMP :: 2,
    TRANSFORM_FEEDBACK_STREAM_EXT :: 1000028004,
    ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV :: 1000165000,
    PERFORMANCE_QUERY_INTEL :: 1000210000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 2,
    RANGE_SIZE :: 3,
    MAX_ENUM :: 2147483647,
};

VkSharingMode :: enum {
    EXCLUSIVE :: 0,
    CONCURRENT :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkImageLayout :: enum {
    UNDEFINED :: 0,
    GENERAL :: 1,
    COLOR_ATTACHMENT_OPTIMAL :: 2,
    DEPTH_STENCIL_ATTACHMENT_OPTIMAL :: 3,
    DEPTH_STENCIL_READ_ONLY_OPTIMAL :: 4,
    SHADER_READ_ONLY_OPTIMAL :: 5,
    TRANSFER_SRC_OPTIMAL :: 6,
    TRANSFER_DST_OPTIMAL :: 7,
    PREINITIALIZED :: 8,
    DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL :: 1000117000,
    DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL :: 1000117001,
    PRESENT_SRC_KHR :: 1000001002,
    SHARED_PRESENT_KHR :: 1000111000,
    SHADING_RATE_OPTIMAL_NV :: 1000164003,
    FRAGMENT_DENSITY_MAP_OPTIMAL_EXT :: 1000218000,
    DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR :: 1000117000,
    DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR :: 1000117001,
    BEGIN_RANGE :: 0,
    END_RANGE :: 8,
    RANGE_SIZE :: 9,
    MAX_ENUM :: 2147483647,
};

VkImageViewType :: enum {
    _1D :: 0,
    _2D :: 1,
    _3D :: 2,
    CUBE :: 3,
    _1D_ARRAY :: 4,
    _2D_ARRAY :: 5,
    CUBE_ARRAY :: 6,
    BEGIN_RANGE :: 0,
    END_RANGE :: 6,
    RANGE_SIZE :: 7,
    MAX_ENUM :: 2147483647,
};

VkComponentSwizzle :: enum {
    IDENTITY :: 0,
    ZERO :: 1,
    ONE :: 2,
    R :: 3,
    G :: 4,
    B :: 5,
    A :: 6,
    BEGIN_RANGE :: 0,
    END_RANGE :: 6,
    RANGE_SIZE :: 7,
    MAX_ENUM :: 2147483647,
};

VkVertexInputRate :: enum {
    VERTEX :: 0,
    INSTANCE :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkPrimitiveTopology :: enum {
    POINT_LIST :: 0,
    LINE_LIST :: 1,
    LINE_STRIP :: 2,
    TRIANGLE_LIST :: 3,
    TRIANGLE_STRIP :: 4,
    TRIANGLE_FAN :: 5,
    LINE_LIST_WITH_ADJACENCY :: 6,
    LINE_STRIP_WITH_ADJACENCY :: 7,
    TRIANGLE_LIST_WITH_ADJACENCY :: 8,
    TRIANGLE_STRIP_WITH_ADJACENCY :: 9,
    PATCH_LIST :: 10,
    BEGIN_RANGE :: 0,
    END_RANGE :: 10,
    RANGE_SIZE :: 11,
    MAX_ENUM :: 2147483647,
};

VkPolygonMode :: enum {
    FILL :: 0,
    LINE :: 1,
    POINT :: 2,
    FILL_RECTANGLE_NV :: 1000153000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 2,
    RANGE_SIZE :: 3,
    MAX_ENUM :: 2147483647,
};

VkFrontFace :: enum {
    COUNTER_CLOCKWISE :: 0,
    CLOCKWISE :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkCompareOp :: enum {
    NEVER :: 0,
    LESS :: 1,
    EQUAL :: 2,
    LESS_OR_EQUAL :: 3,
    GREATER :: 4,
    NOT_EQUAL :: 5,
    GREATER_OR_EQUAL :: 6,
    ALWAYS :: 7,
    BEGIN_RANGE :: 0,
    END_RANGE :: 7,
    RANGE_SIZE :: 8,
    MAX_ENUM :: 2147483647,
};

VkStencilOp :: enum {
    KEEP :: 0,
    ZERO :: 1,
    REPLACE :: 2,
    INCREMENT_AND_CLAMP :: 3,
    DECREMENT_AND_CLAMP :: 4,
    INVERT :: 5,
    INCREMENT_AND_WRAP :: 6,
    DECREMENT_AND_WRAP :: 7,
    BEGIN_RANGE :: 0,
    END_RANGE :: 7,
    RANGE_SIZE :: 8,
    MAX_ENUM :: 2147483647,
};

VkLogicOp :: enum {
    CLEAR :: 0,
    AND :: 1,
    AND_REVERSE :: 2,
    COPY :: 3,
    AND_INVERTED :: 4,
    NO_OP :: 5,
    XOR :: 6,
    OR :: 7,
    NOR :: 8,
    EQUIVALENT :: 9,
    INVERT :: 10,
    OR_REVERSE :: 11,
    COPY_INVERTED :: 12,
    OR_INVERTED :: 13,
    NAND :: 14,
    SET :: 15,
    BEGIN_RANGE :: 0,
    END_RANGE :: 15,
    RANGE_SIZE :: 16,
    MAX_ENUM :: 2147483647,
};

VkBlendFactor :: enum {
    ZERO :: 0,
    ONE :: 1,
    SRC_COLOR :: 2,
    ONE_MINUS_SRC_COLOR :: 3,
    DST_COLOR :: 4,
    ONE_MINUS_DST_COLOR :: 5,
    SRC_ALPHA :: 6,
    ONE_MINUS_SRC_ALPHA :: 7,
    DST_ALPHA :: 8,
    ONE_MINUS_DST_ALPHA :: 9,
    CONSTANT_COLOR :: 10,
    ONE_MINUS_CONSTANT_COLOR :: 11,
    CONSTANT_ALPHA :: 12,
    ONE_MINUS_CONSTANT_ALPHA :: 13,
    SRC_ALPHA_SATURATE :: 14,
    SRC1_COLOR :: 15,
    ONE_MINUS_SRC1_COLOR :: 16,
    SRC1_ALPHA :: 17,
    ONE_MINUS_SRC1_ALPHA :: 18,
    BEGIN_RANGE :: 0,
    END_RANGE :: 18,
    RANGE_SIZE :: 19,
    MAX_ENUM :: 2147483647,
};

VkBlendOp :: enum {
    ADD :: 0,
    SUBTRACT :: 1,
    REVERSE_SUBTRACT :: 2,
    MIN :: 3,
    MAX :: 4,
    ZERO_EXT :: 1000148000,
    SRC_EXT :: 1000148001,
    DST_EXT :: 1000148002,
    SRC_OVER_EXT :: 1000148003,
    DST_OVER_EXT :: 1000148004,
    SRC_IN_EXT :: 1000148005,
    DST_IN_EXT :: 1000148006,
    SRC_OUT_EXT :: 1000148007,
    DST_OUT_EXT :: 1000148008,
    SRC_ATOP_EXT :: 1000148009,
    DST_ATOP_EXT :: 1000148010,
    XOR_EXT :: 1000148011,
    MULTIPLY_EXT :: 1000148012,
    SCREEN_EXT :: 1000148013,
    OVERLAY_EXT :: 1000148014,
    DARKEN_EXT :: 1000148015,
    LIGHTEN_EXT :: 1000148016,
    COLORDODGE_EXT :: 1000148017,
    COLORBURN_EXT :: 1000148018,
    HARDLIGHT_EXT :: 1000148019,
    SOFTLIGHT_EXT :: 1000148020,
    DIFFERENCE_EXT :: 1000148021,
    EXCLUSION_EXT :: 1000148022,
    INVERT_EXT :: 1000148023,
    INVERT_RGB_EXT :: 1000148024,
    LINEARDODGE_EXT :: 1000148025,
    LINEARBURN_EXT :: 1000148026,
    VIVIDLIGHT_EXT :: 1000148027,
    LINEARLIGHT_EXT :: 1000148028,
    PINLIGHT_EXT :: 1000148029,
    HARDMIX_EXT :: 1000148030,
    HSL_HUE_EXT :: 1000148031,
    HSL_SATURATION_EXT :: 1000148032,
    HSL_COLOR_EXT :: 1000148033,
    HSL_LUMINOSITY_EXT :: 1000148034,
    PLUS_EXT :: 1000148035,
    PLUS_CLAMPED_EXT :: 1000148036,
    PLUS_CLAMPED_ALPHA_EXT :: 1000148037,
    PLUS_DARKER_EXT :: 1000148038,
    MINUS_EXT :: 1000148039,
    MINUS_CLAMPED_EXT :: 1000148040,
    CONTRAST_EXT :: 1000148041,
    INVERT_OVG_EXT :: 1000148042,
    RED_EXT :: 1000148043,
    GREEN_EXT :: 1000148044,
    BLUE_EXT :: 1000148045,
    BEGIN_RANGE :: 0,
    END_RANGE :: 4,
    RANGE_SIZE :: 5,
    MAX_ENUM :: 2147483647,
};

VkDynamicState :: enum {
    VIEWPORT :: 0,
    SCISSOR :: 1,
    LINE_WIDTH :: 2,
    DEPTH_BIAS :: 3,
    BLEND_CONSTANTS :: 4,
    DEPTH_BOUNDS :: 5,
    STENCIL_COMPARE_MASK :: 6,
    STENCIL_WRITE_MASK :: 7,
    STENCIL_REFERENCE :: 8,
    VIEWPORT_W_SCALING_NV :: 1000087000,
    DISCARD_RECTANGLE_EXT :: 1000099000,
    SAMPLE_LOCATIONS_EXT :: 1000143000,
    VIEWPORT_SHADING_RATE_PALETTE_NV :: 1000164004,
    VIEWPORT_COARSE_SAMPLE_ORDER_NV :: 1000164006,
    EXCLUSIVE_SCISSOR_NV :: 1000205001,
    BEGIN_RANGE :: 0,
    END_RANGE :: 8,
    RANGE_SIZE :: 9,
    MAX_ENUM :: 2147483647,
};

VkFilter :: enum {
    NEAREST :: 0,
    LINEAR :: 1,
    CUBIC_IMG :: 1000015000,
    CUBIC_EXT :: 1000015000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkSamplerMipmapMode :: enum {
    NEAREST :: 0,
    LINEAR :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkSamplerAddressMode :: enum {
    REPEAT :: 0,
    MIRRORED_REPEAT :: 1,
    CLAMP_TO_EDGE :: 2,
    CLAMP_TO_BORDER :: 3,
    MIRROR_CLAMP_TO_EDGE :: 4,
    BEGIN_RANGE :: 0,
    END_RANGE :: 3,
    RANGE_SIZE :: 4,
    MAX_ENUM :: 2147483647,
};

VkBorderColor :: enum {
    FLOAT_TRANSPARENT_BLACK :: 0,
    INT_TRANSPARENT_BLACK :: 1,
    FLOAT_OPAQUE_BLACK :: 2,
    INT_OPAQUE_BLACK :: 3,
    FLOAT_OPAQUE_WHITE :: 4,
    INT_OPAQUE_WHITE :: 5,
    BEGIN_RANGE :: 0,
    END_RANGE :: 5,
    RANGE_SIZE :: 6,
    MAX_ENUM :: 2147483647,
};

VkDescriptorType :: enum {
    SAMPLER :: 0,
    COMBINED_IMAGE_SAMPLER :: 1,
    SAMPLED_IMAGE :: 2,
    STORAGE_IMAGE :: 3,
    UNIFORM_TEXEL_BUFFER :: 4,
    STORAGE_TEXEL_BUFFER :: 5,
    UNIFORM_BUFFER :: 6,
    STORAGE_BUFFER :: 7,
    UNIFORM_BUFFER_DYNAMIC :: 8,
    STORAGE_BUFFER_DYNAMIC :: 9,
    INPUT_ATTACHMENT :: 10,
    INLINE_UNIFORM_BLOCK_EXT :: 1000138000,
    ACCELERATION_STRUCTURE_NV :: 1000165000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 10,
    RANGE_SIZE :: 11,
    MAX_ENUM :: 2147483647,
};

VkAttachmentLoadOp :: enum {
    LOAD :: 0,
    CLEAR :: 1,
    DONT_CARE :: 2,
    BEGIN_RANGE :: 0,
    END_RANGE :: 2,
    RANGE_SIZE :: 3,
    MAX_ENUM :: 2147483647,
};

VkAttachmentStoreOp :: enum {
    STORE :: 0,
    DONT_CARE :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkPipelineBindPoint :: enum {
    GRAPHICS :: 0,
    COMPUTE :: 1,
    RAY_TRACING_NV :: 1000165000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkCommandBufferLevel :: enum {
    PRIMARY :: 0,
    SECONDARY :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkIndexType :: enum {
    UINT16 :: 0,
    UINT32 :: 1,
    NONE_NV :: 1000165000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkSubpassContents :: enum {
    INLINE :: 0,
    SECONDARY_COMMAND_BUFFERS :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkObjectType :: enum {
    UNKNOWN :: 0,
    INSTANCE :: 1,
    PHYSICAL_DEVICE :: 2,
    DEVICE :: 3,
    QUEUE :: 4,
    SEMAPHORE :: 5,
    COMMAND_BUFFER :: 6,
    FENCE :: 7,
    DEVICE_MEMORY :: 8,
    BUFFER :: 9,
    IMAGE :: 10,
    EVENT :: 11,
    QUERY_POOL :: 12,
    BUFFER_VIEW :: 13,
    IMAGE_VIEW :: 14,
    SHADER_MODULE :: 15,
    PIPELINE_CACHE :: 16,
    PIPELINE_LAYOUT :: 17,
    RENDER_PASS :: 18,
    PIPELINE :: 19,
    DESCRIPTOR_SET_LAYOUT :: 20,
    SAMPLER :: 21,
    DESCRIPTOR_POOL :: 22,
    DESCRIPTOR_SET :: 23,
    FRAMEBUFFER :: 24,
    COMMAND_POOL :: 25,
    SAMPLER_YCBCR_CONVERSION :: 1000156000,
    DESCRIPTOR_UPDATE_TEMPLATE :: 1000085000,
    SURFACE_KHR :: 1000000000,
    SWAPCHAIN_KHR :: 1000001000,
    DISPLAY_KHR :: 1000002000,
    DISPLAY_MODE_KHR :: 1000002001,
    DEBUG_REPORT_CALLBACK_EXT :: 1000011000,
    OBJECT_TABLE_NVX :: 1000086000,
    INDIRECT_COMMANDS_LAYOUT_NVX :: 1000086001,
    DEBUG_UTILS_MESSENGER_EXT :: 1000128000,
    VALIDATION_CACHE_EXT :: 1000160000,
    ACCELERATION_STRUCTURE_NV :: 1000165000,
    PERFORMANCE_CONFIGURATION_INTEL :: 1000210000,
    DESCRIPTOR_UPDATE_TEMPLATE_KHR :: 1000085000,
    SAMPLER_YCBCR_CONVERSION_KHR :: 1000156000,
    BEGIN_RANGE :: 0,
    END_RANGE :: 25,
    RANGE_SIZE :: 26,
    MAX_ENUM :: 2147483647,
};

VkVendorId :: enum {
    ID_VIV :: 65537,
    ID_VSI :: 65538,
    ID_KAZAN :: 65539,
    ID_BEGIN_RANGE :: 65537,
    ID_END_RANGE :: 65539,
    ID_RANGE_SIZE :: 3,
    ID_MAX_ENUM :: 2147483647,
};

VkInstanceCreateFlags :: VkFlags;

VkFormatFeatureFlagBits :: enum {
    SAMPLED_IMAGE_BIT :: 1,
    STORAGE_IMAGE_BIT :: 2,
    STORAGE_IMAGE_ATOMIC_BIT :: 4,
    UNIFORM_TEXEL_BUFFER_BIT :: 8,
    STORAGE_TEXEL_BUFFER_BIT :: 16,
    STORAGE_TEXEL_BUFFER_ATOMIC_BIT :: 32,
    VERTEX_BUFFER_BIT :: 64,
    COLOR_ATTACHMENT_BIT :: 128,
    COLOR_ATTACHMENT_BLEND_BIT :: 256,
    DEPTH_STENCIL_ATTACHMENT_BIT :: 512,
    BLIT_SRC_BIT :: 1024,
    BLIT_DST_BIT :: 2048,
    SAMPLED_IMAGE_FILTER_LINEAR_BIT :: 4096,
    TRANSFER_SRC_BIT :: 16384,
    TRANSFER_DST_BIT :: 32768,
    MIDPOINT_CHROMA_SAMPLES_BIT :: 131072,
    SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT :: 262144,
    SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT :: 524288,
    SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT :: 1048576,
    SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT :: 2097152,
    DISJOINT_BIT :: 4194304,
    COSITED_CHROMA_SAMPLES_BIT :: 8388608,
    SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG :: 8192,
    SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT :: 65536,
    FRAGMENT_DENSITY_MAP_BIT_EXT :: 16777216,
    TRANSFER_SRC_BIT_KHR :: 16384,
    TRANSFER_DST_BIT_KHR :: 32768,
    MIDPOINT_CHROMA_SAMPLES_BIT_KHR :: 131072,
    SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR :: 262144,
    SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR :: 524288,
    SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR :: 1048576,
    SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR :: 2097152,
    DISJOINT_BIT_KHR :: 4194304,
    COSITED_CHROMA_SAMPLES_BIT_KHR :: 8388608,
    SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT :: 8192,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkFormatFeatureFlags :: VkFlags;

VkImageUsageFlagBits :: enum {
    TRANSFER_SRC_BIT :: 1,
    TRANSFER_DST_BIT :: 2,
    SAMPLED_BIT :: 4,
    STORAGE_BIT :: 8,
    COLOR_ATTACHMENT_BIT :: 16,
    DEPTH_STENCIL_ATTACHMENT_BIT :: 32,
    TRANSIENT_ATTACHMENT_BIT :: 64,
    INPUT_ATTACHMENT_BIT :: 128,
    SHADING_RATE_IMAGE_BIT_NV :: 256,
    FRAGMENT_DENSITY_MAP_BIT_EXT :: 512,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkImageUsageFlags :: VkFlags;

VkImageCreateFlagBits :: enum {
    SPARSE_BINDING_BIT :: 1,
    SPARSE_RESIDENCY_BIT :: 2,
    SPARSE_ALIASED_BIT :: 4,
    MUTABLE_FORMAT_BIT :: 8,
    CUBE_COMPATIBLE_BIT :: 16,
    ALIAS_BIT :: 1024,
    SPLIT_INSTANCE_BIND_REGIONS_BIT :: 64,
    _2D_ARRAY_COMPATIBLE_BIT :: 32,
    BLOCK_TEXEL_VIEW_COMPATIBLE_BIT :: 128,
    EXTENDED_USAGE_BIT :: 256,
    PROTECTED_BIT :: 2048,
    DISJOINT_BIT :: 512,
    CORNER_SAMPLED_BIT_NV :: 8192,
    SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT :: 4096,
    SUBSAMPLED_BIT_EXT :: 16384,
    SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR :: 64,
    _2D_ARRAY_COMPATIBLE_BIT_KHR :: 32,
    BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR :: 128,
    EXTENDED_USAGE_BIT_KHR :: 256,
    DISJOINT_BIT_KHR :: 512,
    ALIAS_BIT_KHR :: 1024,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkImageCreateFlags :: VkFlags;

VkSampleCountFlagBits :: enum {
    _1_BIT :: 1,
    _2_BIT :: 2,
    _4_BIT :: 4,
    _8_BIT :: 8,
    _16_BIT :: 16,
    _32_BIT :: 32,
    _64_BIT :: 64,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkSampleCountFlags :: VkFlags;

VkQueueFlagBits :: enum {
    GRAPHICS_BIT :: 1,
    COMPUTE_BIT :: 2,
    TRANSFER_BIT :: 4,
    SPARSE_BINDING_BIT :: 8,
    PROTECTED_BIT :: 16,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkQueueFlags :: VkFlags;

VkMemoryPropertyFlagBits :: enum {
    DEVICE_LOCAL_BIT :: 1,
    HOST_VISIBLE_BIT :: 2,
    HOST_COHERENT_BIT :: 4,
    HOST_CACHED_BIT :: 8,
    LAZILY_ALLOCATED_BIT :: 16,
    PROTECTED_BIT :: 32,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkMemoryPropertyFlags :: VkFlags;

VkMemoryHeapFlagBits :: enum {
    DEVICE_LOCAL_BIT :: 1,
    MULTI_INSTANCE_BIT :: 2,
    MULTI_INSTANCE_BIT_KHR :: 2,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkMemoryHeapFlags :: VkFlags;

VkDeviceCreateFlags :: VkFlags;

VkDeviceQueueCreateFlagBits :: enum {
    CREATE_PROTECTED_BIT :: 1,
    CREATE_FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkDeviceQueueCreateFlags :: VkFlags;

VkPipelineStageFlagBits :: enum {
    TOP_OF_PIPE_BIT :: 1,
    DRAW_INDIRECT_BIT :: 2,
    VERTEX_INPUT_BIT :: 4,
    VERTEX_SHADER_BIT :: 8,
    TESSELLATION_CONTROL_SHADER_BIT :: 16,
    TESSELLATION_EVALUATION_SHADER_BIT :: 32,
    GEOMETRY_SHADER_BIT :: 64,
    FRAGMENT_SHADER_BIT :: 128,
    EARLY_FRAGMENT_TESTS_BIT :: 256,
    LATE_FRAGMENT_TESTS_BIT :: 512,
    COLOR_ATTACHMENT_OUTPUT_BIT :: 1024,
    COMPUTE_SHADER_BIT :: 2048,
    TRANSFER_BIT :: 4096,
    BOTTOM_OF_PIPE_BIT :: 8192,
    HOST_BIT :: 16384,
    ALL_GRAPHICS_BIT :: 32768,
    ALL_COMMANDS_BIT :: 65536,
    TRANSFORM_FEEDBACK_BIT_EXT :: 16777216,
    CONDITIONAL_RENDERING_BIT_EXT :: 262144,
    COMMAND_PROCESS_BIT_NVX :: 131072,
    SHADING_RATE_IMAGE_BIT_NV :: 4194304,
    RAY_TRACING_SHADER_BIT_NV :: 2097152,
    ACCELERATION_STRUCTURE_BUILD_BIT_NV :: 33554432,
    TASK_SHADER_BIT_NV :: 524288,
    MESH_SHADER_BIT_NV :: 1048576,
    FRAGMENT_DENSITY_PROCESS_BIT_EXT :: 8388608,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkPipelineStageFlags :: VkFlags;

VkMemoryMapFlags :: VkFlags;

VkImageAspectFlagBits :: enum {
    COLOR_BIT :: 1,
    DEPTH_BIT :: 2,
    STENCIL_BIT :: 4,
    METADATA_BIT :: 8,
    PLANE_0_BIT :: 16,
    PLANE_1_BIT :: 32,
    PLANE_2_BIT :: 64,
    MEMORY_PLANE_0_BIT_EXT :: 128,
    MEMORY_PLANE_1_BIT_EXT :: 256,
    MEMORY_PLANE_2_BIT_EXT :: 512,
    MEMORY_PLANE_3_BIT_EXT :: 1024,
    PLANE_0_BIT_KHR :: 16,
    PLANE_1_BIT_KHR :: 32,
    PLANE_2_BIT_KHR :: 64,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkImageAspectFlags :: VkFlags;

VkSparseImageFormatFlagBits :: enum {
    SINGLE_MIPTAIL_BIT :: 1,
    ALIGNED_MIP_SIZE_BIT :: 2,
    NONSTANDARD_BLOCK_SIZE_BIT :: 4,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkSparseImageFormatFlags :: VkFlags;

VkSparseMemoryBindFlagBits :: enum {
    BIND_METADATA_BIT :: 1,
    BIND_FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkSparseMemoryBindFlags :: VkFlags;

VkFenceCreateFlagBits :: enum {
    SIGNALED_BIT :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkFenceCreateFlags :: VkFlags;

VkSemaphoreCreateFlags :: VkFlags;

VkEventCreateFlags :: VkFlags;

VkQueryPoolCreateFlags :: VkFlags;

VkQueryPipelineStatisticFlagBits :: enum {
    INPUT_ASSEMBLY_VERTICES_BIT :: 1,
    INPUT_ASSEMBLY_PRIMITIVES_BIT :: 2,
    VERTEX_SHADER_INVOCATIONS_BIT :: 4,
    GEOMETRY_SHADER_INVOCATIONS_BIT :: 8,
    GEOMETRY_SHADER_PRIMITIVES_BIT :: 16,
    CLIPPING_INVOCATIONS_BIT :: 32,
    CLIPPING_PRIMITIVES_BIT :: 64,
    FRAGMENT_SHADER_INVOCATIONS_BIT :: 128,
    TESSELLATION_CONTROL_SHADER_PATCHES_BIT :: 256,
    TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT :: 512,
    COMPUTE_SHADER_INVOCATIONS_BIT :: 1024,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkQueryPipelineStatisticFlags :: VkFlags;

VkQueryResultFlagBits :: enum {
    _64_BIT :: 1,
    WAIT_BIT :: 2,
    WITH_AVAILABILITY_BIT :: 4,
    PARTIAL_BIT :: 8,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkQueryResultFlags :: VkFlags;

VkBufferCreateFlagBits :: enum {
    SPARSE_BINDING_BIT :: 1,
    SPARSE_RESIDENCY_BIT :: 2,
    SPARSE_ALIASED_BIT :: 4,
    PROTECTED_BIT :: 8,
    DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT :: 16,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkBufferCreateFlags :: VkFlags;

VkBufferUsageFlagBits :: enum {
    TRANSFER_SRC_BIT :: 1,
    TRANSFER_DST_BIT :: 2,
    UNIFORM_TEXEL_BUFFER_BIT :: 4,
    STORAGE_TEXEL_BUFFER_BIT :: 8,
    UNIFORM_BUFFER_BIT :: 16,
    STORAGE_BUFFER_BIT :: 32,
    INDEX_BUFFER_BIT :: 64,
    VERTEX_BUFFER_BIT :: 128,
    INDIRECT_BUFFER_BIT :: 256,
    TRANSFORM_FEEDBACK_BUFFER_BIT_EXT :: 2048,
    TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT :: 4096,
    CONDITIONAL_RENDERING_BIT_EXT :: 512,
    RAY_TRACING_BIT_NV :: 1024,
    SHADER_DEVICE_ADDRESS_BIT_EXT :: 131072,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkBufferUsageFlags :: VkFlags;

VkBufferViewCreateFlags :: VkFlags;

VkImageViewCreateFlagBits :: enum {
    FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkImageViewCreateFlags :: VkFlags;

VkShaderModuleCreateFlags :: VkFlags;

VkPipelineCacheCreateFlags :: VkFlags;

VkPipelineCreateFlagBits :: enum {
    DISABLE_OPTIMIZATION_BIT :: 1,
    ALLOW_DERIVATIVES_BIT :: 2,
    DERIVATIVE_BIT :: 4,
    VIEW_INDEX_FROM_DEVICE_INDEX_BIT :: 8,
    DISPATCH_BASE :: 16,
    DEFER_COMPILE_BIT_NV :: 32,
    VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR :: 8,
    DISPATCH_BASE_KHR :: 16,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkPipelineCreateFlags :: VkFlags;

VkPipelineShaderStageCreateFlags :: VkFlags;

VkShaderStageFlagBits :: enum {
    VERTEX_BIT :: 1,
    TESSELLATION_CONTROL_BIT :: 2,
    TESSELLATION_EVALUATION_BIT :: 4,
    GEOMETRY_BIT :: 8,
    FRAGMENT_BIT :: 16,
    COMPUTE_BIT :: 32,
    ALL_GRAPHICS :: 31,
    ALL :: 2147483647,
    RAYGEN_BIT_NV :: 256,
    ANY_HIT_BIT_NV :: 512,
    CLOSEST_HIT_BIT_NV :: 1024,
    MISS_BIT_NV :: 2048,
    INTERSECTION_BIT_NV :: 4096,
    CALLABLE_BIT_NV :: 8192,
    TASK_BIT_NV :: 64,
    MESH_BIT_NV :: 128,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkPipelineVertexInputStateCreateFlags :: VkFlags;

VkPipelineInputAssemblyStateCreateFlags :: VkFlags;

VkPipelineTessellationStateCreateFlags :: VkFlags;

VkPipelineViewportStateCreateFlags :: VkFlags;

VkPipelineRasterizationStateCreateFlags :: VkFlags;

VkCullModeFlagBits :: enum {
    NONE :: 0,
    FRONT_BIT :: 1,
    BACK_BIT :: 2,
    FRONT_AND_BACK :: 3,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkCullModeFlags :: VkFlags;

VkPipelineMultisampleStateCreateFlags :: VkFlags;

VkPipelineDepthStencilStateCreateFlags :: VkFlags;

VkPipelineColorBlendStateCreateFlags :: VkFlags;

VkColorComponentFlagBits :: enum {
    R_BIT :: 1,
    G_BIT :: 2,
    B_BIT :: 4,
    A_BIT :: 8,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkColorComponentFlags :: VkFlags;

VkPipelineDynamicStateCreateFlags :: VkFlags;

VkPipelineLayoutCreateFlags :: VkFlags;

VkShaderStageFlags :: VkFlags;

VkSamplerCreateFlagBits :: enum {
    SUBSAMPLED_BIT_EXT :: 1,
    SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT :: 2,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkSamplerCreateFlags :: VkFlags;

VkDescriptorSetLayoutCreateFlagBits :: enum {
    PUSH_DESCRIPTOR_BIT_KHR :: 1,
    UPDATE_AFTER_BIND_POOL_BIT_EXT :: 2,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkDescriptorSetLayoutCreateFlags :: VkFlags;

VkDescriptorPoolCreateFlagBits :: enum {
    FREE_DESCRIPTOR_SET_BIT :: 1,
    UPDATE_AFTER_BIND_BIT_EXT :: 2,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkDescriptorPoolCreateFlags :: VkFlags;

VkDescriptorPoolResetFlags :: VkFlags;

VkFramebufferCreateFlagBits :: enum {
    IMAGELESS_BIT_KHR :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkFramebufferCreateFlags :: VkFlags;

VkRenderPassCreateFlags :: VkFlags;

VkAttachmentDescriptionFlagBits :: enum {
    MAY_ALIAS_BIT :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkAttachmentDescriptionFlags :: VkFlags;

VkSubpassDescriptionFlagBits :: enum {
    PER_VIEW_ATTRIBUTES_BIT_NVX :: 1,
    PER_VIEW_POSITION_X_ONLY_BIT_NVX :: 2,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkSubpassDescriptionFlags :: VkFlags;

VkAccessFlagBits :: enum {
    INDIRECT_COMMAND_READ_BIT :: 1,
    INDEX_READ_BIT :: 2,
    VERTEX_ATTRIBUTE_READ_BIT :: 4,
    UNIFORM_READ_BIT :: 8,
    INPUT_ATTACHMENT_READ_BIT :: 16,
    SHADER_READ_BIT :: 32,
    SHADER_WRITE_BIT :: 64,
    COLOR_ATTACHMENT_READ_BIT :: 128,
    COLOR_ATTACHMENT_WRITE_BIT :: 256,
    DEPTH_STENCIL_ATTACHMENT_READ_BIT :: 512,
    DEPTH_STENCIL_ATTACHMENT_WRITE_BIT :: 1024,
    TRANSFER_READ_BIT :: 2048,
    TRANSFER_WRITE_BIT :: 4096,
    HOST_READ_BIT :: 8192,
    HOST_WRITE_BIT :: 16384,
    MEMORY_READ_BIT :: 32768,
    MEMORY_WRITE_BIT :: 65536,
    TRANSFORM_FEEDBACK_WRITE_BIT_EXT :: 33554432,
    TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT :: 67108864,
    TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT :: 134217728,
    CONDITIONAL_RENDERING_READ_BIT_EXT :: 1048576,
    COMMAND_PROCESS_READ_BIT_NVX :: 131072,
    COMMAND_PROCESS_WRITE_BIT_NVX :: 262144,
    COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT :: 524288,
    SHADING_RATE_IMAGE_READ_BIT_NV :: 8388608,
    ACCELERATION_STRUCTURE_READ_BIT_NV :: 2097152,
    ACCELERATION_STRUCTURE_WRITE_BIT_NV :: 4194304,
    FRAGMENT_DENSITY_MAP_READ_BIT_EXT :: 16777216,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkAccessFlags :: VkFlags;

VkDependencyFlagBits :: enum {
    BY_REGION_BIT :: 1,
    DEVICE_GROUP_BIT :: 4,
    VIEW_LOCAL_BIT :: 2,
    VIEW_LOCAL_BIT_KHR :: 2,
    DEVICE_GROUP_BIT_KHR :: 4,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkDependencyFlags :: VkFlags;

VkCommandPoolCreateFlagBits :: enum {
    CREATE_TRANSIENT_BIT :: 1,
    CREATE_RESET_COMMAND_BUFFER_BIT :: 2,
    CREATE_PROTECTED_BIT :: 4,
    CREATE_FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkCommandPoolCreateFlags :: VkFlags;

VkCommandPoolResetFlagBits :: enum {
    RELEASE_RESOURCES_BIT :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkCommandPoolResetFlags :: VkFlags;

VkCommandBufferUsageFlagBits :: enum {
    ONE_TIME_SUBMIT_BIT :: 1,
    RENDER_PASS_CONTINUE_BIT :: 2,
    SIMULTANEOUS_USE_BIT :: 4,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkCommandBufferUsageFlags :: VkFlags;

VkQueryControlFlagBits :: enum {
    PRECISE_BIT :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkQueryControlFlags :: VkFlags;

VkCommandBufferResetFlagBits :: enum {
    RELEASE_RESOURCES_BIT :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkCommandBufferResetFlags :: VkFlags;

VkStencilFaceFlagBits :: enum {
    FACE_FRONT_BIT :: 1,
    FACE_BACK_BIT :: 2,
    FRONT_AND_BACK :: 3,
    FACE_FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkStencilFaceFlags :: VkFlags;

VkApplicationInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    pApplicationName: *u8,
    applicationVersion: u32,
    pEngineName: *u8,
    engineVersion: u32,
    apiVersion: u32,
};

VkInstanceCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkInstanceCreateFlags,
    pApplicationInfo: *VkApplicationInfo,
    enabledLayerCount: u32,
    ppEnabledLayerNames: **u8,
    enabledExtensionCount: u32,
    ppEnabledExtensionNames: **u8,
};

PFN_vkAllocationFunction :: *fn (_0: *u8, _1: usize, _2: usize, _3: VkSystemAllocationScope) *u8;

PFN_vkReallocationFunction :: *fn (_0: *u8, _1: *u8, _2: usize, _3: usize, _4: VkSystemAllocationScope) *u8;

PFN_vkFreeFunction :: *fn (_0: *u8, _1: *u8) ;

PFN_vkInternalAllocationNotification :: *fn (_0: *u8, _1: usize, _2: VkInternalAllocationType, _3: VkSystemAllocationScope) ;

PFN_vkInternalFreeNotification :: *fn (_0: *u8, _1: usize, _2: VkInternalAllocationType, _3: VkSystemAllocationScope) ;

VkAllocationCallbacks :: struct {
    pUserData: *u8,
    pfnAllocation: PFN_vkAllocationFunction,
    pfnReallocation: PFN_vkReallocationFunction,
    pfnFree: PFN_vkFreeFunction,
    pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pfnInternalFree: PFN_vkInternalFreeNotification,
};

VkPhysicalDeviceFeatures :: struct {
    robustBufferAccess: VkBool32,
    fullDrawIndexUint32: VkBool32,
    imageCubeArray: VkBool32,
    independentBlend: VkBool32,
    geometryShader: VkBool32,
    tessellationShader: VkBool32,
    sampleRateShading: VkBool32,
    dualSrcBlend: VkBool32,
    logicOp: VkBool32,
    multiDrawIndirect: VkBool32,
    drawIndirectFirstInstance: VkBool32,
    depthClamp: VkBool32,
    depthBiasClamp: VkBool32,
    fillModeNonSolid: VkBool32,
    depthBounds: VkBool32,
    wideLines: VkBool32,
    largePoints: VkBool32,
    alphaToOne: VkBool32,
    multiViewport: VkBool32,
    samplerAnisotropy: VkBool32,
    textureCompressionETC2: VkBool32,
    textureCompressionASTC_LDR: VkBool32,
    textureCompressionBC: VkBool32,
    occlusionQueryPrecise: VkBool32,
    pipelineStatisticsQuery: VkBool32,
    vertexPipelineStoresAndAtomics: VkBool32,
    fragmentStoresAndAtomics: VkBool32,
    shaderTessellationAndGeometryPointSize: VkBool32,
    shaderImageGatherExtended: VkBool32,
    shaderStorageImageExtendedFormats: VkBool32,
    shaderStorageImageMultisample: VkBool32,
    shaderStorageImageReadWithoutFormat: VkBool32,
    shaderStorageImageWriteWithoutFormat: VkBool32,
    shaderUniformBufferArrayDynamicIndexing: VkBool32,
    shaderSampledImageArrayDynamicIndexing: VkBool32,
    shaderStorageBufferArrayDynamicIndexing: VkBool32,
    shaderStorageImageArrayDynamicIndexing: VkBool32,
    shaderClipDistance: VkBool32,
    shaderCullDistance: VkBool32,
    shaderFloat64: VkBool32,
    shaderInt64: VkBool32,
    shaderInt16: VkBool32,
    shaderResourceResidency: VkBool32,
    shaderResourceMinLod: VkBool32,
    sparseBinding: VkBool32,
    sparseResidencyBuffer: VkBool32,
    sparseResidencyImage2D: VkBool32,
    sparseResidencyImage3D: VkBool32,
    sparseResidency2Samples: VkBool32,
    sparseResidency4Samples: VkBool32,
    sparseResidency8Samples: VkBool32,
    sparseResidency16Samples: VkBool32,
    sparseResidencyAliased: VkBool32,
    variableMultisampleRate: VkBool32,
    inheritedQueries: VkBool32,
};

VkFormatProperties :: struct {
    linearTilingFeatures: VkFormatFeatureFlags,
    optimalTilingFeatures: VkFormatFeatureFlags,
    bufferFeatures: VkFormatFeatureFlags,
};

VkExtent3D :: struct {
    width: u32,
    height: u32,
    depth: u32,
};

VkImageFormatProperties :: struct {
    maxExtent: VkExtent3D,
    maxMipLevels: u32,
    maxArrayLayers: u32,
    sampleCounts: VkSampleCountFlags,
    maxResourceSize: VkDeviceSize,
};

VkPhysicalDeviceLimits :: struct {
    maxImageDimension1D: u32,
    maxImageDimension2D: u32,
    maxImageDimension3D: u32,
    maxImageDimensionCube: u32,
    maxImageArrayLayers: u32,
    maxTexelBufferElements: u32,
    maxUniformBufferRange: u32,
    maxStorageBufferRange: u32,
    maxPushConstantsSize: u32,
    maxMemoryAllocationCount: u32,
    maxSamplerAllocationCount: u32,
    bufferImageGranularity: VkDeviceSize,
    sparseAddressSpaceSize: VkDeviceSize,
    maxBoundDescriptorSets: u32,
    maxPerStageDescriptorSamplers: u32,
    maxPerStageDescriptorUniformBuffers: u32,
    maxPerStageDescriptorStorageBuffers: u32,
    maxPerStageDescriptorSampledImages: u32,
    maxPerStageDescriptorStorageImages: u32,
    maxPerStageDescriptorInputAttachments: u32,
    maxPerStageResources: u32,
    maxDescriptorSetSamplers: u32,
    maxDescriptorSetUniformBuffers: u32,
    maxDescriptorSetUniformBuffersDynamic: u32,
    maxDescriptorSetStorageBuffers: u32,
    maxDescriptorSetStorageBuffersDynamic: u32,
    maxDescriptorSetSampledImages: u32,
    maxDescriptorSetStorageImages: u32,
    maxDescriptorSetInputAttachments: u32,
    maxVertexInputAttributes: u32,
    maxVertexInputBindings: u32,
    maxVertexInputAttributeOffset: u32,
    maxVertexInputBindingStride: u32,
    maxVertexOutputComponents: u32,
    maxTessellationGenerationLevel: u32,
    maxTessellationPatchSize: u32,
    maxTessellationControlPerVertexInputComponents: u32,
    maxTessellationControlPerVertexOutputComponents: u32,
    maxTessellationControlPerPatchOutputComponents: u32,
    maxTessellationControlTotalOutputComponents: u32,
    maxTessellationEvaluationInputComponents: u32,
    maxTessellationEvaluationOutputComponents: u32,
    maxGeometryShaderInvocations: u32,
    maxGeometryInputComponents: u32,
    maxGeometryOutputComponents: u32,
    maxGeometryOutputVertices: u32,
    maxGeometryTotalOutputComponents: u32,
    maxFragmentInputComponents: u32,
    maxFragmentOutputAttachments: u32,
    maxFragmentDualSrcAttachments: u32,
    maxFragmentCombinedOutputResources: u32,
    maxComputeSharedMemorySize: u32,
    maxComputeWorkGroupCount: [3]u32,
    maxComputeWorkGroupInvocations: u32,
    maxComputeWorkGroupSize: [3]u32,
    subPixelPrecisionBits: u32,
    subTexelPrecisionBits: u32,
    mipmapPrecisionBits: u32,
    maxDrawIndexedIndexValue: u32,
    maxDrawIndirectCount: u32,
    maxSamplerLodBias: f32,
    maxSamplerAnisotropy: f32,
    maxViewports: u32,
    maxViewportDimensions: [2]u32,
    viewportBoundsRange: [2]f32,
    viewportSubPixelBits: u32,
    minMemoryMapAlignment: usize,
    minTexelBufferOffsetAlignment: VkDeviceSize,
    minUniformBufferOffsetAlignment: VkDeviceSize,
    minStorageBufferOffsetAlignment: VkDeviceSize,
    minTexelOffset: s32,
    maxTexelOffset: u32,
    minTexelGatherOffset: s32,
    maxTexelGatherOffset: u32,
    minInterpolationOffset: f32,
    maxInterpolationOffset: f32,
    subPixelInterpolationOffsetBits: u32,
    maxFramebufferWidth: u32,
    maxFramebufferHeight: u32,
    maxFramebufferLayers: u32,
    framebufferColorSampleCounts: VkSampleCountFlags,
    framebufferDepthSampleCounts: VkSampleCountFlags,
    framebufferStencilSampleCounts: VkSampleCountFlags,
    framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    maxColorAttachments: u32,
    sampledImageColorSampleCounts: VkSampleCountFlags,
    sampledImageIntegerSampleCounts: VkSampleCountFlags,
    sampledImageDepthSampleCounts: VkSampleCountFlags,
    sampledImageStencilSampleCounts: VkSampleCountFlags,
    storageImageSampleCounts: VkSampleCountFlags,
    maxSampleMaskWords: u32,
    timestampComputeAndGraphics: VkBool32,
    timestampPeriod: f32,
    maxClipDistances: u32,
    maxCullDistances: u32,
    maxCombinedClipAndCullDistances: u32,
    discreteQueuePriorities: u32,
    pointSizeRange: [2]f32,
    lineWidthRange: [2]f32,
    pointSizeGranularity: f32,
    lineWidthGranularity: f32,
    strictLines: VkBool32,
    standardSampleLocations: VkBool32,
    optimalBufferCopyOffsetAlignment: VkDeviceSize,
    optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    nonCoherentAtomSize: VkDeviceSize,
};

VkPhysicalDeviceSparseProperties :: struct {
    residencyStandard2DBlockShape: VkBool32,
    residencyStandard2DMultisampleBlockShape: VkBool32,
    residencyStandard3DBlockShape: VkBool32,
    residencyAlignedMipSize: VkBool32,
    residencyNonResidentStrict: VkBool32,
};

VkPhysicalDeviceProperties :: struct {
    apiVersion: u32,
    driverVersion: u32,
    vendorID: u32,
    deviceID: u32,
    deviceType: VkPhysicalDeviceType,
    deviceName: [256]u8,
    pipelineCacheUUID: [16]u8,
    limits: VkPhysicalDeviceLimits,
    sparseProperties: VkPhysicalDeviceSparseProperties,
};

VkQueueFamilyProperties :: struct {
    queueFlags: VkQueueFlags,
    queueCount: u32,
    timestampValidBits: u32,
    minImageTransferGranularity: VkExtent3D,
};

VkMemoryType :: struct {
    propertyFlags: VkMemoryPropertyFlags,
    heapIndex: u32,
};

VkMemoryHeap :: struct {
    size: VkDeviceSize,
    flags: VkMemoryHeapFlags,
};

VkPhysicalDeviceMemoryProperties :: struct {
    memoryTypeCount: u32,
    memoryTypes: [32]VkMemoryType,
    memoryHeapCount: u32,
    memoryHeaps: [16]VkMemoryHeap,
};

PFN_vkVoidFunction :: *fn () ;

VkDeviceQueueCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDeviceQueueCreateFlags,
    queueFamilyIndex: u32,
    queueCount: u32,
    pQueuePriorities: *f32,
};

VkDeviceCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDeviceCreateFlags,
    queueCreateInfoCount: u32,
    pQueueCreateInfos: *VkDeviceQueueCreateInfo,
    enabledLayerCount: u32,
    ppEnabledLayerNames: **u8,
    enabledExtensionCount: u32,
    ppEnabledExtensionNames: **u8,
    pEnabledFeatures: *VkPhysicalDeviceFeatures,
};

VkExtensionProperties :: struct {
    extensionName: [256]u8,
    specVersion: u32,
};

VkLayerProperties :: struct {
    layerName: [256]u8,
    specVersion: u32,
    implementationVersion: u32,
    description: [256]s8,
};

VkSubmitInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    waitSemaphoreCount: u32,
    pWaitSemaphores: *VkSemaphore,
    pWaitDstStageMask: *VkPipelineStageFlags,
    commandBufferCount: u32,
    pCommandBuffers: *VkCommandBuffer,
    signalSemaphoreCount: u32,
    pSignalSemaphores: *VkSemaphore,
};

VkMemoryAllocateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    allocationSize: VkDeviceSize,
    memoryTypeIndex: u32,
};

VkMappedMemoryRange :: struct {
    sType: VkStructureType,
    pNext: *u8,
    memory: VkDeviceMemory,
    offset: VkDeviceSize,
    size: VkDeviceSize,
};

VkMemoryRequirements :: struct {
    size: VkDeviceSize,
    alignment: VkDeviceSize,
    memoryTypeBits: u32,
};

VkSparseImageFormatProperties :: struct {
    aspectMask: VkImageAspectFlags,
    imageGranularity: VkExtent3D,
    flags: VkSparseImageFormatFlags,
};

VkSparseImageMemoryRequirements :: struct {
    formatProperties: VkSparseImageFormatProperties,
    imageMipTailFirstLod: u32,
    imageMipTailSize: VkDeviceSize,
    imageMipTailOffset: VkDeviceSize,
    imageMipTailStride: VkDeviceSize,
};

VkSparseMemoryBind :: struct {
    resourceOffset: VkDeviceSize,
    size: VkDeviceSize,
    memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize,
    flags: VkSparseMemoryBindFlags,
};

VkSparseBufferMemoryBindInfo :: struct {
    buffer: VkBuffer,
    bindCount: u32,
    pBinds: *VkSparseMemoryBind,
};

VkSparseImageOpaqueMemoryBindInfo :: struct {
    image: VkImage,
    bindCount: u32,
    pBinds: *VkSparseMemoryBind,
};

VkImageSubresource :: struct {
    aspectMask: VkImageAspectFlags,
    mipLevel: u32,
    arrayLayer: u32,
};

VkOffset3D :: struct {
    x: s32,
    y: s32,
    z: s32,
};

VkSparseImageMemoryBind :: struct {
    subresource: VkImageSubresource,
    offset: VkOffset3D,
    extent: VkExtent3D,
    memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize,
    flags: VkSparseMemoryBindFlags,
};

VkSparseImageMemoryBindInfo :: struct {
    image: VkImage,
    bindCount: u32,
    pBinds: *VkSparseImageMemoryBind,
};

VkBindSparseInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    waitSemaphoreCount: u32,
    pWaitSemaphores: *VkSemaphore,
    bufferBindCount: u32,
    pBufferBinds: *VkSparseBufferMemoryBindInfo,
    imageOpaqueBindCount: u32,
    pImageOpaqueBinds: *VkSparseImageOpaqueMemoryBindInfo,
    imageBindCount: u32,
    pImageBinds: *VkSparseImageMemoryBindInfo,
    signalSemaphoreCount: u32,
    pSignalSemaphores: *VkSemaphore,
};

VkFenceCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkFenceCreateFlags,
};

VkSemaphoreCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkSemaphoreCreateFlags,
};

VkEventCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkEventCreateFlags,
};

VkQueryPoolCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkQueryPoolCreateFlags,
    queryType: VkQueryType,
    queryCount: u32,
    pipelineStatistics: VkQueryPipelineStatisticFlags,
};

VkBufferCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkBufferCreateFlags,
    size: VkDeviceSize,
    usage: VkBufferUsageFlags,
    sharingMode: VkSharingMode,
    queueFamilyIndexCount: u32,
    pQueueFamilyIndices: *u32,
};

VkBufferViewCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkBufferViewCreateFlags,
    buffer: VkBuffer,
    format: VkFormat,
    offset: VkDeviceSize,
    range: VkDeviceSize,
};

VkImageCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkImageCreateFlags,
    imageType: VkImageType,
    format: VkFormat,
    extent: VkExtent3D,
    mipLevels: u32,
    arrayLayers: u32,
    samples: VkSampleCountFlagBits,
    tiling: VkImageTiling,
    usage: VkImageUsageFlags,
    sharingMode: VkSharingMode,
    queueFamilyIndexCount: u32,
    pQueueFamilyIndices: *u32,
    initialLayout: VkImageLayout,
};

VkSubresourceLayout :: struct {
    offset: VkDeviceSize,
    size: VkDeviceSize,
    rowPitch: VkDeviceSize,
    arrayPitch: VkDeviceSize,
    depthPitch: VkDeviceSize,
};

VkComponentMapping :: struct {
    r: VkComponentSwizzle,
    g: VkComponentSwizzle,
    b: VkComponentSwizzle,
    a: VkComponentSwizzle,
};

VkImageSubresourceRange :: struct {
    aspectMask: VkImageAspectFlags,
    baseMipLevel: u32,
    levelCount: u32,
    baseArrayLayer: u32,
    layerCount: u32,
};

VkImageViewCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkImageViewCreateFlags,
    image: VkImage,
    viewType: VkImageViewType,
    format: VkFormat,
    components: VkComponentMapping,
    subresourceRange: VkImageSubresourceRange,
};

VkShaderModuleCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkShaderModuleCreateFlags,
    codeSize: usize,
    pCode: *u8,
};

VkPipelineCacheCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineCacheCreateFlags,
    initialDataSize: usize,
    pInitialData: *u8,
};

VkSpecializationMapEntry :: struct {
    constantID: u32,
    offset: u32,
    size: usize,
};

VkSpecializationInfo :: struct {
    mapEntryCount: u32,
    pMapEntries: *VkSpecializationMapEntry,
    dataSize: usize,
    pData: *u8,
};

VkPipelineShaderStageCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineShaderStageCreateFlags,
    stage: VkShaderStageFlagBits,
    module: VkShaderModule,
    pName: *u8,
    pSpecializationInfo: *VkSpecializationInfo,
};

VkVertexInputBindingDescription :: struct {
    binding: u32,
    stride: u32,
    inputRate: VkVertexInputRate,
};

VkVertexInputAttributeDescription :: struct {
    location: u32,
    binding: u32,
    format: VkFormat,
    offset: u32,
};

VkPipelineVertexInputStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineVertexInputStateCreateFlags,
    vertexBindingDescriptionCount: u32,
    pVertexBindingDescriptions: *VkVertexInputBindingDescription,
    vertexAttributeDescriptionCount: u32,
    pVertexAttributeDescriptions: *VkVertexInputAttributeDescription,
};

VkPipelineInputAssemblyStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineInputAssemblyStateCreateFlags,
    topology: VkPrimitiveTopology,
    primitiveRestartEnable: VkBool32,
};

VkPipelineTessellationStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineTessellationStateCreateFlags,
    patchControlPoints: u32,
};

VkViewport :: struct {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    minDepth: f32,
    maxDepth: f32,
};

VkOffset2D :: struct {
    x: s32,
    y: s32,
};

VkExtent2D :: struct {
    width: u32,
    height: u32,
};

VkRect2D :: struct {
    offset: VkOffset2D,
    extent: VkExtent2D,
};

VkPipelineViewportStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineViewportStateCreateFlags,
    viewportCount: u32,
    pViewports: *VkViewport,
    scissorCount: u32,
    pScissors: *VkRect2D,
};

VkPipelineRasterizationStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineRasterizationStateCreateFlags,
    depthClampEnable: VkBool32,
    rasterizerDiscardEnable: VkBool32,
    polygonMode: VkPolygonMode,
    cullMode: VkCullModeFlags,
    frontFace: VkFrontFace,
    depthBiasEnable: VkBool32,
    depthBiasConstantFactor: f32,
    depthBiasClamp: f32,
    depthBiasSlopeFactor: f32,
    lineWidth: f32,
};

VkPipelineMultisampleStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineMultisampleStateCreateFlags,
    rasterizationSamples: VkSampleCountFlagBits,
    sampleShadingEnable: VkBool32,
    minSampleShading: f32,
    pSampleMask: *VkSampleMask,
    alphaToCoverageEnable: VkBool32,
    alphaToOneEnable: VkBool32,
};

VkStencilOpState :: struct {
    failOp: VkStencilOp,
    passOp: VkStencilOp,
    depthFailOp: VkStencilOp,
    compareOp: VkCompareOp,
    compareMask: u32,
    writeMask: u32,
    reference: u32,
};

VkPipelineDepthStencilStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineDepthStencilStateCreateFlags,
    depthTestEnable: VkBool32,
    depthWriteEnable: VkBool32,
    depthCompareOp: VkCompareOp,
    depthBoundsTestEnable: VkBool32,
    stencilTestEnable: VkBool32,
    front: VkStencilOpState,
    back: VkStencilOpState,
    minDepthBounds: f32,
    maxDepthBounds: f32,
};

VkPipelineColorBlendAttachmentState :: struct {
    blendEnable: VkBool32,
    srcColorBlendFactor: VkBlendFactor,
    dstColorBlendFactor: VkBlendFactor,
    colorBlendOp: VkBlendOp,
    srcAlphaBlendFactor: VkBlendFactor,
    dstAlphaBlendFactor: VkBlendFactor,
    alphaBlendOp: VkBlendOp,
    colorWriteMask: VkColorComponentFlags,
};

VkPipelineColorBlendStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineColorBlendStateCreateFlags,
    logicOpEnable: VkBool32,
    logicOp: VkLogicOp,
    attachmentCount: u32,
    pAttachments: *VkPipelineColorBlendAttachmentState,
    blendConstants: [4]f32,
};

VkPipelineDynamicStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineDynamicStateCreateFlags,
    dynamicStateCount: u32,
    pDynamicStates: *VkDynamicState,
};

VkGraphicsPipelineCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineCreateFlags,
    stageCount: u32,
    pStages: *VkPipelineShaderStageCreateInfo,
    pVertexInputState: *VkPipelineVertexInputStateCreateInfo,
    pInputAssemblyState: *VkPipelineInputAssemblyStateCreateInfo,
    pTessellationState: *VkPipelineTessellationStateCreateInfo,
    pViewportState: *VkPipelineViewportStateCreateInfo,
    pRasterizationState: *VkPipelineRasterizationStateCreateInfo,
    pMultisampleState: *VkPipelineMultisampleStateCreateInfo,
    pDepthStencilState: *VkPipelineDepthStencilStateCreateInfo,
    pColorBlendState: *VkPipelineColorBlendStateCreateInfo,
    pDynamicState: *VkPipelineDynamicStateCreateInfo,
    layout: VkPipelineLayout,
    renderPass: VkRenderPass,
    subpass: u32,
    basePipelineHandle: VkPipeline,
    basePipelineIndex: s32,
};

VkComputePipelineCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineCreateFlags,
    stage: VkPipelineShaderStageCreateInfo,
    layout: VkPipelineLayout,
    basePipelineHandle: VkPipeline,
    basePipelineIndex: s32,
};

VkPushConstantRange :: struct {
    stageFlags: VkShaderStageFlags,
    offset: u32,
    size: u32,
};

VkPipelineLayoutCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineLayoutCreateFlags,
    setLayoutCount: u32,
    pSetLayouts: *VkDescriptorSetLayout,
    pushConstantRangeCount: u32,
    pPushConstantRanges: *VkPushConstantRange,
};

VkSamplerCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkSamplerCreateFlags,
    magFilter: VkFilter,
    minFilter: VkFilter,
    mipmapMode: VkSamplerMipmapMode,
    addressModeU: VkSamplerAddressMode,
    addressModeV: VkSamplerAddressMode,
    addressModeW: VkSamplerAddressMode,
    mipLodBias: f32,
    anisotropyEnable: VkBool32,
    maxAnisotropy: f32,
    compareEnable: VkBool32,
    compareOp: VkCompareOp,
    minLod: f32,
    maxLod: f32,
    borderColor: VkBorderColor,
    unnormalizedCoordinates: VkBool32,
};

VkDescriptorSetLayoutBinding :: struct {
    binding: u32,
    descriptorType: VkDescriptorType,
    descriptorCount: u32,
    stageFlags: VkShaderStageFlags,
    pImmutableSamplers: *VkSampler,
};

VkDescriptorSetLayoutCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDescriptorSetLayoutCreateFlags,
    bindingCount: u32,
    pBindings: *VkDescriptorSetLayoutBinding,
};

VkDescriptorPoolSize :: struct {
    type: VkDescriptorType,
    descriptorCount: u32,
};

VkDescriptorPoolCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDescriptorPoolCreateFlags,
    maxSets: u32,
    poolSizeCount: u32,
    pPoolSizes: *VkDescriptorPoolSize,
};

VkDescriptorSetAllocateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    descriptorPool: VkDescriptorPool,
    descriptorSetCount: u32,
    pSetLayouts: *VkDescriptorSetLayout,
};

VkDescriptorImageInfo :: struct {
    sampler: VkSampler,
    imageView: VkImageView,
    imageLayout: VkImageLayout,
};

VkDescriptorBufferInfo :: struct {
    buffer: VkBuffer,
    offset: VkDeviceSize,
    range: VkDeviceSize,
};

VkWriteDescriptorSet :: struct {
    sType: VkStructureType,
    pNext: *u8,
    dstSet: VkDescriptorSet,
    dstBinding: u32,
    dstArrayElement: u32,
    descriptorCount: u32,
    descriptorType: VkDescriptorType,
    pImageInfo: *VkDescriptorImageInfo,
    pBufferInfo: *VkDescriptorBufferInfo,
    pTexelBufferView: *VkBufferView,
};

VkCopyDescriptorSet :: struct {
    sType: VkStructureType,
    pNext: *u8,
    srcSet: VkDescriptorSet,
    srcBinding: u32,
    srcArrayElement: u32,
    dstSet: VkDescriptorSet,
    dstBinding: u32,
    dstArrayElement: u32,
    descriptorCount: u32,
};

VkFramebufferCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkFramebufferCreateFlags,
    renderPass: VkRenderPass,
    attachmentCount: u32,
    pAttachments: *VkImageView,
    width: u32,
    height: u32,
    layers: u32,
};

VkAttachmentDescription :: struct {
    flags: VkAttachmentDescriptionFlags,
    format: VkFormat,
    samples: VkSampleCountFlagBits,
    loadOp: VkAttachmentLoadOp,
    storeOp: VkAttachmentStoreOp,
    stencilLoadOp: VkAttachmentLoadOp,
    stencilStoreOp: VkAttachmentStoreOp,
    initialLayout: VkImageLayout,
    finalLayout: VkImageLayout,
};

VkAttachmentReference :: struct {
    attachment: u32,
    layout: VkImageLayout,
};

VkSubpassDescription :: struct {
    flags: VkSubpassDescriptionFlags,
    pipelineBindPoint: VkPipelineBindPoint,
    inputAttachmentCount: u32,
    pInputAttachments: *VkAttachmentReference,
    colorAttachmentCount: u32,
    pColorAttachments: *VkAttachmentReference,
    pResolveAttachments: *VkAttachmentReference,
    pDepthStencilAttachment: *VkAttachmentReference,
    preserveAttachmentCount: u32,
    pPreserveAttachments: *u32,
};

VkSubpassDependency :: struct {
    srcSubpass: u32,
    dstSubpass: u32,
    srcStageMask: VkPipelineStageFlags,
    dstStageMask: VkPipelineStageFlags,
    srcAccessMask: VkAccessFlags,
    dstAccessMask: VkAccessFlags,
    dependencyFlags: VkDependencyFlags,
};

VkRenderPassCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkRenderPassCreateFlags,
    attachmentCount: u32,
    pAttachments: *VkAttachmentDescription,
    subpassCount: u32,
    pSubpasses: *VkSubpassDescription,
    dependencyCount: u32,
    pDependencies: *VkSubpassDependency,
};

VkCommandPoolCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkCommandPoolCreateFlags,
    queueFamilyIndex: u32,
};

VkCommandBufferAllocateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    commandPool: VkCommandPool,
    level: VkCommandBufferLevel,
    commandBufferCount: u32,
};

VkCommandBufferInheritanceInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    renderPass: VkRenderPass,
    subpass: u32,
    framebuffer: VkFramebuffer,
    occlusionQueryEnable: VkBool32,
    queryFlags: VkQueryControlFlags,
    pipelineStatistics: VkQueryPipelineStatisticFlags,
};

VkCommandBufferBeginInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkCommandBufferUsageFlags,
    pInheritanceInfo: *VkCommandBufferInheritanceInfo,
};

VkBufferCopy :: struct {
    srcOffset: VkDeviceSize,
    dstOffset: VkDeviceSize,
    size: VkDeviceSize,
};

VkImageSubresourceLayers :: struct {
    aspectMask: VkImageAspectFlags,
    mipLevel: u32,
    baseArrayLayer: u32,
    layerCount: u32,
};

VkImageCopy :: struct {
    srcSubresource: VkImageSubresourceLayers,
    srcOffset: VkOffset3D,
    dstSubresource: VkImageSubresourceLayers,
    dstOffset: VkOffset3D,
    extent: VkExtent3D,
};

VkImageBlit :: struct {
    srcSubresource: VkImageSubresourceLayers,
    srcOffsets: [2]VkOffset3D,
    dstSubresource: VkImageSubresourceLayers,
    dstOffsets: [2]VkOffset3D,
};

VkBufferImageCopy :: struct {
    bufferOffset: VkDeviceSize,
    bufferRowLength: u32,
    bufferImageHeight: u32,
    imageSubresource: VkImageSubresourceLayers,
    imageOffset: VkOffset3D,
    imageExtent: VkExtent3D,
};

// INCOMPLETE
VkClearColorValue :: [4]f32;

VkClearDepthStencilValue :: struct {
    depth: f32,
    stencil: u32,
};

// INCOMPLETE
VkClearValue :: VkClearColorValue;

VkClearAttachment :: struct {
    aspectMask: VkImageAspectFlags,
    colorAttachment: u32,
    clearValue: VkClearValue,
};

VkClearRect :: struct {
    rect: VkRect2D,
    baseArrayLayer: u32,
    layerCount: u32,
};

VkImageResolve :: struct {
    srcSubresource: VkImageSubresourceLayers,
    srcOffset: VkOffset3D,
    dstSubresource: VkImageSubresourceLayers,
    dstOffset: VkOffset3D,
    extent: VkExtent3D,
};

VkMemoryBarrier :: struct {
    sType: VkStructureType,
    pNext: *u8,
    srcAccessMask: VkAccessFlags,
    dstAccessMask: VkAccessFlags,
};

VkBufferMemoryBarrier :: struct {
    sType: VkStructureType,
    pNext: *u8,
    srcAccessMask: VkAccessFlags,
    dstAccessMask: VkAccessFlags,
    srcQueueFamilyIndex: u32,
    dstQueueFamilyIndex: u32,
    buffer: VkBuffer,
    offset: VkDeviceSize,
    size: VkDeviceSize,
};

VkImageMemoryBarrier :: struct {
    sType: VkStructureType,
    pNext: *u8,
    srcAccessMask: VkAccessFlags,
    dstAccessMask: VkAccessFlags,
    oldLayout: VkImageLayout,
    newLayout: VkImageLayout,
    srcQueueFamilyIndex: u32,
    dstQueueFamilyIndex: u32,
    image: VkImage,
    subresourceRange: VkImageSubresourceRange,
};

VkRenderPassBeginInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    renderPass: VkRenderPass,
    framebuffer: VkFramebuffer,
    renderArea: VkRect2D,
    clearValueCount: u32,
    pClearValues: *VkClearValue,
};

VkDispatchIndirectCommand :: struct {
    x: u32,
    y: u32,
    z: u32,
};

VkDrawIndexedIndirectCommand :: struct {
    indexCount: u32,
    instanceCount: u32,
    firstIndex: u32,
    vertexOffset: s32,
    firstInstance: u32,
};

VkDrawIndirectCommand :: struct {
    vertexCount: u32,
    instanceCount: u32,
    firstVertex: u32,
    firstInstance: u32,
};

VkBaseOutStructure :: struct {
    sType: VkStructureType,
    pNext: *u8, // INCOMPLETE
};

VkBaseInStructure :: struct {
    sType: VkStructureType,
    pNext: *u8, // INCOMPLETE
};

PFN_vkCreateInstance :: *fn (_0: *VkInstanceCreateInfo, _1: *VkAllocationCallbacks, _2: *VkInstance) VkResult;

PFN_vkDestroyInstance :: *fn (_0: VkInstance, _1: *VkAllocationCallbacks) ;

PFN_vkEnumeratePhysicalDevices :: *fn (_0: VkInstance, _1: *u32, _2: *VkPhysicalDevice) VkResult;

PFN_vkGetPhysicalDeviceFeatures :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceFeatures) ;

PFN_vkGetPhysicalDeviceFormatProperties :: *fn (_0: VkPhysicalDevice, _1: VkFormat, _2: *VkFormatProperties) ;

PFN_vkGetPhysicalDeviceImageFormatProperties :: *fn (_0: VkPhysicalDevice, _1: VkFormat, _2: VkImageType, _3: VkImageTiling, _4: VkImageUsageFlags, _5: VkImageCreateFlags, _6: *VkImageFormatProperties) VkResult;

PFN_vkGetPhysicalDeviceProperties :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceProperties) ;

PFN_vkGetPhysicalDeviceQueueFamilyProperties :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkQueueFamilyProperties) ;

PFN_vkGetPhysicalDeviceMemoryProperties :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceMemoryProperties) ;

PFN_vkGetInstanceProcAddr :: *fn (_0: VkInstance, _1: *s8) PFN_vkVoidFunction;

PFN_vkGetDeviceProcAddr :: *fn (_0: VkDevice, _1: *s8) PFN_vkVoidFunction;

PFN_vkCreateDevice :: *fn (_0: VkPhysicalDevice, _1: *VkDeviceCreateInfo, _2: *VkAllocationCallbacks, _3: *VkDevice) VkResult;

PFN_vkDestroyDevice :: *fn (_0: VkDevice, _1: *VkAllocationCallbacks) ;

PFN_vkEnumerateInstanceExtensionProperties :: *fn (_0: *s8, _1: *u32, _2: *VkExtensionProperties) VkResult;

PFN_vkEnumerateDeviceExtensionProperties :: *fn (_0: VkPhysicalDevice, _1: *s8, _2: *u32, _3: *VkExtensionProperties) VkResult;

PFN_vkEnumerateInstanceLayerProperties :: *fn (_0: *u32, _1: *VkLayerProperties) VkResult;

PFN_vkEnumerateDeviceLayerProperties :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkLayerProperties) VkResult;

PFN_vkGetDeviceQueue :: *fn (_0: VkDevice, _1: u32, _2: u32, _3: *VkQueue) ;

PFN_vkQueueSubmit :: *fn (_0: VkQueue, _1: u32, _2: *VkSubmitInfo, _3: VkFence) VkResult;

PFN_vkQueueWaitIdle :: *fn (_0: VkQueue) VkResult;

PFN_vkDeviceWaitIdle :: *fn (_0: VkDevice) VkResult;

PFN_vkAllocateMemory :: *fn (_0: VkDevice, _1: *VkMemoryAllocateInfo, _2: *VkAllocationCallbacks, _3: *VkDeviceMemory) VkResult;

PFN_vkFreeMemory :: *fn (_0: VkDevice, _1: VkDeviceMemory, _2: *VkAllocationCallbacks) ;

PFN_vkMapMemory :: *fn (_0: VkDevice, _1: VkDeviceMemory, _2: VkDeviceSize, _3: VkDeviceSize, _4: VkMemoryMapFlags, _5: **u8) VkResult;

PFN_vkUnmapMemory :: *fn (_0: VkDevice, _1: VkDeviceMemory) ;

PFN_vkFlushMappedMemoryRanges :: *fn (_0: VkDevice, _1: u32, _2: *VkMappedMemoryRange) VkResult;

PFN_vkInvalidateMappedMemoryRanges :: *fn (_0: VkDevice, _1: u32, _2: *VkMappedMemoryRange) VkResult;

PFN_vkGetDeviceMemoryCommitment :: *fn (_0: VkDevice, _1: VkDeviceMemory, _2: *VkDeviceSize) ;

PFN_vkBindBufferMemory :: *fn (_0: VkDevice, _1: VkBuffer, _2: VkDeviceMemory, _3: VkDeviceSize) VkResult;

PFN_vkBindImageMemory :: *fn (_0: VkDevice, _1: VkImage, _2: VkDeviceMemory, _3: VkDeviceSize) VkResult;

PFN_vkGetBufferMemoryRequirements :: *fn (_0: VkDevice, _1: VkBuffer, _2: *VkMemoryRequirements) ;

PFN_vkGetImageMemoryRequirements :: *fn (_0: VkDevice, _1: VkImage, _2: *VkMemoryRequirements) ;

PFN_vkGetImageSparseMemoryRequirements :: *fn (_0: VkDevice, _1: VkImage, _2: *u32, _3: *VkSparseImageMemoryRequirements) ;

PFN_vkGetPhysicalDeviceSparseImageFormatProperties :: *fn (_0: VkPhysicalDevice, _1: VkFormat, _2: VkImageType, _3: VkSampleCountFlagBits, _4: VkImageUsageFlags, _5: VkImageTiling, _6: *u32, _7: *VkSparseImageFormatProperties) ;

PFN_vkQueueBindSparse :: *fn (_0: VkQueue, _1: u32, _2: *VkBindSparseInfo, _3: VkFence) VkResult;

PFN_vkCreateFence :: *fn (_0: VkDevice, _1: *VkFenceCreateInfo, _2: *VkAllocationCallbacks, _3: *VkFence) VkResult;

PFN_vkDestroyFence :: *fn (_0: VkDevice, _1: VkFence, _2: *VkAllocationCallbacks) ;

PFN_vkResetFences :: *fn (_0: VkDevice, _1: u32, _2: *VkFence) VkResult;

PFN_vkGetFenceStatus :: *fn (_0: VkDevice, _1: VkFence) VkResult;

PFN_vkWaitForFences :: *fn (_0: VkDevice, _1: u32, _2: *VkFence, _3: VkBool32, _4: u64) VkResult;

PFN_vkCreateSemaphore :: *fn (_0: VkDevice, _1: *VkSemaphoreCreateInfo, _2: *VkAllocationCallbacks, _3: *VkSemaphore) VkResult;

PFN_vkDestroySemaphore :: *fn (_0: VkDevice, _1: VkSemaphore, _2: *VkAllocationCallbacks) ;

PFN_vkCreateEvent :: *fn (_0: VkDevice, _1: *VkEventCreateInfo, _2: *VkAllocationCallbacks, _3: *VkEvent) VkResult;

PFN_vkDestroyEvent :: *fn (_0: VkDevice, _1: VkEvent, _2: *VkAllocationCallbacks) ;

PFN_vkGetEventStatus :: *fn (_0: VkDevice, _1: VkEvent) VkResult;

PFN_vkSetEvent :: *fn (_0: VkDevice, _1: VkEvent) VkResult;

PFN_vkResetEvent :: *fn (_0: VkDevice, _1: VkEvent) VkResult;

PFN_vkCreateQueryPool :: *fn (_0: VkDevice, _1: *VkQueryPoolCreateInfo, _2: *VkAllocationCallbacks, _3: *VkQueryPool) VkResult;

PFN_vkDestroyQueryPool :: *fn (_0: VkDevice, _1: VkQueryPool, _2: *VkAllocationCallbacks) ;

PFN_vkGetQueryPoolResults :: *fn (_0: VkDevice, _1: VkQueryPool, _2: u32, _3: u32, _4: usize, _5: *u8, _6: VkDeviceSize, _7: VkQueryResultFlags) VkResult;

PFN_vkCreateBuffer :: *fn (_0: VkDevice, _1: *VkBufferCreateInfo, _2: *VkAllocationCallbacks, _3: *VkBuffer) VkResult;

PFN_vkDestroyBuffer :: *fn (_0: VkDevice, _1: VkBuffer, _2: *VkAllocationCallbacks) ;

PFN_vkCreateBufferView :: *fn (_0: VkDevice, _1: *VkBufferViewCreateInfo, _2: *VkAllocationCallbacks, _3: *VkBufferView) VkResult;

PFN_vkDestroyBufferView :: *fn (_0: VkDevice, _1: VkBufferView, _2: *VkAllocationCallbacks) ;

PFN_vkCreateImage :: *fn (_0: VkDevice, _1: *VkImageCreateInfo, _2: *VkAllocationCallbacks, _3: *VkImage) VkResult;

PFN_vkDestroyImage :: *fn (_0: VkDevice, _1: VkImage, _2: *VkAllocationCallbacks) ;

PFN_vkGetImageSubresourceLayout :: *fn (_0: VkDevice, _1: VkImage, _2: *VkImageSubresource, _3: *VkSubresourceLayout) ;

PFN_vkCreateImageView :: *fn (_0: VkDevice, _1: *VkImageViewCreateInfo, _2: *VkAllocationCallbacks, _3: *VkImageView) VkResult;

PFN_vkDestroyImageView :: *fn (_0: VkDevice, _1: VkImageView, _2: *VkAllocationCallbacks) ;

PFN_vkCreateShaderModule :: *fn (_0: VkDevice, _1: *VkShaderModuleCreateInfo, _2: *VkAllocationCallbacks, _3: *VkShaderModule) VkResult;

PFN_vkDestroyShaderModule :: *fn (_0: VkDevice, _1: VkShaderModule, _2: *VkAllocationCallbacks) ;

PFN_vkCreatePipelineCache :: *fn (_0: VkDevice, _1: *VkPipelineCacheCreateInfo, _2: *VkAllocationCallbacks, _3: *VkPipelineCache) VkResult;

PFN_vkDestroyPipelineCache :: *fn (_0: VkDevice, _1: VkPipelineCache, _2: *VkAllocationCallbacks) ;

PFN_vkGetPipelineCacheData :: *fn (_0: VkDevice, _1: VkPipelineCache, _2: *usize, _3: *u8) VkResult;

PFN_vkMergePipelineCaches :: *fn (_0: VkDevice, _1: VkPipelineCache, _2: u32, _3: *VkPipelineCache) VkResult;

PFN_vkCreateGraphicsPipelines :: *fn (_0: VkDevice, _1: VkPipelineCache, _2: u32, _3: *VkGraphicsPipelineCreateInfo, _4: *VkAllocationCallbacks, _5: *VkPipeline) VkResult;

PFN_vkCreateComputePipelines :: *fn (_0: VkDevice, _1: VkPipelineCache, _2: u32, _3: *VkComputePipelineCreateInfo, _4: *VkAllocationCallbacks, _5: *VkPipeline) VkResult;

PFN_vkDestroyPipeline :: *fn (_0: VkDevice, _1: VkPipeline, _2: *VkAllocationCallbacks) ;

PFN_vkCreatePipelineLayout :: *fn (_0: VkDevice, _1: *VkPipelineLayoutCreateInfo, _2: *VkAllocationCallbacks, _3: *VkPipelineLayout) VkResult;

PFN_vkDestroyPipelineLayout :: *fn (_0: VkDevice, _1: VkPipelineLayout, _2: *VkAllocationCallbacks) ;

PFN_vkCreateSampler :: *fn (_0: VkDevice, _1: *VkSamplerCreateInfo, _2: *VkAllocationCallbacks, _3: *VkSampler) VkResult;

PFN_vkDestroySampler :: *fn (_0: VkDevice, _1: VkSampler, _2: *VkAllocationCallbacks) ;

PFN_vkCreateDescriptorSetLayout :: *fn (_0: VkDevice, _1: *VkDescriptorSetLayoutCreateInfo, _2: *VkAllocationCallbacks, _3: *VkDescriptorSetLayout) VkResult;

PFN_vkDestroyDescriptorSetLayout :: *fn (_0: VkDevice, _1: VkDescriptorSetLayout, _2: *VkAllocationCallbacks) ;

PFN_vkCreateDescriptorPool :: *fn (_0: VkDevice, _1: *VkDescriptorPoolCreateInfo, _2: *VkAllocationCallbacks, _3: *VkDescriptorPool) VkResult;

PFN_vkDestroyDescriptorPool :: *fn (_0: VkDevice, _1: VkDescriptorPool, _2: *VkAllocationCallbacks) ;

PFN_vkResetDescriptorPool :: *fn (_0: VkDevice, _1: VkDescriptorPool, _2: VkDescriptorPoolResetFlags) VkResult;

PFN_vkAllocateDescriptorSets :: *fn (_0: VkDevice, _1: *VkDescriptorSetAllocateInfo, _2: *VkDescriptorSet) VkResult;

PFN_vkFreeDescriptorSets :: *fn (_0: VkDevice, _1: VkDescriptorPool, _2: u32, _3: *VkDescriptorSet) VkResult;

PFN_vkUpdateDescriptorSets :: *fn (_0: VkDevice, _1: u32, _2: *VkWriteDescriptorSet, _3: u32, _4: *VkCopyDescriptorSet) ;

PFN_vkCreateFramebuffer :: *fn (_0: VkDevice, _1: *VkFramebufferCreateInfo, _2: *VkAllocationCallbacks, _3: *VkFramebuffer) VkResult;

PFN_vkDestroyFramebuffer :: *fn (_0: VkDevice, _1: VkFramebuffer, _2: *VkAllocationCallbacks) ;

PFN_vkCreateRenderPass :: *fn (_0: VkDevice, _1: *VkRenderPassCreateInfo, _2: *VkAllocationCallbacks, _3: *VkRenderPass) VkResult;

PFN_vkDestroyRenderPass :: *fn (_0: VkDevice, _1: VkRenderPass, _2: *VkAllocationCallbacks) ;

PFN_vkGetRenderAreaGranularity :: *fn (_0: VkDevice, _1: VkRenderPass, _2: *VkExtent2D) ;

PFN_vkCreateCommandPool :: *fn (_0: VkDevice, _1: *VkCommandPoolCreateInfo, _2: *VkAllocationCallbacks, _3: *VkCommandPool) VkResult;

PFN_vkDestroyCommandPool :: *fn (_0: VkDevice, _1: VkCommandPool, _2: *VkAllocationCallbacks) ;

PFN_vkResetCommandPool :: *fn (_0: VkDevice, _1: VkCommandPool, _2: VkCommandPoolResetFlags) VkResult;

PFN_vkAllocateCommandBuffers :: *fn (_0: VkDevice, _1: *VkCommandBufferAllocateInfo, _2: *VkCommandBuffer) VkResult;

PFN_vkFreeCommandBuffers :: *fn (_0: VkDevice, _1: VkCommandPool, _2: u32, _3: *VkCommandBuffer) ;

PFN_vkBeginCommandBuffer :: *fn (_0: VkCommandBuffer, _1: *VkCommandBufferBeginInfo) VkResult;

PFN_vkEndCommandBuffer :: *fn (_0: VkCommandBuffer) VkResult;

PFN_vkResetCommandBuffer :: *fn (_0: VkCommandBuffer, _1: VkCommandBufferResetFlags) VkResult;

PFN_vkCmdBindPipeline :: *fn (_0: VkCommandBuffer, _1: VkPipelineBindPoint, _2: VkPipeline) ;

PFN_vkCmdSetViewport :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkViewport) ;

PFN_vkCmdSetScissor :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkRect2D) ;

PFN_vkCmdSetLineWidth :: *fn (_0: VkCommandBuffer, _1: f32) ;

PFN_vkCmdSetDepthBias :: *fn (_0: VkCommandBuffer, _1: f32, _2: f32, _3: f32) ;

PFN_vkCmdSetBlendConstants :: *fn (_0: VkCommandBuffer, _1: [4]f32) ;

PFN_vkCmdSetDepthBounds :: *fn (_0: VkCommandBuffer, _1: f32, _2: f32) ;

PFN_vkCmdSetStencilCompareMask :: *fn (_0: VkCommandBuffer, _1: VkStencilFaceFlags, _2: u32) ;

PFN_vkCmdSetStencilWriteMask :: *fn (_0: VkCommandBuffer, _1: VkStencilFaceFlags, _2: u32) ;

PFN_vkCmdSetStencilReference :: *fn (_0: VkCommandBuffer, _1: VkStencilFaceFlags, _2: u32) ;

PFN_vkCmdBindDescriptorSets :: *fn (_0: VkCommandBuffer, _1: VkPipelineBindPoint, _2: VkPipelineLayout, _3: u32, _4: u32, _5: *VkDescriptorSet, _6: u32, _7: *u32) ;

PFN_vkCmdBindIndexBuffer :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkIndexType) ;

PFN_vkCmdBindVertexBuffers :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkBuffer, _4: *VkDeviceSize) ;

PFN_vkCmdDraw :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: u32, _4: u32) ;

PFN_vkCmdDrawIndexed :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: u32, _4: s32, _5: u32) ;

PFN_vkCmdDrawIndirect :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: u32, _4: u32) ;

PFN_vkCmdDrawIndexedIndirect :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: u32, _4: u32) ;

PFN_vkCmdDispatch :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: u32) ;

PFN_vkCmdDispatchIndirect :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize) ;

PFN_vkCmdCopyBuffer :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkBuffer, _3: u32, _4: *VkBufferCopy) ;

PFN_vkCmdCopyImage :: *fn (_0: VkCommandBuffer, _1: VkImage, _2: VkImageLayout, _3: VkImage, _4: VkImageLayout, _5: u32, _6: *VkImageCopy) ;

PFN_vkCmdBlitImage :: *fn (_0: VkCommandBuffer, _1: VkImage, _2: VkImageLayout, _3: VkImage, _4: VkImageLayout, _5: u32, _6: *VkImageBlit, _7: VkFilter) ;

PFN_vkCmdCopyBufferToImage :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkImage, _3: VkImageLayout, _4: u32, _5: *VkBufferImageCopy) ;

PFN_vkCmdCopyImageToBuffer :: *fn (_0: VkCommandBuffer, _1: VkImage, _2: VkImageLayout, _3: VkBuffer, _4: u32, _5: *VkBufferImageCopy) ;

PFN_vkCmdUpdateBuffer :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkDeviceSize, _4: *u8) ;

PFN_vkCmdFillBuffer :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkDeviceSize, _4: u32) ;

PFN_vkCmdClearColorImage :: *fn (_0: VkCommandBuffer, _1: VkImage, _2: VkImageLayout, _3: *VkClearColorValue, _4: u32, _5: *VkImageSubresourceRange) ;

PFN_vkCmdClearDepthStencilImage :: *fn (_0: VkCommandBuffer, _1: VkImage, _2: VkImageLayout, _3: *VkClearDepthStencilValue, _4: u32, _5: *VkImageSubresourceRange) ;

PFN_vkCmdClearAttachments :: *fn (_0: VkCommandBuffer, _1: u32, _2: *VkClearAttachment, _3: u32, _4: *VkClearRect) ;

PFN_vkCmdResolveImage :: *fn (_0: VkCommandBuffer, _1: VkImage, _2: VkImageLayout, _3: VkImage, _4: VkImageLayout, _5: u32, _6: *VkImageResolve) ;

PFN_vkCmdSetEvent :: *fn (_0: VkCommandBuffer, _1: VkEvent, _2: VkPipelineStageFlags) ;

PFN_vkCmdResetEvent :: *fn (_0: VkCommandBuffer, _1: VkEvent, _2: VkPipelineStageFlags) ;

PFN_vkCmdWaitEvents :: *fn (_0: VkCommandBuffer, _1: u32, _2: *VkEvent, _3: VkPipelineStageFlags, _4: VkPipelineStageFlags, _5: u32, _6: *VkMemoryBarrier, _7: u32, _8: *VkBufferMemoryBarrier, _9: u32, _10: *VkImageMemoryBarrier) ;

PFN_vkCmdPipelineBarrier :: *fn (_0: VkCommandBuffer, _1: VkPipelineStageFlags, _2: VkPipelineStageFlags, _3: VkDependencyFlags, _4: u32, _5: *VkMemoryBarrier, _6: u32, _7: *VkBufferMemoryBarrier, _8: u32, _9: *VkImageMemoryBarrier) ;

PFN_vkCmdBeginQuery :: *fn (_0: VkCommandBuffer, _1: VkQueryPool, _2: u32, _3: VkQueryControlFlags) ;

PFN_vkCmdEndQuery :: *fn (_0: VkCommandBuffer, _1: VkQueryPool, _2: u32) ;

PFN_vkCmdResetQueryPool :: *fn (_0: VkCommandBuffer, _1: VkQueryPool, _2: u32, _3: u32) ;

PFN_vkCmdWriteTimestamp :: *fn (_0: VkCommandBuffer, _1: VkPipelineStageFlagBits, _2: VkQueryPool, _3: u32) ;

PFN_vkCmdCopyQueryPoolResults :: *fn (_0: VkCommandBuffer, _1: VkQueryPool, _2: u32, _3: u32, _4: VkBuffer, _5: VkDeviceSize, _6: VkDeviceSize, _7: VkQueryResultFlags) ;

PFN_vkCmdPushConstants :: *fn (_0: VkCommandBuffer, _1: VkPipelineLayout, _2: VkShaderStageFlags, _3: u32, _4: u32, _5: *u8) ;

PFN_vkCmdBeginRenderPass :: *fn (_0: VkCommandBuffer, _1: *VkRenderPassBeginInfo, _2: VkSubpassContents) ;

PFN_vkCmdNextSubpass :: *fn (_0: VkCommandBuffer, _1: VkSubpassContents) ;

PFN_vkCmdEndRenderPass :: *fn (_0: VkCommandBuffer) ;

PFN_vkCmdExecuteCommands :: *fn (_0: VkCommandBuffer, _1: u32, _2: *VkCommandBuffer) ;

vkCreateInstance :: fn (pCreateInfo: *VkInstanceCreateInfo, pAllocator: *VkAllocationCallbacks, pInstance: *VkInstance) VkResult #extern;
vkDestroyInstance :: fn (instance: VkInstance, pAllocator: *VkAllocationCallbacks)  #extern;
vkEnumeratePhysicalDevices :: fn (instance: VkInstance, pPhysicalDeviceCount: *u32, pPhysicalDevices: *VkPhysicalDevice) VkResult #extern;
vkGetPhysicalDeviceFeatures :: fn (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures)  #extern;
vkGetPhysicalDeviceFormatProperties :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties)  #extern;
vkGetPhysicalDeviceImageFormatProperties :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *VkImageFormatProperties) VkResult #extern;
vkGetPhysicalDeviceProperties :: fn (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties)  #extern;
vkGetPhysicalDeviceQueueFamilyProperties :: fn (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties)  #extern;
vkGetPhysicalDeviceMemoryProperties :: fn (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties)  #extern;
vkGetInstanceProcAddr :: fn (instance: VkInstance, pName: *u8) PFN_vkVoidFunction #extern;
vkGetDeviceProcAddr :: fn (device: VkDevice, pName: *u8) PFN_vkVoidFunction #extern;
vkCreateDevice :: fn (physicalDevice: VkPhysicalDevice, pCreateInfo: *VkDeviceCreateInfo, pAllocator: *VkAllocationCallbacks, pDevice: *VkDevice) VkResult #extern;
vkDestroyDevice :: fn (device: VkDevice, pAllocator: *VkAllocationCallbacks)  #extern;
vkEnumerateInstanceExtensionProperties :: fn (pLayerName: *u8, pPropertyCount: *u32, pProperties: *VkExtensionProperties) VkResult #extern;
vkEnumerateDeviceExtensionProperties :: fn (physicalDevice: VkPhysicalDevice, pLayerName: *u8, pPropertyCount: *u32, pProperties: *VkExtensionProperties) VkResult #extern;
vkEnumerateInstanceLayerProperties :: fn (pPropertyCount: *u32, pProperties: *VkLayerProperties) VkResult #extern;
vkEnumerateDeviceLayerProperties :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkLayerProperties) VkResult #extern;
vkGetDeviceQueue :: fn (device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *VkQueue)  #extern;
vkQueueSubmit :: fn (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo, fence: VkFence) VkResult #extern;
vkQueueWaitIdle :: fn (queue: VkQueue) VkResult #extern;
vkDeviceWaitIdle :: fn (device: VkDevice) VkResult #extern;
vkAllocateMemory :: fn (device: VkDevice, pAllocateInfo: *VkMemoryAllocateInfo, pAllocator: *VkAllocationCallbacks, pMemory: *VkDeviceMemory) VkResult #extern;
vkFreeMemory :: fn (device: VkDevice, memory: VkDeviceMemory, pAllocator: *VkAllocationCallbacks)  #extern;
vkMapMemory :: fn (device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: **u8) VkResult #extern;
vkUnmapMemory :: fn (device: VkDevice, memory: VkDeviceMemory)  #extern;
vkFlushMappedMemoryRanges :: fn (device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *VkMappedMemoryRange) VkResult #extern;
vkInvalidateMappedMemoryRanges :: fn (device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *VkMappedMemoryRange) VkResult #extern;
vkGetDeviceMemoryCommitment :: fn (device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *VkDeviceSize)  #extern;
vkBindBufferMemory :: fn (device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) VkResult #extern;
vkBindImageMemory :: fn (device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) VkResult #extern;
vkGetBufferMemoryRequirements :: fn (device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *VkMemoryRequirements)  #extern;
vkGetImageMemoryRequirements :: fn (device: VkDevice, image: VkImage, pMemoryRequirements: *VkMemoryRequirements)  #extern;
vkGetImageSparseMemoryRequirements :: fn (device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements)  #extern;
vkGetPhysicalDeviceSparseImageFormatProperties :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties)  #extern;
vkQueueBindSparse :: fn (queue: VkQueue, bindInfoCount: u32, pBindInfo: *VkBindSparseInfo, fence: VkFence) VkResult #extern;
vkCreateFence :: fn (device: VkDevice, pCreateInfo: *VkFenceCreateInfo, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) VkResult #extern;
vkDestroyFence :: fn (device: VkDevice, fence: VkFence, pAllocator: *VkAllocationCallbacks)  #extern;
vkResetFences :: fn (device: VkDevice, fenceCount: u32, pFences: *VkFence) VkResult #extern;
vkGetFenceStatus :: fn (device: VkDevice, fence: VkFence) VkResult #extern;
vkWaitForFences :: fn (device: VkDevice, fenceCount: u32, pFences: *VkFence, waitAll: VkBool32, timeout: u64) VkResult #extern;
vkCreateSemaphore :: fn (device: VkDevice, pCreateInfo: *VkSemaphoreCreateInfo, pAllocator: *VkAllocationCallbacks, pSemaphore: *VkSemaphore) VkResult #extern;
vkDestroySemaphore :: fn (device: VkDevice, semaphore: VkSemaphore, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateEvent :: fn (device: VkDevice, pCreateInfo: *VkEventCreateInfo, pAllocator: *VkAllocationCallbacks, pEvent: *VkEvent) VkResult #extern;
vkDestroyEvent :: fn (device: VkDevice, event: VkEvent, pAllocator: *VkAllocationCallbacks)  #extern;
vkGetEventStatus :: fn (device: VkDevice, event: VkEvent) VkResult #extern;
vkSetEvent :: fn (device: VkDevice, event: VkEvent) VkResult #extern;
vkResetEvent :: fn (device: VkDevice, event: VkEvent) VkResult #extern;
vkCreateQueryPool :: fn (device: VkDevice, pCreateInfo: *VkQueryPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pQueryPool: *VkQueryPool) VkResult #extern;
vkDestroyQueryPool :: fn (device: VkDevice, queryPool: VkQueryPool, pAllocator: *VkAllocationCallbacks)  #extern;
vkGetQueryPoolResults :: fn (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *u8, stride: VkDeviceSize, flags: VkQueryResultFlags) VkResult #extern;
vkCreateBuffer :: fn (device: VkDevice, pCreateInfo: *VkBufferCreateInfo, pAllocator: *VkAllocationCallbacks, pBuffer: *VkBuffer) VkResult #extern;
vkDestroyBuffer :: fn (device: VkDevice, buffer: VkBuffer, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateBufferView :: fn (device: VkDevice, pCreateInfo: *VkBufferViewCreateInfo, pAllocator: *VkAllocationCallbacks, pView: *VkBufferView) VkResult #extern;
vkDestroyBufferView :: fn (device: VkDevice, bufferView: VkBufferView, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateImage :: fn (device: VkDevice, pCreateInfo: *VkImageCreateInfo, pAllocator: *VkAllocationCallbacks, pImage: *VkImage) VkResult #extern;
vkDestroyImage :: fn (device: VkDevice, image: VkImage, pAllocator: *VkAllocationCallbacks)  #extern;
vkGetImageSubresourceLayout :: fn (device: VkDevice, image: VkImage, pSubresource: *VkImageSubresource, pLayout: *VkSubresourceLayout)  #extern;
vkCreateImageView :: fn (device: VkDevice, pCreateInfo: *VkImageViewCreateInfo, pAllocator: *VkAllocationCallbacks, pView: *VkImageView) VkResult #extern;
vkDestroyImageView :: fn (device: VkDevice, imageView: VkImageView, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateShaderModule :: fn (device: VkDevice, pCreateInfo: *VkShaderModuleCreateInfo, pAllocator: *VkAllocationCallbacks, pShaderModule: *VkShaderModule) VkResult #extern;
vkDestroyShaderModule :: fn (device: VkDevice, shaderModule: VkShaderModule, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreatePipelineCache :: fn (device: VkDevice, pCreateInfo: *VkPipelineCacheCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelineCache: *VkPipelineCache) VkResult #extern;
vkDestroyPipelineCache :: fn (device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *VkAllocationCallbacks)  #extern;
vkGetPipelineCacheData :: fn (device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *usize, pData: *u8) VkResult #extern;
vkMergePipelineCaches :: fn (device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *VkPipelineCache) VkResult #extern;
vkCreateGraphicsPipelines :: fn (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkGraphicsPipelineCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) VkResult #extern;
vkCreateComputePipelines :: fn (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkComputePipelineCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) VkResult #extern;
vkDestroyPipeline :: fn (device: VkDevice, pipeline: VkPipeline, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreatePipelineLayout :: fn (device: VkDevice, pCreateInfo: *VkPipelineLayoutCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelineLayout: *VkPipelineLayout) VkResult #extern;
vkDestroyPipelineLayout :: fn (device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateSampler :: fn (device: VkDevice, pCreateInfo: *VkSamplerCreateInfo, pAllocator: *VkAllocationCallbacks, pSampler: *VkSampler) VkResult #extern;
vkDestroySampler :: fn (device: VkDevice, sampler: VkSampler, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateDescriptorSetLayout :: fn (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pAllocator: *VkAllocationCallbacks, pSetLayout: *VkDescriptorSetLayout) VkResult #extern;
vkDestroyDescriptorSetLayout :: fn (device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateDescriptorPool :: fn (device: VkDevice, pCreateInfo: *VkDescriptorPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorPool: *VkDescriptorPool) VkResult #extern;
vkDestroyDescriptorPool :: fn (device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *VkAllocationCallbacks)  #extern;
vkResetDescriptorPool :: fn (device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) VkResult #extern;
vkAllocateDescriptorSets :: fn (device: VkDevice, pAllocateInfo: *VkDescriptorSetAllocateInfo, pDescriptorSets: *VkDescriptorSet) VkResult #extern;
vkFreeDescriptorSets :: fn (device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *VkDescriptorSet) VkResult #extern;
vkUpdateDescriptorSets :: fn (device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *VkCopyDescriptorSet)  #extern;
vkCreateFramebuffer :: fn (device: VkDevice, pCreateInfo: *VkFramebufferCreateInfo, pAllocator: *VkAllocationCallbacks, pFramebuffer: *VkFramebuffer) VkResult #extern;
vkDestroyFramebuffer :: fn (device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateRenderPass :: fn (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) VkResult #extern;
vkDestroyRenderPass :: fn (device: VkDevice, renderPass: VkRenderPass, pAllocator: *VkAllocationCallbacks)  #extern;
vkGetRenderAreaGranularity :: fn (device: VkDevice, renderPass: VkRenderPass, pGranularity: *VkExtent2D)  #extern;
vkCreateCommandPool :: fn (device: VkDevice, pCreateInfo: *VkCommandPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pCommandPool: *VkCommandPool) VkResult #extern;
vkDestroyCommandPool :: fn (device: VkDevice, commandPool: VkCommandPool, pAllocator: *VkAllocationCallbacks)  #extern;
vkResetCommandPool :: fn (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) VkResult #extern;
vkAllocateCommandBuffers :: fn (device: VkDevice, pAllocateInfo: *VkCommandBufferAllocateInfo, pCommandBuffers: *VkCommandBuffer) VkResult #extern;
vkFreeCommandBuffers :: fn (device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *VkCommandBuffer)  #extern;
vkBeginCommandBuffer :: fn (commandBuffer: VkCommandBuffer, pBeginInfo: *VkCommandBufferBeginInfo) VkResult #extern;
vkEndCommandBuffer :: fn (commandBuffer: VkCommandBuffer) VkResult #extern;
vkResetCommandBuffer :: fn (commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) VkResult #extern;
vkCmdBindPipeline :: fn (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline)  #extern;
vkCmdSetViewport :: fn (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *VkViewport)  #extern;
vkCmdSetScissor :: fn (commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *VkRect2D)  #extern;
vkCmdSetLineWidth :: fn (commandBuffer: VkCommandBuffer, lineWidth: f32)  #extern;
vkCmdSetDepthBias :: fn (commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32)  #extern;
vkCmdSetBlendConstants :: fn (commandBuffer: VkCommandBuffer, blendConstants: [4]f32)  #extern;
vkCmdSetDepthBounds :: fn (commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32)  #extern;
vkCmdSetStencilCompareMask :: fn (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32)  #extern;
vkCmdSetStencilWriteMask :: fn (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32)  #extern;
vkCmdSetStencilReference :: fn (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32)  #extern;
vkCmdBindDescriptorSets :: fn (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *u32)  #extern;
vkCmdBindIndexBuffer :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType)  #extern;
vkCmdBindVertexBuffers :: fn (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize)  #extern;
vkCmdDraw :: fn (commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32)  #extern;
vkCmdDrawIndexed :: fn (commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: s32, firstInstance: u32)  #extern;
vkCmdDrawIndirect :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32)  #extern;
vkCmdDrawIndexedIndirect :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32)  #extern;
vkCmdDispatch :: fn (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32)  #extern;
vkCmdDispatchIndirect :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize)  #extern;
vkCmdCopyBuffer :: fn (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *VkBufferCopy)  #extern;
vkCmdCopyImage :: fn (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageCopy)  #extern;
vkCmdBlitImage :: fn (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageBlit, filter: VkFilter)  #extern;
vkCmdCopyBufferToImage :: fn (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkBufferImageCopy)  #extern;
vkCmdCopyImageToBuffer :: fn (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *VkBufferImageCopy)  #extern;
vkCmdUpdateBuffer :: fn (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *u8)  #extern;
vkCmdFillBuffer :: fn (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32)  #extern;
vkCmdClearColorImage :: fn (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *VkClearColorValue, rangeCount: u32, pRanges: *VkImageSubresourceRange)  #extern;
vkCmdClearDepthStencilImage :: fn (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *VkClearDepthStencilValue, rangeCount: u32, pRanges: *VkImageSubresourceRange)  #extern;
vkCmdClearAttachments :: fn (commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *VkClearAttachment, rectCount: u32, pRects: *VkClearRect)  #extern;
vkCmdResolveImage :: fn (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageResolve)  #extern;
vkCmdSetEvent :: fn (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags)  #extern;
vkCmdResetEvent :: fn (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags)  #extern;
vkCmdWaitEvents :: fn (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *VkImageMemoryBarrier)  #extern;
vkCmdPipelineBarrier :: fn (commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *VkImageMemoryBarrier)  #extern;
vkCmdBeginQuery :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags)  #extern;
vkCmdEndQuery :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32)  #extern;
vkCmdResetQueryPool :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32)  #extern;
vkCmdWriteTimestamp :: fn (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32)  #extern;
vkCmdCopyQueryPoolResults :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags)  #extern;
vkCmdPushConstants :: fn (commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *u8)  #extern;
vkCmdBeginRenderPass :: fn (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, contents: VkSubpassContents)  #extern;
vkCmdNextSubpass :: fn (commandBuffer: VkCommandBuffer, contents: VkSubpassContents)  #extern;
vkCmdEndRenderPass :: fn (commandBuffer: VkCommandBuffer)  #extern;
vkCmdExecuteCommands :: fn (commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *VkCommandBuffer)  #extern;
VkPointClippingBehavior :: enum {
    ALL_CLIP_PLANES :: 0,
    USER_CLIP_PLANES_ONLY :: 1,
    ALL_CLIP_PLANES_KHR :: 0,
    USER_CLIP_PLANES_ONLY_KHR :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkTessellationDomainOrigin :: enum {
    UPPER_LEFT :: 0,
    LOWER_LEFT :: 1,
    UPPER_LEFT_KHR :: 0,
    LOWER_LEFT_KHR :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkSamplerYcbcrModelConversion :: enum {
    RGB_IDENTITY :: 0,
    YCBCR_IDENTITY :: 1,
    YCBCR_709 :: 2,
    YCBCR_601 :: 3,
    YCBCR_2020 :: 4,
    RGB_IDENTITY_KHR :: 0,
    YCBCR_IDENTITY_KHR :: 1,
    YCBCR_709_KHR :: 2,
    YCBCR_601_KHR :: 3,
    YCBCR_2020_KHR :: 4,
    BEGIN_RANGE :: 0,
    END_RANGE :: 4,
    RANGE_SIZE :: 5,
    MAX_ENUM :: 2147483647,
};

VkSamplerYcbcrRange :: enum {
    ITU_FULL :: 0,
    ITU_NARROW :: 1,
    ITU_FULL_KHR :: 0,
    ITU_NARROW_KHR :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkChromaLocation :: enum {
    COSITED_EVEN :: 0,
    MIDPOINT :: 1,
    COSITED_EVEN_KHR :: 0,
    MIDPOINT_KHR :: 1,
    BEGIN_RANGE :: 0,
    END_RANGE :: 1,
    RANGE_SIZE :: 2,
    MAX_ENUM :: 2147483647,
};

VkDescriptorUpdateTemplateType :: enum {
    DESCRIPTOR_SET :: 0,
    PUSH_DESCRIPTORS_KHR :: 1,
    DESCRIPTOR_SET_KHR :: 0,
    BEGIN_RANGE :: 0,
    END_RANGE :: 0,
    RANGE_SIZE :: 1,
    MAX_ENUM :: 2147483647,
};

VkSubgroupFeatureFlagBits :: enum {
    BASIC_BIT :: 1,
    VOTE_BIT :: 2,
    ARITHMETIC_BIT :: 4,
    BALLOT_BIT :: 8,
    SHUFFLE_BIT :: 16,
    SHUFFLE_RELATIVE_BIT :: 32,
    CLUSTERED_BIT :: 64,
    QUAD_BIT :: 128,
    PARTITIONED_BIT_NV :: 256,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkSubgroupFeatureFlags :: VkFlags;

VkPeerMemoryFeatureFlagBits :: enum {
    COPY_SRC_BIT :: 1,
    COPY_DST_BIT :: 2,
    GENERIC_SRC_BIT :: 4,
    GENERIC_DST_BIT :: 8,
    COPY_SRC_BIT_KHR :: 1,
    COPY_DST_BIT_KHR :: 2,
    GENERIC_SRC_BIT_KHR :: 4,
    GENERIC_DST_BIT_KHR :: 8,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkPeerMemoryFeatureFlags :: VkFlags;

VkMemoryAllocateFlagBits :: enum {
    DEVICE_MASK_BIT :: 1,
    DEVICE_MASK_BIT_KHR :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkMemoryAllocateFlags :: VkFlags;

VkCommandPoolTrimFlags :: VkFlags;

VkDescriptorUpdateTemplateCreateFlags :: VkFlags;

VkExternalMemoryHandleTypeFlagBits :: enum {
    OPAQUE_FD_BIT :: 1,
    OPAQUE_WIN32_BIT :: 2,
    OPAQUE_WIN32_KMT_BIT :: 4,
    D3D11_TEXTURE_BIT :: 8,
    D3D11_TEXTURE_KMT_BIT :: 16,
    D3D12_HEAP_BIT :: 32,
    D3D12_RESOURCE_BIT :: 64,
    DMA_BUF_BIT_EXT :: 512,
    ANDROID_HARDWARE_BUFFER_BIT_ANDROID :: 1024,
    HOST_ALLOCATION_BIT_EXT :: 128,
    HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT :: 256,
    OPAQUE_FD_BIT_KHR :: 1,
    OPAQUE_WIN32_BIT_KHR :: 2,
    OPAQUE_WIN32_KMT_BIT_KHR :: 4,
    D3D11_TEXTURE_BIT_KHR :: 8,
    D3D11_TEXTURE_KMT_BIT_KHR :: 16,
    D3D12_HEAP_BIT_KHR :: 32,
    D3D12_RESOURCE_BIT_KHR :: 64,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkExternalMemoryHandleTypeFlags :: VkFlags;

VkExternalMemoryFeatureFlagBits :: enum {
    DEDICATED_ONLY_BIT :: 1,
    EXPORTABLE_BIT :: 2,
    IMPORTABLE_BIT :: 4,
    DEDICATED_ONLY_BIT_KHR :: 1,
    EXPORTABLE_BIT_KHR :: 2,
    IMPORTABLE_BIT_KHR :: 4,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkExternalMemoryFeatureFlags :: VkFlags;

VkExternalFenceHandleTypeFlagBits :: enum {
    OPAQUE_FD_BIT :: 1,
    OPAQUE_WIN32_BIT :: 2,
    OPAQUE_WIN32_KMT_BIT :: 4,
    SYNC_FD_BIT :: 8,
    OPAQUE_FD_BIT_KHR :: 1,
    OPAQUE_WIN32_BIT_KHR :: 2,
    OPAQUE_WIN32_KMT_BIT_KHR :: 4,
    SYNC_FD_BIT_KHR :: 8,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkExternalFenceHandleTypeFlags :: VkFlags;

VkExternalFenceFeatureFlagBits :: enum {
    EXPORTABLE_BIT :: 1,
    IMPORTABLE_BIT :: 2,
    EXPORTABLE_BIT_KHR :: 1,
    IMPORTABLE_BIT_KHR :: 2,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkExternalFenceFeatureFlags :: VkFlags;

VkFenceImportFlagBits :: enum {
    TEMPORARY_BIT :: 1,
    TEMPORARY_BIT_KHR :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkFenceImportFlags :: VkFlags;

VkSemaphoreImportFlagBits :: enum {
    TEMPORARY_BIT :: 1,
    TEMPORARY_BIT_KHR :: 1,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkSemaphoreImportFlags :: VkFlags;

VkExternalSemaphoreHandleTypeFlagBits :: enum {
    OPAQUE_FD_BIT :: 1,
    OPAQUE_WIN32_BIT :: 2,
    OPAQUE_WIN32_KMT_BIT :: 4,
    D3D12_FENCE_BIT :: 8,
    SYNC_FD_BIT :: 16,
    OPAQUE_FD_BIT_KHR :: 1,
    OPAQUE_WIN32_BIT_KHR :: 2,
    OPAQUE_WIN32_KMT_BIT_KHR :: 4,
    D3D12_FENCE_BIT_KHR :: 8,
    SYNC_FD_BIT_KHR :: 16,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkExternalSemaphoreHandleTypeFlags :: VkFlags;

VkExternalSemaphoreFeatureFlagBits :: enum {
    EXPORTABLE_BIT :: 1,
    IMPORTABLE_BIT :: 2,
    EXPORTABLE_BIT_KHR :: 1,
    IMPORTABLE_BIT_KHR :: 2,
    FLAG_BITS_MAX_ENUM :: 2147483647,
};

VkExternalSemaphoreFeatureFlags :: VkFlags;

VkPhysicalDeviceSubgroupProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    subgroupSize: u32,
    supportedStages: VkShaderStageFlags,
    supportedOperations: VkSubgroupFeatureFlags,
    quadOperationsInAllStages: VkBool32,
};

VkBindBufferMemoryInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    buffer: VkBuffer,
    memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize,
};

VkBindImageMemoryInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    image: VkImage,
    memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize,
};

VkPhysicalDevice16BitStorageFeatures :: struct {
    sType: VkStructureType,
    pNext: *u8,
    storageBuffer16BitAccess: VkBool32,
    uniformAndStorageBuffer16BitAccess: VkBool32,
    storagePushConstant16: VkBool32,
    storageInputOutput16: VkBool32,
};

VkMemoryDedicatedRequirements :: struct {
    sType: VkStructureType,
    pNext: *u8,
    prefersDedicatedAllocation: VkBool32,
    requiresDedicatedAllocation: VkBool32,
};

VkMemoryDedicatedAllocateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    image: VkImage,
    buffer: VkBuffer,
};

VkMemoryAllocateFlagsInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkMemoryAllocateFlags,
    deviceMask: u32,
};

VkDeviceGroupRenderPassBeginInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    deviceMask: u32,
    deviceRenderAreaCount: u32,
    pDeviceRenderAreas: *VkRect2D,
};

VkDeviceGroupCommandBufferBeginInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    deviceMask: u32,
};

VkDeviceGroupSubmitInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    waitSemaphoreCount: u32,
    pWaitSemaphoreDeviceIndices: *u32,
    commandBufferCount: u32,
    pCommandBufferDeviceMasks: *u32,
    signalSemaphoreCount: u32,
    pSignalSemaphoreDeviceIndices: *u32,
};

VkDeviceGroupBindSparseInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    resourceDeviceIndex: u32,
    memoryDeviceIndex: u32,
};

VkBindBufferMemoryDeviceGroupInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    deviceIndexCount: u32,
    pDeviceIndices: *u32,
};

VkBindImageMemoryDeviceGroupInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    deviceIndexCount: u32,
    pDeviceIndices: *u32,
    splitInstanceBindRegionCount: u32,
    pSplitInstanceBindRegions: *VkRect2D,
};

VkPhysicalDeviceGroupProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    physicalDeviceCount: u32,
    physicalDevices: [32]VkPhysicalDevice,
    subsetAllocation: VkBool32,
};

VkDeviceGroupDeviceCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    physicalDeviceCount: u32,
    pPhysicalDevices: *VkPhysicalDevice,
};

VkBufferMemoryRequirementsInfo2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    buffer: VkBuffer,
};

VkImageMemoryRequirementsInfo2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    image: VkImage,
};

VkImageSparseMemoryRequirementsInfo2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    image: VkImage,
};

VkMemoryRequirements2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    memoryRequirements: VkMemoryRequirements,
};

VkMemoryRequirements2KHR :: VkMemoryRequirements2;

VkSparseImageMemoryRequirements2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    memoryRequirements: VkSparseImageMemoryRequirements,
};

VkPhysicalDeviceFeatures2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    features: VkPhysicalDeviceFeatures,
};

VkPhysicalDeviceProperties2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    properties: VkPhysicalDeviceProperties,
};

VkFormatProperties2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    formatProperties: VkFormatProperties,
};

VkImageFormatProperties2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    imageFormatProperties: VkImageFormatProperties,
};

VkPhysicalDeviceImageFormatInfo2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    format: VkFormat,
    type: VkImageType,
    tiling: VkImageTiling,
    usage: VkImageUsageFlags,
    flags: VkImageCreateFlags,
};

VkQueueFamilyProperties2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    queueFamilyProperties: VkQueueFamilyProperties,
};

VkPhysicalDeviceMemoryProperties2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    memoryProperties: VkPhysicalDeviceMemoryProperties,
};

VkSparseImageFormatProperties2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    properties: VkSparseImageFormatProperties,
};

VkPhysicalDeviceSparseImageFormatInfo2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    format: VkFormat,
    type: VkImageType,
    samples: VkSampleCountFlagBits,
    usage: VkImageUsageFlags,
    tiling: VkImageTiling,
};

VkPhysicalDevicePointClippingProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    pointClippingBehavior: VkPointClippingBehavior,
};

VkInputAttachmentAspectReference :: struct {
    subpass: u32,
    inputAttachmentIndex: u32,
    aspectMask: VkImageAspectFlags,
};

VkRenderPassInputAttachmentAspectCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    aspectReferenceCount: u32,
    pAspectReferences: *VkInputAttachmentAspectReference,
};

VkImageViewUsageCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    usage: VkImageUsageFlags,
};

VkPipelineTessellationDomainOriginStateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    domainOrigin: VkTessellationDomainOrigin,
};

VkRenderPassMultiviewCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    subpassCount: u32,
    pViewMasks: *u32,
    dependencyCount: u32,
    pViewOffsets: *s32,
    correlationMaskCount: u32,
    pCorrelationMasks: *u32,
};

VkPhysicalDeviceMultiviewFeatures :: struct {
    sType: VkStructureType,
    pNext: *u8,
    multiview: VkBool32,
    multiviewGeometryShader: VkBool32,
    multiviewTessellationShader: VkBool32,
};

VkPhysicalDeviceMultiviewProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxMultiviewViewCount: u32,
    maxMultiviewInstanceIndex: u32,
};

VkPhysicalDeviceVariablePointersFeatures :: struct {
    sType: VkStructureType,
    pNext: *u8,
    variablePointersStorageBuffer: VkBool32,
    variablePointers: VkBool32,
};

VkPhysicalDeviceVariablePointerFeatures :: VkPhysicalDeviceVariablePointersFeatures;

VkPhysicalDeviceProtectedMemoryFeatures :: struct {
    sType: VkStructureType,
    pNext: *u8,
    protectedMemory: VkBool32,
};

VkPhysicalDeviceProtectedMemoryProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    protectedNoFault: VkBool32,
};

VkDeviceQueueInfo2 :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDeviceQueueCreateFlags,
    queueFamilyIndex: u32,
    queueIndex: u32,
};

VkProtectedSubmitInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    protectedSubmit: VkBool32,
};

VkSamplerYcbcrConversionCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    format: VkFormat,
    ycbcrModel: VkSamplerYcbcrModelConversion,
    ycbcrRange: VkSamplerYcbcrRange,
    components: VkComponentMapping,
    xChromaOffset: VkChromaLocation,
    yChromaOffset: VkChromaLocation,
    chromaFilter: VkFilter,
    forceExplicitReconstruction: VkBool32,
};

VkSamplerYcbcrConversionInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    conversion: VkSamplerYcbcrConversion,
};

VkBindImagePlaneMemoryInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    planeAspect: VkImageAspectFlagBits,
};

VkImagePlaneMemoryRequirementsInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    planeAspect: VkImageAspectFlagBits,
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures :: struct {
    sType: VkStructureType,
    pNext: *u8,
    samplerYcbcrConversion: VkBool32,
};

VkSamplerYcbcrConversionImageFormatProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    combinedImageSamplerDescriptorCount: u32,
};

VkDescriptorUpdateTemplateEntry :: struct {
    dstBinding: u32,
    dstArrayElement: u32,
    descriptorCount: u32,
    descriptorType: VkDescriptorType,
    offset: usize,
    stride: usize,
};

VkDescriptorUpdateTemplateCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDescriptorUpdateTemplateCreateFlags,
    descriptorUpdateEntryCount: u32,
    pDescriptorUpdateEntries: *VkDescriptorUpdateTemplateEntry,
    templateType: VkDescriptorUpdateTemplateType,
    descriptorSetLayout: VkDescriptorSetLayout,
    pipelineBindPoint: VkPipelineBindPoint,
    pipelineLayout: VkPipelineLayout,
    set: u32,
};

VkExternalMemoryProperties :: struct {
    externalMemoryFeatures: VkExternalMemoryFeatureFlags,
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags,
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlags,
};

VkPhysicalDeviceExternalImageFormatInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleType: VkExternalMemoryHandleTypeFlagBits,
};

VkExternalImageFormatProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    externalMemoryProperties: VkExternalMemoryProperties,
};

VkPhysicalDeviceExternalBufferInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkBufferCreateFlags,
    usage: VkBufferUsageFlags,
    handleType: VkExternalMemoryHandleTypeFlagBits,
};

VkExternalBufferProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    externalMemoryProperties: VkExternalMemoryProperties,
};

VkPhysicalDeviceIDProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    deviceUUID: [16]u8,
    driverUUID: [16]u8,
    deviceLUID: [8]u8,
    deviceNodeMask: u32,
    deviceLUIDValid: VkBool32,
};

VkExternalMemoryImageCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleTypes: VkExternalMemoryHandleTypeFlags,
};

VkExternalMemoryBufferCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleTypes: VkExternalMemoryHandleTypeFlags,
};

VkExportMemoryAllocateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleTypes: VkExternalMemoryHandleTypeFlags,
};

VkPhysicalDeviceExternalFenceInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleType: VkExternalFenceHandleTypeFlagBits,
};

VkExternalFenceProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags,
    compatibleHandleTypes: VkExternalFenceHandleTypeFlags,
    externalFenceFeatures: VkExternalFenceFeatureFlags,
};

VkExportFenceCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleTypes: VkExternalFenceHandleTypeFlags,
};

VkExportSemaphoreCreateInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleTypes: VkExternalSemaphoreHandleTypeFlags,
};

VkPhysicalDeviceExternalSemaphoreInfo :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleType: VkExternalSemaphoreHandleTypeFlagBits,
};

VkExternalSemaphoreProperties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags,
    compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags,
    externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags,
};

VkPhysicalDeviceMaintenance3Properties :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxPerSetDescriptors: u32,
    maxMemoryAllocationSize: VkDeviceSize,
};

VkDescriptorSetLayoutSupport :: struct {
    sType: VkStructureType,
    pNext: *u8,
    supported: VkBool32,
};

VkPhysicalDeviceShaderDrawParametersFeatures :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderDrawParameters: VkBool32,
};

VkPhysicalDeviceShaderDrawParameterFeatures :: VkPhysicalDeviceShaderDrawParametersFeatures;

PFN_vkEnumerateInstanceVersion :: *fn (_0: *u32) VkResult;

PFN_vkBindBufferMemory2 :: *fn (_0: VkDevice, _1: u32, _2: *VkBindBufferMemoryInfo) VkResult;

PFN_vkBindImageMemory2 :: *fn (_0: VkDevice, _1: u32, _2: *VkBindImageMemoryInfo) VkResult;

PFN_vkGetDeviceGroupPeerMemoryFeatures :: *fn (_0: VkDevice, _1: u32, _2: u32, _3: u32, _4: *VkPeerMemoryFeatureFlags) ;

PFN_vkCmdSetDeviceMask :: *fn (_0: VkCommandBuffer, _1: u32) ;

PFN_vkCmdDispatchBase :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: u32, _4: u32, _5: u32, _6: u32) ;

PFN_vkEnumeratePhysicalDeviceGroups :: *fn (_0: VkInstance, _1: *u32, _2: *VkPhysicalDeviceGroupProperties) VkResult;

PFN_vkGetImageMemoryRequirements2 :: *fn (_0: VkDevice, _1: *VkImageMemoryRequirementsInfo2, _2: *VkMemoryRequirements2) ;

PFN_vkGetBufferMemoryRequirements2 :: *fn (_0: VkDevice, _1: *VkBufferMemoryRequirementsInfo2, _2: *VkMemoryRequirements2) ;

PFN_vkGetImageSparseMemoryRequirements2 :: *fn (_0: VkDevice, _1: *VkImageSparseMemoryRequirementsInfo2, _2: *u32, _3: *VkSparseImageMemoryRequirements2) ;

PFN_vkGetPhysicalDeviceFeatures2 :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceFeatures2) ;

PFN_vkGetPhysicalDeviceProperties2 :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceProperties2) ;

PFN_vkGetPhysicalDeviceFormatProperties2 :: *fn (_0: VkPhysicalDevice, _1: VkFormat, _2: *VkFormatProperties2) ;

PFN_vkGetPhysicalDeviceImageFormatProperties2 :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceImageFormatInfo2, _2: *VkImageFormatProperties2) VkResult;

PFN_vkGetPhysicalDeviceQueueFamilyProperties2 :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkQueueFamilyProperties2) ;

PFN_vkGetPhysicalDeviceMemoryProperties2 :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceMemoryProperties2) ;

PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceSparseImageFormatInfo2, _2: *u32, _3: *VkSparseImageFormatProperties2) ;

PFN_vkTrimCommandPool :: *fn (_0: VkDevice, _1: VkCommandPool, _2: VkCommandPoolTrimFlags) ;

PFN_vkGetDeviceQueue2 :: *fn (_0: VkDevice, _1: *VkDeviceQueueInfo2, _2: *VkQueue) ;

PFN_vkCreateSamplerYcbcrConversion :: *fn (_0: VkDevice, _1: *VkSamplerYcbcrConversionCreateInfo, _2: *VkAllocationCallbacks, _3: *VkSamplerYcbcrConversion) VkResult;

PFN_vkDestroySamplerYcbcrConversion :: *fn (_0: VkDevice, _1: VkSamplerYcbcrConversion, _2: *VkAllocationCallbacks) ;

PFN_vkCreateDescriptorUpdateTemplate :: *fn (_0: VkDevice, _1: *VkDescriptorUpdateTemplateCreateInfo, _2: *VkAllocationCallbacks, _3: *VkDescriptorUpdateTemplate) VkResult;

PFN_vkDestroyDescriptorUpdateTemplate :: *fn (_0: VkDevice, _1: VkDescriptorUpdateTemplate, _2: *VkAllocationCallbacks) ;

PFN_vkUpdateDescriptorSetWithTemplate :: *fn (_0: VkDevice, _1: VkDescriptorSet, _2: VkDescriptorUpdateTemplate, _3: *u8) ;

PFN_vkGetPhysicalDeviceExternalBufferProperties :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceExternalBufferInfo, _2: *VkExternalBufferProperties) ;

PFN_vkGetPhysicalDeviceExternalFenceProperties :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceExternalFenceInfo, _2: *VkExternalFenceProperties) ;

PFN_vkGetPhysicalDeviceExternalSemaphoreProperties :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceExternalSemaphoreInfo, _2: *VkExternalSemaphoreProperties) ;

PFN_vkGetDescriptorSetLayoutSupport :: *fn (_0: VkDevice, _1: *VkDescriptorSetLayoutCreateInfo, _2: *VkDescriptorSetLayoutSupport) ;

vkEnumerateInstanceVersion :: fn (pApiVersion: *u32) VkResult #extern;
vkBindBufferMemory2 :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindBufferMemoryInfo) VkResult #extern;
vkBindImageMemory2 :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindImageMemoryInfo) VkResult #extern;
vkGetDeviceGroupPeerMemoryFeatures :: fn (device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags)  #extern;
vkCmdSetDeviceMask :: fn (commandBuffer: VkCommandBuffer, deviceMask: u32)  #extern;
vkCmdDispatchBase :: fn (commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32)  #extern;
vkEnumeratePhysicalDeviceGroups :: fn (instance: VkInstance, pPhysicalDeviceGroupCount: *u32, pPhysicalDeviceGroupProperties: *VkPhysicalDeviceGroupProperties) VkResult #extern;
vkGetImageMemoryRequirements2 :: fn (device: VkDevice, pInfo: *VkImageMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2)  #extern;
vkGetBufferMemoryRequirements2 :: fn (device: VkDevice, pInfo: *VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2)  #extern;
vkGetImageSparseMemoryRequirements2 :: fn (device: VkDevice, pInfo: *VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2)  #extern;
vkGetPhysicalDeviceFeatures2 :: fn (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures2)  #extern;
vkGetPhysicalDeviceProperties2 :: fn (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties2)  #extern;
vkGetPhysicalDeviceFormatProperties2 :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties2)  #extern;
vkGetPhysicalDeviceImageFormatProperties2 :: fn (physicalDevice: VkPhysicalDevice, pImageFormatInfo: *VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *VkImageFormatProperties2) VkResult #extern;
vkGetPhysicalDeviceQueueFamilyProperties2 :: fn (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties2)  #extern;
vkGetPhysicalDeviceMemoryProperties2 :: fn (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties2)  #extern;
vkGetPhysicalDeviceSparseImageFormatProperties2 :: fn (physicalDevice: VkPhysicalDevice, pFormatInfo: *VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties2)  #extern;
vkTrimCommandPool :: fn (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags)  #extern;
vkGetDeviceQueue2 :: fn (device: VkDevice, pQueueInfo: *VkDeviceQueueInfo2, pQueue: *VkQueue)  #extern;
vkCreateSamplerYcbcrConversion :: fn (device: VkDevice, pCreateInfo: *VkSamplerYcbcrConversionCreateInfo, pAllocator: *VkAllocationCallbacks, pYcbcrConversion: *VkSamplerYcbcrConversion) VkResult #extern;
vkDestroySamplerYcbcrConversion :: fn (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateDescriptorUpdateTemplate :: fn (device: VkDevice, pCreateInfo: *VkDescriptorUpdateTemplateCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate) VkResult #extern;
vkDestroyDescriptorUpdateTemplate :: fn (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *VkAllocationCallbacks)  #extern;
vkUpdateDescriptorSetWithTemplate :: fn (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *u8)  #extern;
vkGetPhysicalDeviceExternalBufferProperties :: fn (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *VkExternalBufferProperties)  #extern;
vkGetPhysicalDeviceExternalFenceProperties :: fn (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *VkExternalFenceProperties)  #extern;
vkGetPhysicalDeviceExternalSemaphoreProperties :: fn (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *VkExternalSemaphoreProperties)  #extern;
vkGetDescriptorSetLayoutSupport :: fn (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pSupport: *VkDescriptorSetLayoutSupport)  #extern;
VkColorSpaceKHR :: enum {
    SRGB_NONLINEAR_KHR :: 0,
    DISPLAY_P3_NONLINEAR_EXT :: 1000104001,
    EXTENDED_SRGB_LINEAR_EXT :: 1000104002,
    DISPLAY_P3_LINEAR_EXT :: 1000104003,
    DCI_P3_NONLINEAR_EXT :: 1000104004,
    BT709_LINEAR_EXT :: 1000104005,
    BT709_NONLINEAR_EXT :: 1000104006,
    BT2020_LINEAR_EXT :: 1000104007,
    HDR10_ST2084_EXT :: 1000104008,
    DOLBYVISION_EXT :: 1000104009,
    HDR10_HLG_EXT :: 1000104010,
    ADOBERGB_LINEAR_EXT :: 1000104011,
    ADOBERGB_NONLINEAR_EXT :: 1000104012,
    PASS_THROUGH_EXT :: 1000104013,
    EXTENDED_SRGB_NONLINEAR_EXT :: 1000104014,
    DISPLAY_NATIVE_AMD :: 1000213000,
    RGB_NONLINEAR_KHR :: 0,
    DCI_P3_LINEAR_EXT :: 1000104003,
    BEGIN_RANGE_KHR :: 0,
    END_RANGE_KHR :: 0,
    RANGE_SIZE_KHR :: 1,
    MAX_ENUM_KHR :: 2147483647,
};

VkPresentModeKHR :: enum {
    IMMEDIATE_KHR :: 0,
    MAILBOX_KHR :: 1,
    FIFO_KHR :: 2,
    FIFO_RELAXED_KHR :: 3,
    SHARED_DEMAND_REFRESH_KHR :: 1000111000,
    SHARED_CONTINUOUS_REFRESH_KHR :: 1000111001,
    BEGIN_RANGE_KHR :: 0,
    END_RANGE_KHR :: 3,
    RANGE_SIZE_KHR :: 4,
    MAX_ENUM_KHR :: 2147483647,
};

VkSurfaceTransformFlagBitsKHR :: enum {
    IDENTITY_BIT_KHR :: 1,
    ROTATE_90_BIT_KHR :: 2,
    ROTATE_180_BIT_KHR :: 4,
    ROTATE_270_BIT_KHR :: 8,
    HORIZONTAL_MIRROR_BIT_KHR :: 16,
    HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR :: 32,
    HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR :: 64,
    HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR :: 128,
    INHERIT_BIT_KHR :: 256,
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647,
};

VkSurfaceTransformFlagsKHR :: VkFlags;

VkCompositeAlphaFlagBitsKHR :: enum {
    OPAQUE_BIT_KHR :: 1,
    PRE_MULTIPLIED_BIT_KHR :: 2,
    POST_MULTIPLIED_BIT_KHR :: 4,
    INHERIT_BIT_KHR :: 8,
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647,
};

VkCompositeAlphaFlagsKHR :: VkFlags;

VkSurfaceCapabilitiesKHR :: struct {
    minImageCount: u32,
    maxImageCount: u32,
    currentExtent: VkExtent2D,
    minImageExtent: VkExtent2D,
    maxImageExtent: VkExtent2D,
    maxImageArrayLayers: u32,
    supportedTransforms: VkSurfaceTransformFlagsKHR,
    currentTransform: VkSurfaceTransformFlagBitsKHR,
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    supportedUsageFlags: VkImageUsageFlags,
};

VkSurfaceFormatKHR :: struct {
    format: VkFormat,
    colorSpace: VkColorSpaceKHR,
};

PFN_vkDestroySurfaceKHR :: *fn (_0: VkInstance, _1: VkSurfaceKHR, _2: *VkAllocationCallbacks) ;

PFN_vkGetPhysicalDeviceSurfaceSupportKHR :: *fn (_0: VkPhysicalDevice, _1: u32, _2: VkSurfaceKHR, _3: *VkBool32) VkResult;

PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: *fn (_0: VkPhysicalDevice, _1: VkSurfaceKHR, _2: *VkSurfaceCapabilitiesKHR) VkResult;

PFN_vkGetPhysicalDeviceSurfaceFormatsKHR :: *fn (_0: VkPhysicalDevice, _1: VkSurfaceKHR, _2: *u32, _3: *VkSurfaceFormatKHR) VkResult;

PFN_vkGetPhysicalDeviceSurfacePresentModesKHR :: *fn (_0: VkPhysicalDevice, _1: VkSurfaceKHR, _2: *u32, _3: *VkPresentModeKHR) VkResult;

vkDestroySurfaceKHR :: fn (instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *VkAllocationCallbacks)  #extern;
vkGetPhysicalDeviceSurfaceSupportKHR :: fn (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, surface: VkSurfaceKHR, pSupported: *VkBool32) VkResult #extern;
vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *VkSurfaceCapabilitiesKHR) VkResult #extern;
vkGetPhysicalDeviceSurfaceFormatsKHR :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceFormatCount: *u32, pSurfaceFormats: *VkSurfaceFormatKHR) VkResult #extern;
vkGetPhysicalDeviceSurfacePresentModesKHR :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pPresentModeCount: *u32, pPresentModes: *VkPresentModeKHR) VkResult #extern;
VkSwapchainCreateFlagBitsKHR :: enum {
    SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR :: 1,
    PROTECTED_BIT_KHR :: 2,
    MUTABLE_FORMAT_BIT_KHR :: 4,
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647,
};

VkSwapchainCreateFlagsKHR :: VkFlags;

VkDeviceGroupPresentModeFlagBitsKHR :: enum {
    LOCAL_BIT_KHR :: 1,
    REMOTE_BIT_KHR :: 2,
    SUM_BIT_KHR :: 4,
    LOCAL_MULTI_DEVICE_BIT_KHR :: 8,
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647,
};

VkDeviceGroupPresentModeFlagsKHR :: VkFlags;

VkSwapchainCreateInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkSwapchainCreateFlagsKHR,
    surface: VkSurfaceKHR,
    minImageCount: u32,
    imageFormat: VkFormat,
    imageColorSpace: VkColorSpaceKHR,
    imageExtent: VkExtent2D,
    imageArrayLayers: u32,
    imageUsage: VkImageUsageFlags,
    imageSharingMode: VkSharingMode,
    queueFamilyIndexCount: u32,
    pQueueFamilyIndices: *u32,
    preTransform: VkSurfaceTransformFlagBitsKHR,
    compositeAlpha: VkCompositeAlphaFlagBitsKHR,
    presentMode: VkPresentModeKHR,
    clipped: VkBool32,
    oldSwapchain: VkSwapchainKHR,
};

VkPresentInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    waitSemaphoreCount: u32,
    pWaitSemaphores: *VkSemaphore,
    swapchainCount: u32,
    pSwapchains: *VkSwapchainKHR,
    pImageIndices: *u32,
    pResults: *VkResult,
};

VkImageSwapchainCreateInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    swapchain: VkSwapchainKHR,
};

VkBindImageMemorySwapchainInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    swapchain: VkSwapchainKHR,
    imageIndex: u32,
};

VkAcquireNextImageInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    swapchain: VkSwapchainKHR,
    timeout: u64,
    semaphore: VkSemaphore,
    fence: VkFence,
    deviceMask: u32,
};

VkDeviceGroupPresentCapabilitiesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    presentMask: [32]u32,
    modes: VkDeviceGroupPresentModeFlagsKHR,
};

VkDeviceGroupPresentInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    swapchainCount: u32,
    pDeviceMasks: *u32,
    mode: VkDeviceGroupPresentModeFlagBitsKHR,
};

VkDeviceGroupSwapchainCreateInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    modes: VkDeviceGroupPresentModeFlagsKHR,
};

PFN_vkCreateSwapchainKHR :: *fn (_0: VkDevice, _1: *VkSwapchainCreateInfoKHR, _2: *VkAllocationCallbacks, _3: *VkSwapchainKHR) VkResult;

PFN_vkDestroySwapchainKHR :: *fn (_0: VkDevice, _1: VkSwapchainKHR, _2: *VkAllocationCallbacks) ;

PFN_vkGetSwapchainImagesKHR :: *fn (_0: VkDevice, _1: VkSwapchainKHR, _2: *u32, _3: *VkImage) VkResult;

PFN_vkAcquireNextImageKHR :: *fn (_0: VkDevice, _1: VkSwapchainKHR, _2: u64, _3: VkSemaphore, _4: VkFence, _5: *u32) VkResult;

PFN_vkQueuePresentKHR :: *fn (_0: VkQueue, _1: *VkPresentInfoKHR) VkResult;

PFN_vkGetDeviceGroupPresentCapabilitiesKHR :: *fn (_0: VkDevice, _1: *VkDeviceGroupPresentCapabilitiesKHR) VkResult;

PFN_vkGetDeviceGroupSurfacePresentModesKHR :: *fn (_0: VkDevice, _1: VkSurfaceKHR, _2: *VkDeviceGroupPresentModeFlagsKHR) VkResult;

PFN_vkGetPhysicalDevicePresentRectanglesKHR :: *fn (_0: VkPhysicalDevice, _1: VkSurfaceKHR, _2: *u32, _3: *VkRect2D) VkResult;

PFN_vkAcquireNextImage2KHR :: *fn (_0: VkDevice, _1: *VkAcquireNextImageInfoKHR, _2: *u32) VkResult;

vkCreateSwapchainKHR :: fn (device: VkDevice, pCreateInfo: *VkSwapchainCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSwapchain: *VkSwapchainKHR) VkResult #extern;
vkDestroySwapchainKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: *VkAllocationCallbacks)  #extern;
vkGetSwapchainImagesKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainImageCount: *u32, pSwapchainImages: *VkImage) VkResult #extern;
vkAcquireNextImageKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR, timeout: u64, semaphore: VkSemaphore, fence: VkFence, pImageIndex: *u32) VkResult #extern;
vkQueuePresentKHR :: fn (queue: VkQueue, pPresentInfo: *VkPresentInfoKHR) VkResult #extern;
vkGetDeviceGroupPresentCapabilitiesKHR :: fn (device: VkDevice, pDeviceGroupPresentCapabilities: *VkDeviceGroupPresentCapabilitiesKHR) VkResult #extern;
vkGetDeviceGroupSurfacePresentModesKHR :: fn (device: VkDevice, surface: VkSurfaceKHR, pModes: *VkDeviceGroupPresentModeFlagsKHR) VkResult #extern;
vkGetPhysicalDevicePresentRectanglesKHR :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: *u32, pRects: *VkRect2D) VkResult #extern;
vkAcquireNextImage2KHR :: fn (device: VkDevice, pAcquireInfo: *VkAcquireNextImageInfoKHR, pImageIndex: *u32) VkResult #extern;
VkDisplayPlaneAlphaFlagBitsKHR :: enum {
    OPAQUE_BIT_KHR :: 1,
    GLOBAL_BIT_KHR :: 2,
    PER_PIXEL_BIT_KHR :: 4,
    PER_PIXEL_PREMULTIPLIED_BIT_KHR :: 8,
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647,
};

VkDisplayPlaneAlphaFlagsKHR :: VkFlags;

VkDisplayModeCreateFlagsKHR :: VkFlags;

VkDisplaySurfaceCreateFlagsKHR :: VkFlags;

VkDisplayPropertiesKHR :: struct {
    display: VkDisplayKHR,
    displayName: *u8,
    physicalDimensions: VkExtent2D,
    physicalResolution: VkExtent2D,
    supportedTransforms: VkSurfaceTransformFlagsKHR,
    planeReorderPossible: VkBool32,
    persistentContent: VkBool32,
};

VkDisplayModeParametersKHR :: struct {
    visibleRegion: VkExtent2D,
    refreshRate: u32,
};

VkDisplayModePropertiesKHR :: struct {
    displayMode: VkDisplayModeKHR,
    parameters: VkDisplayModeParametersKHR,
};

VkDisplayModeCreateInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDisplayModeCreateFlagsKHR,
    parameters: VkDisplayModeParametersKHR,
};

VkDisplayPlaneCapabilitiesKHR :: struct {
    supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
    minSrcPosition: VkOffset2D,
    maxSrcPosition: VkOffset2D,
    minSrcExtent: VkExtent2D,
    maxSrcExtent: VkExtent2D,
    minDstPosition: VkOffset2D,
    maxDstPosition: VkOffset2D,
    minDstExtent: VkExtent2D,
    maxDstExtent: VkExtent2D,
};

VkDisplayPlanePropertiesKHR :: struct {
    currentDisplay: VkDisplayKHR,
    currentStackIndex: u32,
};

VkDisplaySurfaceCreateInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDisplaySurfaceCreateFlagsKHR,
    displayMode: VkDisplayModeKHR,
    planeIndex: u32,
    planeStackIndex: u32,
    transform: VkSurfaceTransformFlagBitsKHR,
    globalAlpha: f32,
    alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
    imageExtent: VkExtent2D,
};

PFN_vkGetPhysicalDeviceDisplayPropertiesKHR :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkDisplayPropertiesKHR) VkResult;

PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkDisplayPlanePropertiesKHR) VkResult;

PFN_vkGetDisplayPlaneSupportedDisplaysKHR :: *fn (_0: VkPhysicalDevice, _1: u32, _2: *u32, _3: *VkDisplayKHR) VkResult;

PFN_vkGetDisplayModePropertiesKHR :: *fn (_0: VkPhysicalDevice, _1: VkDisplayKHR, _2: *u32, _3: *VkDisplayModePropertiesKHR) VkResult;

PFN_vkCreateDisplayModeKHR :: *fn (_0: VkPhysicalDevice, _1: VkDisplayKHR, _2: *VkDisplayModeCreateInfoKHR, _3: *VkAllocationCallbacks, _4: *VkDisplayModeKHR) VkResult;

PFN_vkGetDisplayPlaneCapabilitiesKHR :: *fn (_0: VkPhysicalDevice, _1: VkDisplayModeKHR, _2: u32, _3: *VkDisplayPlaneCapabilitiesKHR) VkResult;

PFN_vkCreateDisplayPlaneSurfaceKHR :: *fn (_0: VkInstance, _1: *VkDisplaySurfaceCreateInfoKHR, _2: *VkAllocationCallbacks, _3: *VkSurfaceKHR) VkResult;

vkGetPhysicalDeviceDisplayPropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPropertiesKHR) VkResult #extern;
vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPlanePropertiesKHR) VkResult #extern;
vkGetDisplayPlaneSupportedDisplaysKHR :: fn (physicalDevice: VkPhysicalDevice, planeIndex: u32, pDisplayCount: *u32, pDisplays: *VkDisplayKHR) VkResult #extern;
vkGetDisplayModePropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *u32, pProperties: *VkDisplayModePropertiesKHR) VkResult #extern;
vkCreateDisplayModeKHR :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pCreateInfo: *VkDisplayModeCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pMode: *VkDisplayModeKHR) VkResult #extern;
vkGetDisplayPlaneCapabilitiesKHR :: fn (physicalDevice: VkPhysicalDevice, mode: VkDisplayModeKHR, planeIndex: u32, pCapabilities: *VkDisplayPlaneCapabilitiesKHR) VkResult #extern;
vkCreateDisplayPlaneSurfaceKHR :: fn (instance: VkInstance, pCreateInfo: *VkDisplaySurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) VkResult #extern;
VkDisplayPresentInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    srcRect: VkRect2D,
    dstRect: VkRect2D,
    persistent: VkBool32,
};

PFN_vkCreateSharedSwapchainsKHR :: *fn (_0: VkDevice, _1: u32, _2: *VkSwapchainCreateInfoKHR, _3: *VkAllocationCallbacks, _4: *VkSwapchainKHR) VkResult;

vkCreateSharedSwapchainsKHR :: fn (device: VkDevice, swapchainCount: u32, pCreateInfos: *VkSwapchainCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSwapchains: *VkSwapchainKHR) VkResult #extern;
VkRenderPassMultiviewCreateInfoKHR :: VkRenderPassMultiviewCreateInfo;

VkPhysicalDeviceMultiviewFeaturesKHR :: VkPhysicalDeviceMultiviewFeatures;

VkPhysicalDeviceMultiviewPropertiesKHR :: VkPhysicalDeviceMultiviewProperties;

VkPhysicalDeviceFeatures2KHR :: VkPhysicalDeviceFeatures2;

VkPhysicalDeviceProperties2KHR :: VkPhysicalDeviceProperties2;

VkFormatProperties2KHR :: VkFormatProperties2;

VkImageFormatProperties2KHR :: VkImageFormatProperties2;

VkPhysicalDeviceImageFormatInfo2KHR :: VkPhysicalDeviceImageFormatInfo2;

VkQueueFamilyProperties2KHR :: VkQueueFamilyProperties2;

VkPhysicalDeviceMemoryProperties2KHR :: VkPhysicalDeviceMemoryProperties2;

VkSparseImageFormatProperties2KHR :: VkSparseImageFormatProperties2;

VkPhysicalDeviceSparseImageFormatInfo2KHR :: VkPhysicalDeviceSparseImageFormatInfo2;

PFN_vkGetPhysicalDeviceFeatures2KHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceFeatures2) ;

PFN_vkGetPhysicalDeviceProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceProperties2) ;

PFN_vkGetPhysicalDeviceFormatProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: VkFormat, _2: *VkFormatProperties2) ;

PFN_vkGetPhysicalDeviceImageFormatProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceImageFormatInfo2, _2: *VkImageFormatProperties2) VkResult;

PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkQueueFamilyProperties2) ;

PFN_vkGetPhysicalDeviceMemoryProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceMemoryProperties2) ;

PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceSparseImageFormatInfo2, _2: *u32, _3: *VkSparseImageFormatProperties2) ;

vkGetPhysicalDeviceFeatures2KHR :: fn (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures2)  #extern;
vkGetPhysicalDeviceProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties2)  #extern;
vkGetPhysicalDeviceFormatProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties2)  #extern;
vkGetPhysicalDeviceImageFormatProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pImageFormatInfo: *VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *VkImageFormatProperties2) VkResult #extern;
vkGetPhysicalDeviceQueueFamilyProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties2)  #extern;
vkGetPhysicalDeviceMemoryProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties2)  #extern;
vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pFormatInfo: *VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties2)  #extern;
VkPeerMemoryFeatureFlagsKHR :: VkPeerMemoryFeatureFlags;

VkPeerMemoryFeatureFlagBitsKHR :: VkPeerMemoryFeatureFlagBits;

VkMemoryAllocateFlagsKHR :: VkMemoryAllocateFlags;

VkMemoryAllocateFlagBitsKHR :: VkMemoryAllocateFlagBits;

VkMemoryAllocateFlagsInfoKHR :: VkMemoryAllocateFlagsInfo;

VkDeviceGroupRenderPassBeginInfoKHR :: VkDeviceGroupRenderPassBeginInfo;

VkDeviceGroupCommandBufferBeginInfoKHR :: VkDeviceGroupCommandBufferBeginInfo;

VkDeviceGroupSubmitInfoKHR :: VkDeviceGroupSubmitInfo;

VkDeviceGroupBindSparseInfoKHR :: VkDeviceGroupBindSparseInfo;

VkBindBufferMemoryDeviceGroupInfoKHR :: VkBindBufferMemoryDeviceGroupInfo;

VkBindImageMemoryDeviceGroupInfoKHR :: VkBindImageMemoryDeviceGroupInfo;

PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR :: *fn (_0: VkDevice, _1: u32, _2: u32, _3: u32, _4: *VkPeerMemoryFeatureFlags) ;

PFN_vkCmdSetDeviceMaskKHR :: *fn (_0: VkCommandBuffer, _1: u32) ;

PFN_vkCmdDispatchBaseKHR :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: u32, _4: u32, _5: u32, _6: u32) ;

vkGetDeviceGroupPeerMemoryFeaturesKHR :: fn (device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags)  #extern;
vkCmdSetDeviceMaskKHR :: fn (commandBuffer: VkCommandBuffer, deviceMask: u32)  #extern;
vkCmdDispatchBaseKHR :: fn (commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32)  #extern;
VkCommandPoolTrimFlagsKHR :: VkCommandPoolTrimFlags;

PFN_vkTrimCommandPoolKHR :: *fn (_0: VkDevice, _1: VkCommandPool, _2: VkCommandPoolTrimFlags) ;

vkTrimCommandPoolKHR :: fn (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags)  #extern;
VkPhysicalDeviceGroupPropertiesKHR :: VkPhysicalDeviceGroupProperties;

VkDeviceGroupDeviceCreateInfoKHR :: VkDeviceGroupDeviceCreateInfo;

PFN_vkEnumeratePhysicalDeviceGroupsKHR :: *fn (_0: VkInstance, _1: *u32, _2: *VkPhysicalDeviceGroupProperties) VkResult;

vkEnumeratePhysicalDeviceGroupsKHR :: fn (instance: VkInstance, pPhysicalDeviceGroupCount: *u32, pPhysicalDeviceGroupProperties: *VkPhysicalDeviceGroupProperties) VkResult #extern;
VkExternalMemoryHandleTypeFlagsKHR :: VkExternalMemoryHandleTypeFlags;

VkExternalMemoryHandleTypeFlagBitsKHR :: VkExternalMemoryHandleTypeFlagBits;

VkExternalMemoryFeatureFlagsKHR :: VkExternalMemoryFeatureFlags;

VkExternalMemoryFeatureFlagBitsKHR :: VkExternalMemoryFeatureFlagBits;

VkExternalMemoryPropertiesKHR :: VkExternalMemoryProperties;

VkPhysicalDeviceExternalImageFormatInfoKHR :: VkPhysicalDeviceExternalImageFormatInfo;

VkExternalImageFormatPropertiesKHR :: VkExternalImageFormatProperties;

VkPhysicalDeviceExternalBufferInfoKHR :: VkPhysicalDeviceExternalBufferInfo;

VkExternalBufferPropertiesKHR :: VkExternalBufferProperties;

VkPhysicalDeviceIDPropertiesKHR :: VkPhysicalDeviceIDProperties;

PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceExternalBufferInfo, _2: *VkExternalBufferProperties) ;

vkGetPhysicalDeviceExternalBufferPropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *VkExternalBufferProperties)  #extern;
VkExternalMemoryImageCreateInfoKHR :: VkExternalMemoryImageCreateInfo;

VkExternalMemoryBufferCreateInfoKHR :: VkExternalMemoryBufferCreateInfo;

VkExportMemoryAllocateInfoKHR :: VkExportMemoryAllocateInfo;

VkImportMemoryFdInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleType: VkExternalMemoryHandleTypeFlagBits,
    fd: s32,
};

VkMemoryFdPropertiesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    memoryTypeBits: u32,
};

VkMemoryGetFdInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    memory: VkDeviceMemory,
    handleType: VkExternalMemoryHandleTypeFlagBits,
};

PFN_vkGetMemoryFdKHR :: *fn (_0: VkDevice, _1: *VkMemoryGetFdInfoKHR, _2: *s32) VkResult;

PFN_vkGetMemoryFdPropertiesKHR :: *fn (_0: VkDevice, _1: VkExternalMemoryHandleTypeFlagBits, _2: s32, _3: *VkMemoryFdPropertiesKHR) VkResult;

vkGetMemoryFdKHR :: fn (device: VkDevice, pGetFdInfo: *VkMemoryGetFdInfoKHR, pFd: *s32) VkResult #extern;
vkGetMemoryFdPropertiesKHR :: fn (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, fd: s32, pMemoryFdProperties: *VkMemoryFdPropertiesKHR) VkResult #extern;
VkExternalSemaphoreHandleTypeFlagsKHR :: VkExternalSemaphoreHandleTypeFlags;

VkExternalSemaphoreHandleTypeFlagBitsKHR :: VkExternalSemaphoreHandleTypeFlagBits;

VkExternalSemaphoreFeatureFlagsKHR :: VkExternalSemaphoreFeatureFlags;

VkExternalSemaphoreFeatureFlagBitsKHR :: VkExternalSemaphoreFeatureFlagBits;

VkPhysicalDeviceExternalSemaphoreInfoKHR :: VkPhysicalDeviceExternalSemaphoreInfo;

VkExternalSemaphorePropertiesKHR :: VkExternalSemaphoreProperties;

PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceExternalSemaphoreInfo, _2: *VkExternalSemaphoreProperties) ;

vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *VkExternalSemaphoreProperties)  #extern;
VkSemaphoreImportFlagsKHR :: VkSemaphoreImportFlags;

VkSemaphoreImportFlagBitsKHR :: VkSemaphoreImportFlagBits;

VkExportSemaphoreCreateInfoKHR :: VkExportSemaphoreCreateInfo;

VkImportSemaphoreFdInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    semaphore: VkSemaphore,
    flags: VkSemaphoreImportFlags,
    handleType: VkExternalSemaphoreHandleTypeFlagBits,
    fd: s32,
};

VkSemaphoreGetFdInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    semaphore: VkSemaphore,
    handleType: VkExternalSemaphoreHandleTypeFlagBits,
};

PFN_vkImportSemaphoreFdKHR :: *fn (_0: VkDevice, _1: *VkImportSemaphoreFdInfoKHR) VkResult;

PFN_vkGetSemaphoreFdKHR :: *fn (_0: VkDevice, _1: *VkSemaphoreGetFdInfoKHR, _2: *s32) VkResult;

vkImportSemaphoreFdKHR :: fn (device: VkDevice, pImportSemaphoreFdInfo: *VkImportSemaphoreFdInfoKHR) VkResult #extern;
vkGetSemaphoreFdKHR :: fn (device: VkDevice, pGetFdInfo: *VkSemaphoreGetFdInfoKHR, pFd: *s32) VkResult #extern;
VkPhysicalDevicePushDescriptorPropertiesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxPushDescriptors: u32,
};

PFN_vkCmdPushDescriptorSetKHR :: *fn (_0: VkCommandBuffer, _1: VkPipelineBindPoint, _2: VkPipelineLayout, _3: u32, _4: u32, _5: *VkWriteDescriptorSet) ;

PFN_vkCmdPushDescriptorSetWithTemplateKHR :: *fn (_0: VkCommandBuffer, _1: VkDescriptorUpdateTemplate, _2: VkPipelineLayout, _3: u32, _4: *u8) ;

vkCmdPushDescriptorSetKHR :: fn (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *VkWriteDescriptorSet)  #extern;
vkCmdPushDescriptorSetWithTemplateKHR :: fn (commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *u8)  #extern;
VkPhysicalDeviceFloat16Int8FeaturesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderFloat16: VkBool32,
    shaderInt8: VkBool32,
};

VkPhysicalDevice16BitStorageFeaturesKHR :: VkPhysicalDevice16BitStorageFeatures;

VkRectLayerKHR :: struct {
    offset: VkOffset2D,
    extent: VkExtent2D,
    layer: u32,
};

VkPresentRegionKHR :: struct {
    rectangleCount: u32,
    pRectangles: *VkRectLayerKHR,
};

VkPresentRegionsKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    swapchainCount: u32,
    pRegions: *VkPresentRegionKHR,
};

VkDescriptorUpdateTemplateKHR :: VkDescriptorUpdateTemplate;

VkDescriptorUpdateTemplateTypeKHR :: VkDescriptorUpdateTemplateType;

VkDescriptorUpdateTemplateCreateFlagsKHR :: VkDescriptorUpdateTemplateCreateFlags;

VkDescriptorUpdateTemplateEntryKHR :: VkDescriptorUpdateTemplateEntry;

VkDescriptorUpdateTemplateCreateInfoKHR :: VkDescriptorUpdateTemplateCreateInfo;

PFN_vkCreateDescriptorUpdateTemplateKHR :: *fn (_0: VkDevice, _1: *VkDescriptorUpdateTemplateCreateInfo, _2: *VkAllocationCallbacks, _3: *VkDescriptorUpdateTemplate) VkResult;

PFN_vkDestroyDescriptorUpdateTemplateKHR :: *fn (_0: VkDevice, _1: VkDescriptorUpdateTemplate, _2: *VkAllocationCallbacks) ;

PFN_vkUpdateDescriptorSetWithTemplateKHR :: *fn (_0: VkDevice, _1: VkDescriptorSet, _2: VkDescriptorUpdateTemplate, _3: *u8) ;

vkCreateDescriptorUpdateTemplateKHR :: fn (device: VkDevice, pCreateInfo: *VkDescriptorUpdateTemplateCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate) VkResult #extern;
vkDestroyDescriptorUpdateTemplateKHR :: fn (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *VkAllocationCallbacks)  #extern;
vkUpdateDescriptorSetWithTemplateKHR :: fn (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *u8)  #extern;
VkPhysicalDeviceImagelessFramebufferFeaturesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    imagelessFramebuffer: VkBool32,
};

VkFramebufferAttachmentImageInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkImageCreateFlags,
    usage: VkImageUsageFlags,
    width: u32,
    height: u32,
    layerCount: u32,
    viewFormatCount: u32,
    pViewFormats: *VkFormat,
};

VkFramebufferAttachmentsCreateInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    attachmentImageInfoCount: u32,
    pAttachmentImageInfos: *VkFramebufferAttachmentImageInfoKHR,
};

VkRenderPassAttachmentBeginInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    attachmentCount: u32,
    pAttachments: *VkImageView,
};

VkAttachmentDescription2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkAttachmentDescriptionFlags,
    format: VkFormat,
    samples: VkSampleCountFlagBits,
    loadOp: VkAttachmentLoadOp,
    storeOp: VkAttachmentStoreOp,
    stencilLoadOp: VkAttachmentLoadOp,
    stencilStoreOp: VkAttachmentStoreOp,
    initialLayout: VkImageLayout,
    finalLayout: VkImageLayout,
};

VkAttachmentReference2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    attachment: u32,
    layout: VkImageLayout,
    aspectMask: VkImageAspectFlags,
};

VkSubpassDescription2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkSubpassDescriptionFlags,
    pipelineBindPoint: VkPipelineBindPoint,
    viewMask: u32,
    inputAttachmentCount: u32,
    pInputAttachments: *VkAttachmentReference2KHR,
    colorAttachmentCount: u32,
    pColorAttachments: *VkAttachmentReference2KHR,
    pResolveAttachments: *VkAttachmentReference2KHR,
    pDepthStencilAttachment: *VkAttachmentReference2KHR,
    preserveAttachmentCount: u32,
    pPreserveAttachments: *u32,
};

VkSubpassDependency2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    srcSubpass: u32,
    dstSubpass: u32,
    srcStageMask: VkPipelineStageFlags,
    dstStageMask: VkPipelineStageFlags,
    srcAccessMask: VkAccessFlags,
    dstAccessMask: VkAccessFlags,
    dependencyFlags: VkDependencyFlags,
    viewOffset: s32,
};

VkRenderPassCreateInfo2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkRenderPassCreateFlags,
    attachmentCount: u32,
    pAttachments: *VkAttachmentDescription2KHR,
    subpassCount: u32,
    pSubpasses: *VkSubpassDescription2KHR,
    dependencyCount: u32,
    pDependencies: *VkSubpassDependency2KHR,
    correlatedViewMaskCount: u32,
    pCorrelatedViewMasks: *u32,
};

VkSubpassBeginInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    contents: VkSubpassContents,
};

VkSubpassEndInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
};

PFN_vkCreateRenderPass2KHR :: *fn (_0: VkDevice, _1: *VkRenderPassCreateInfo2KHR, _2: *VkAllocationCallbacks, _3: *VkRenderPass) VkResult;

PFN_vkCmdBeginRenderPass2KHR :: *fn (_0: VkCommandBuffer, _1: *VkRenderPassBeginInfo, _2: *VkSubpassBeginInfoKHR) ;

PFN_vkCmdNextSubpass2KHR :: *fn (_0: VkCommandBuffer, _1: *VkSubpassBeginInfoKHR, _2: *VkSubpassEndInfoKHR) ;

PFN_vkCmdEndRenderPass2KHR :: *fn (_0: VkCommandBuffer, _1: *VkSubpassEndInfoKHR) ;

vkCreateRenderPass2KHR :: fn (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo2KHR, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) VkResult #extern;
vkCmdBeginRenderPass2KHR :: fn (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, pSubpassBeginInfo: *VkSubpassBeginInfoKHR)  #extern;
vkCmdNextSubpass2KHR :: fn (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *VkSubpassBeginInfoKHR, pSubpassEndInfo: *VkSubpassEndInfoKHR)  #extern;
vkCmdEndRenderPass2KHR :: fn (commandBuffer: VkCommandBuffer, pSubpassEndInfo: *VkSubpassEndInfoKHR)  #extern;
VkSharedPresentSurfaceCapabilitiesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    sharedPresentSupportedUsageFlags: VkImageUsageFlags,
};

PFN_vkGetSwapchainStatusKHR :: *fn (_0: VkDevice, _1: VkSwapchainKHR) VkResult;

vkGetSwapchainStatusKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR) VkResult #extern;
VkExternalFenceHandleTypeFlagsKHR :: VkExternalFenceHandleTypeFlags;

VkExternalFenceHandleTypeFlagBitsKHR :: VkExternalFenceHandleTypeFlagBits;

VkExternalFenceFeatureFlagsKHR :: VkExternalFenceFeatureFlags;

VkExternalFenceFeatureFlagBitsKHR :: VkExternalFenceFeatureFlagBits;

VkPhysicalDeviceExternalFenceInfoKHR :: VkPhysicalDeviceExternalFenceInfo;

VkExternalFencePropertiesKHR :: VkExternalFenceProperties;

PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceExternalFenceInfo, _2: *VkExternalFenceProperties) ;

vkGetPhysicalDeviceExternalFencePropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *VkExternalFenceProperties)  #extern;
VkFenceImportFlagsKHR :: VkFenceImportFlags;

VkFenceImportFlagBitsKHR :: VkFenceImportFlagBits;

VkExportFenceCreateInfoKHR :: VkExportFenceCreateInfo;

VkImportFenceFdInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    fence: VkFence,
    flags: VkFenceImportFlags,
    handleType: VkExternalFenceHandleTypeFlagBits,
    fd: s32,
};

VkFenceGetFdInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    fence: VkFence,
    handleType: VkExternalFenceHandleTypeFlagBits,
};

PFN_vkImportFenceFdKHR :: *fn (_0: VkDevice, _1: *VkImportFenceFdInfoKHR) VkResult;

PFN_vkGetFenceFdKHR :: *fn (_0: VkDevice, _1: *VkFenceGetFdInfoKHR, _2: *s32) VkResult;

vkImportFenceFdKHR :: fn (device: VkDevice, pImportFenceFdInfo: *VkImportFenceFdInfoKHR) VkResult #extern;
vkGetFenceFdKHR :: fn (device: VkDevice, pGetFdInfo: *VkFenceGetFdInfoKHR, pFd: *s32) VkResult #extern;
VkPointClippingBehaviorKHR :: VkPointClippingBehavior;

VkTessellationDomainOriginKHR :: VkTessellationDomainOrigin;

VkPhysicalDevicePointClippingPropertiesKHR :: VkPhysicalDevicePointClippingProperties;

VkRenderPassInputAttachmentAspectCreateInfoKHR :: VkRenderPassInputAttachmentAspectCreateInfo;

VkInputAttachmentAspectReferenceKHR :: VkInputAttachmentAspectReference;

VkImageViewUsageCreateInfoKHR :: VkImageViewUsageCreateInfo;

VkPipelineTessellationDomainOriginStateCreateInfoKHR :: VkPipelineTessellationDomainOriginStateCreateInfo;

VkPhysicalDeviceSurfaceInfo2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    surface: VkSurfaceKHR,
};

VkSurfaceCapabilities2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    surfaceCapabilities: VkSurfaceCapabilitiesKHR,
};

VkSurfaceFormat2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    surfaceFormat: VkSurfaceFormatKHR,
};

PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceSurfaceInfo2KHR, _2: *VkSurfaceCapabilities2KHR) VkResult;

PFN_vkGetPhysicalDeviceSurfaceFormats2KHR :: *fn (_0: VkPhysicalDevice, _1: *VkPhysicalDeviceSurfaceInfo2KHR, _2: *u32, _3: *VkSurfaceFormat2KHR) VkResult;

vkGetPhysicalDeviceSurfaceCapabilities2KHR :: fn (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *VkSurfaceCapabilities2KHR) VkResult #extern;
vkGetPhysicalDeviceSurfaceFormats2KHR :: fn (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *u32, pSurfaceFormats: *VkSurfaceFormat2KHR) VkResult #extern;
VkPhysicalDeviceVariablePointerFeaturesKHR :: VkPhysicalDeviceVariablePointersFeatures;

VkPhysicalDeviceVariablePointersFeaturesKHR :: VkPhysicalDeviceVariablePointersFeatures;

VkDisplayProperties2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    displayProperties: VkDisplayPropertiesKHR,
};

VkDisplayPlaneProperties2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    displayPlaneProperties: VkDisplayPlanePropertiesKHR,
};

VkDisplayModeProperties2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    displayModeProperties: VkDisplayModePropertiesKHR,
};

VkDisplayPlaneInfo2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    mode: VkDisplayModeKHR,
    planeIndex: u32,
};

VkDisplayPlaneCapabilities2KHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    capabilities: VkDisplayPlaneCapabilitiesKHR,
};

PFN_vkGetPhysicalDeviceDisplayProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkDisplayProperties2KHR) VkResult;

PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkDisplayPlaneProperties2KHR) VkResult;

PFN_vkGetDisplayModeProperties2KHR :: *fn (_0: VkPhysicalDevice, _1: VkDisplayKHR, _2: *u32, _3: *VkDisplayModeProperties2KHR) VkResult;

PFN_vkGetDisplayPlaneCapabilities2KHR :: *fn (_0: VkPhysicalDevice, _1: *VkDisplayPlaneInfo2KHR, _2: *VkDisplayPlaneCapabilities2KHR) VkResult;

vkGetPhysicalDeviceDisplayProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayProperties2KHR) VkResult #extern;
vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPlaneProperties2KHR) VkResult #extern;
vkGetDisplayModeProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *u32, pProperties: *VkDisplayModeProperties2KHR) VkResult #extern;
vkGetDisplayPlaneCapabilities2KHR :: fn (physicalDevice: VkPhysicalDevice, pDisplayPlaneInfo: *VkDisplayPlaneInfo2KHR, pCapabilities: *VkDisplayPlaneCapabilities2KHR) VkResult #extern;
VkMemoryDedicatedRequirementsKHR :: VkMemoryDedicatedRequirements;

VkMemoryDedicatedAllocateInfoKHR :: VkMemoryDedicatedAllocateInfo;

VkBufferMemoryRequirementsInfo2KHR :: VkBufferMemoryRequirementsInfo2;

VkImageMemoryRequirementsInfo2KHR :: VkImageMemoryRequirementsInfo2;

VkImageSparseMemoryRequirementsInfo2KHR :: VkImageSparseMemoryRequirementsInfo2;

VkSparseImageMemoryRequirements2KHR :: VkSparseImageMemoryRequirements2;

PFN_vkGetImageMemoryRequirements2KHR :: *fn (_0: VkDevice, _1: *VkImageMemoryRequirementsInfo2, _2: *VkMemoryRequirements2) ;

PFN_vkGetBufferMemoryRequirements2KHR :: *fn (_0: VkDevice, _1: *VkBufferMemoryRequirementsInfo2, _2: *VkMemoryRequirements2) ;

PFN_vkGetImageSparseMemoryRequirements2KHR :: *fn (_0: VkDevice, _1: *VkImageSparseMemoryRequirementsInfo2, _2: *u32, _3: *VkSparseImageMemoryRequirements2) ;

vkGetImageMemoryRequirements2KHR :: fn (device: VkDevice, pInfo: *VkImageMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2)  #extern;
vkGetBufferMemoryRequirements2KHR :: fn (device: VkDevice, pInfo: *VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2)  #extern;
vkGetImageSparseMemoryRequirements2KHR :: fn (device: VkDevice, pInfo: *VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2)  #extern;
VkImageFormatListCreateInfoKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    viewFormatCount: u32,
    pViewFormats: *VkFormat,
};

VkSamplerYcbcrConversionKHR :: VkSamplerYcbcrConversion;

VkSamplerYcbcrModelConversionKHR :: VkSamplerYcbcrModelConversion;

VkSamplerYcbcrRangeKHR :: VkSamplerYcbcrRange;

VkChromaLocationKHR :: VkChromaLocation;

VkSamplerYcbcrConversionCreateInfoKHR :: VkSamplerYcbcrConversionCreateInfo;

VkSamplerYcbcrConversionInfoKHR :: VkSamplerYcbcrConversionInfo;

VkBindImagePlaneMemoryInfoKHR :: VkBindImagePlaneMemoryInfo;

VkImagePlaneMemoryRequirementsInfoKHR :: VkImagePlaneMemoryRequirementsInfo;

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR :: VkPhysicalDeviceSamplerYcbcrConversionFeatures;

VkSamplerYcbcrConversionImageFormatPropertiesKHR :: VkSamplerYcbcrConversionImageFormatProperties;

PFN_vkCreateSamplerYcbcrConversionKHR :: *fn (_0: VkDevice, _1: *VkSamplerYcbcrConversionCreateInfo, _2: *VkAllocationCallbacks, _3: *VkSamplerYcbcrConversion) VkResult;

PFN_vkDestroySamplerYcbcrConversionKHR :: *fn (_0: VkDevice, _1: VkSamplerYcbcrConversion, _2: *VkAllocationCallbacks) ;

vkCreateSamplerYcbcrConversionKHR :: fn (device: VkDevice, pCreateInfo: *VkSamplerYcbcrConversionCreateInfo, pAllocator: *VkAllocationCallbacks, pYcbcrConversion: *VkSamplerYcbcrConversion) VkResult #extern;
vkDestroySamplerYcbcrConversionKHR :: fn (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *VkAllocationCallbacks)  #extern;
VkBindBufferMemoryInfoKHR :: VkBindBufferMemoryInfo;

VkBindImageMemoryInfoKHR :: VkBindImageMemoryInfo;

PFN_vkBindBufferMemory2KHR :: *fn (_0: VkDevice, _1: u32, _2: *VkBindBufferMemoryInfo) VkResult;

PFN_vkBindImageMemory2KHR :: *fn (_0: VkDevice, _1: u32, _2: *VkBindImageMemoryInfo) VkResult;

vkBindBufferMemory2KHR :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindBufferMemoryInfo) VkResult #extern;
vkBindImageMemory2KHR :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindImageMemoryInfo) VkResult #extern;
VkPhysicalDeviceMaintenance3PropertiesKHR :: VkPhysicalDeviceMaintenance3Properties;

VkDescriptorSetLayoutSupportKHR :: VkDescriptorSetLayoutSupport;

PFN_vkGetDescriptorSetLayoutSupportKHR :: *fn (_0: VkDevice, _1: *VkDescriptorSetLayoutCreateInfo, _2: *VkDescriptorSetLayoutSupport) ;

vkGetDescriptorSetLayoutSupportKHR :: fn (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pSupport: *VkDescriptorSetLayoutSupport)  #extern;
PFN_vkCmdDrawIndirectCountKHR :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkBuffer, _4: VkDeviceSize, _5: u32, _6: u32) ;

PFN_vkCmdDrawIndexedIndirectCountKHR :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkBuffer, _4: VkDeviceSize, _5: u32, _6: u32) ;

vkCmdDrawIndirectCountKHR :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32)  #extern;
vkCmdDrawIndexedIndirectCountKHR :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32)  #extern;
VkPhysicalDevice8BitStorageFeaturesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    storageBuffer8BitAccess: VkBool32,
    uniformAndStorageBuffer8BitAccess: VkBool32,
    storagePushConstant8: VkBool32,
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderBufferInt64Atomics: VkBool32,
    shaderSharedInt64Atomics: VkBool32,
};

VkDriverIdKHR :: enum {
    AMD_PROPRIETARY_KHR :: 1,
    AMD_OPEN_SOURCE_KHR :: 2,
    MESA_RADV_KHR :: 3,
    NVIDIA_PROPRIETARY_KHR :: 4,
    INTEL_PROPRIETARY_WINDOWS_KHR :: 5,
    INTEL_OPEN_SOURCE_MESA_KHR :: 6,
    IMAGINATION_PROPRIETARY_KHR :: 7,
    QUALCOMM_PROPRIETARY_KHR :: 8,
    ARM_PROPRIETARY_KHR :: 9,
    GOOGLE_SWIFTSHADER_KHR :: 10,
    GGP_PROPRIETARY_KHR :: 11,
    BROADCOM_PROPRIETARY_KHR :: 12,
    BEGIN_RANGE_KHR :: 1,
    END_RANGE_KHR :: 12,
    RANGE_SIZE_KHR :: 12,
    MAX_ENUM_KHR :: 2147483647,
};

VkConformanceVersionKHR :: struct {
    major: u8,
    minor: u8,
    subminor: u8,
    patch: u8,
};

VkPhysicalDeviceDriverPropertiesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    driverID: VkDriverIdKHR,
    driverName: [256]u8,
    driverInfo: [256]u8,
    conformanceVersion: VkConformanceVersionKHR,
};

VkPhysicalDeviceFloatControlsPropertiesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    separateDenormSettings: VkBool32,
    separateRoundingModeSettings: VkBool32,
    shaderSignedZeroInfNanPreserveFloat16: VkBool32,
    shaderSignedZeroInfNanPreserveFloat32: VkBool32,
    shaderSignedZeroInfNanPreserveFloat64: VkBool32,
    shaderDenormPreserveFloat16: VkBool32,
    shaderDenormPreserveFloat32: VkBool32,
    shaderDenormPreserveFloat64: VkBool32,
    shaderDenormFlushToZeroFloat16: VkBool32,
    shaderDenormFlushToZeroFloat32: VkBool32,
    shaderDenormFlushToZeroFloat64: VkBool32,
    shaderRoundingModeRTEFloat16: VkBool32,
    shaderRoundingModeRTEFloat32: VkBool32,
    shaderRoundingModeRTEFloat64: VkBool32,
    shaderRoundingModeRTZFloat16: VkBool32,
    shaderRoundingModeRTZFloat32: VkBool32,
    shaderRoundingModeRTZFloat64: VkBool32,
};

VkResolveModeFlagBitsKHR :: enum {
    NONE_KHR :: 0,
    SAMPLE_ZERO_BIT_KHR :: 1,
    AVERAGE_BIT_KHR :: 2,
    MIN_BIT_KHR :: 4,
    MAX_BIT_KHR :: 8,
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647,
};

VkResolveModeFlagsKHR :: VkFlags;

VkSubpassDescriptionDepthStencilResolveKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    depthResolveMode: VkResolveModeFlagBitsKHR,
    stencilResolveMode: VkResolveModeFlagBitsKHR,
    pDepthStencilResolveAttachment: *VkAttachmentReference2KHR,
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    supportedDepthResolveModes: VkResolveModeFlagsKHR,
    supportedStencilResolveModes: VkResolveModeFlagsKHR,
    independentResolveNone: VkBool32,
    independentResolve: VkBool32,
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    vulkanMemoryModel: VkBool32,
    vulkanMemoryModelDeviceScope: VkBool32,
    vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
};

VkSurfaceProtectedCapabilitiesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    supportsProtected: VkBool32,
};

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR :: struct {
    sType: VkStructureType,
    pNext: *u8,
    uniformBufferStandardLayout: VkBool32,
};

VkDebugReportObjectTypeEXT :: enum {
    UNKNOWN_EXT :: 0,
    INSTANCE_EXT :: 1,
    PHYSICAL_DEVICE_EXT :: 2,
    DEVICE_EXT :: 3,
    QUEUE_EXT :: 4,
    SEMAPHORE_EXT :: 5,
    COMMAND_BUFFER_EXT :: 6,
    FENCE_EXT :: 7,
    DEVICE_MEMORY_EXT :: 8,
    BUFFER_EXT :: 9,
    IMAGE_EXT :: 10,
    EVENT_EXT :: 11,
    QUERY_POOL_EXT :: 12,
    BUFFER_VIEW_EXT :: 13,
    IMAGE_VIEW_EXT :: 14,
    SHADER_MODULE_EXT :: 15,
    PIPELINE_CACHE_EXT :: 16,
    PIPELINE_LAYOUT_EXT :: 17,
    RENDER_PASS_EXT :: 18,
    PIPELINE_EXT :: 19,
    DESCRIPTOR_SET_LAYOUT_EXT :: 20,
    SAMPLER_EXT :: 21,
    DESCRIPTOR_POOL_EXT :: 22,
    DESCRIPTOR_SET_EXT :: 23,
    FRAMEBUFFER_EXT :: 24,
    COMMAND_POOL_EXT :: 25,
    SURFACE_KHR_EXT :: 26,
    SWAPCHAIN_KHR_EXT :: 27,
    DEBUG_REPORT_CALLBACK_EXT_EXT :: 28,
    DISPLAY_KHR_EXT :: 29,
    DISPLAY_MODE_KHR_EXT :: 30,
    OBJECT_TABLE_NVX_EXT :: 31,
    INDIRECT_COMMANDS_LAYOUT_NVX_EXT :: 32,
    VALIDATION_CACHE_EXT_EXT :: 33,
    SAMPLER_YCBCR_CONVERSION_EXT :: 1000156000,
    DESCRIPTOR_UPDATE_TEMPLATE_EXT :: 1000085000,
    ACCELERATION_STRUCTURE_NV_EXT :: 1000165000,
    DEBUG_REPORT_EXT :: 28,
    VALIDATION_CACHE_EXT :: 33,
    DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT :: 1000085000,
    SAMPLER_YCBCR_CONVERSION_KHR_EXT :: 1000156000,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 33,
    RANGE_SIZE_EXT :: 34,
    MAX_ENUM_EXT :: 2147483647,
};

VkDebugReportFlagBitsEXT :: enum {
    INFORMATION_BIT_EXT :: 1,
    WARNING_BIT_EXT :: 2,
    PERFORMANCE_WARNING_BIT_EXT :: 4,
    ERROR_BIT_EXT :: 8,
    DEBUG_BIT_EXT :: 16,
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647,
};

VkDebugReportFlagsEXT :: VkFlags;

PFN_vkDebugReportCallbackEXT :: *fn (_0: VkDebugReportFlagsEXT, _1: VkDebugReportObjectTypeEXT, _2: u64, _3: usize, _4: s32, _5: *s8, _6: *s8, _7: *u8) VkBool32;

VkDebugReportCallbackCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDebugReportFlagsEXT,
    pfnCallback: PFN_vkDebugReportCallbackEXT,
    pUserData: *u8,
};

PFN_vkCreateDebugReportCallbackEXT :: *fn (_0: VkInstance, _1: *VkDebugReportCallbackCreateInfoEXT, _2: *VkAllocationCallbacks, _3: *VkDebugReportCallbackEXT) VkResult;

PFN_vkDestroyDebugReportCallbackEXT :: *fn (_0: VkInstance, _1: VkDebugReportCallbackEXT, _2: *VkAllocationCallbacks) ;

PFN_vkDebugReportMessageEXT :: *fn (_0: VkInstance, _1: VkDebugReportFlagsEXT, _2: VkDebugReportObjectTypeEXT, _3: u64, _4: usize, _5: s32, _6: *s8, _7: *s8) ;

vkCreateDebugReportCallbackEXT :: fn (instance: VkInstance, pCreateInfo: *VkDebugReportCallbackCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pCallback: *VkDebugReportCallbackEXT) VkResult #extern;
vkDestroyDebugReportCallbackEXT :: fn (instance: VkInstance, callback: VkDebugReportCallbackEXT, pAllocator: *VkAllocationCallbacks)  #extern;
vkDebugReportMessageEXT :: fn (instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: usize, messageCode: s32, pLayerPrefix: *s8, pMessage: *s8)  #extern;
VkRasterizationOrderAMD :: enum {
    STRICT_AMD :: 0,
    RELAXED_AMD :: 1,
    BEGIN_RANGE_AMD :: 0,
    END_RANGE_AMD :: 1,
    RANGE_SIZE_AMD :: 2,
    MAX_ENUM_AMD :: 2147483647,
};

VkPipelineRasterizationStateRasterizationOrderAMD :: struct {
    sType: VkStructureType,
    pNext: *u8,
    rasterizationOrder: VkRasterizationOrderAMD,
};

VkDebugMarkerObjectNameInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    objectType: VkDebugReportObjectTypeEXT,
    object: u64,
    pObjectName: *u8,
};

VkDebugMarkerObjectTagInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    objectType: VkDebugReportObjectTypeEXT,
    object: u64,
    tagName: u64,
    tagSize: usize,
    pTag: *u8,
};

VkDebugMarkerMarkerInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    pMarkerName: *u8,
    color: [4]f32,
};

PFN_vkDebugMarkerSetObjectTagEXT :: *fn (_0: VkDevice, _1: *VkDebugMarkerObjectTagInfoEXT) VkResult;

PFN_vkDebugMarkerSetObjectNameEXT :: *fn (_0: VkDevice, _1: *VkDebugMarkerObjectNameInfoEXT) VkResult;

PFN_vkCmdDebugMarkerBeginEXT :: *fn (_0: VkCommandBuffer, _1: *VkDebugMarkerMarkerInfoEXT) ;

PFN_vkCmdDebugMarkerEndEXT :: *fn (_0: VkCommandBuffer) ;

PFN_vkCmdDebugMarkerInsertEXT :: *fn (_0: VkCommandBuffer, _1: *VkDebugMarkerMarkerInfoEXT) ;

vkDebugMarkerSetObjectTagEXT :: fn (device: VkDevice, pTagInfo: *VkDebugMarkerObjectTagInfoEXT) VkResult #extern;
vkDebugMarkerSetObjectNameEXT :: fn (device: VkDevice, pNameInfo: *VkDebugMarkerObjectNameInfoEXT) VkResult #extern;
vkCmdDebugMarkerBeginEXT :: fn (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkDebugMarkerMarkerInfoEXT)  #extern;
vkCmdDebugMarkerEndEXT :: fn (commandBuffer: VkCommandBuffer)  #extern;
vkCmdDebugMarkerInsertEXT :: fn (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkDebugMarkerMarkerInfoEXT)  #extern;
VkDedicatedAllocationImageCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    dedicatedAllocation: VkBool32,
};

VkDedicatedAllocationBufferCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    dedicatedAllocation: VkBool32,
};

VkDedicatedAllocationMemoryAllocateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    image: VkImage,
    buffer: VkBuffer,
};

VkPipelineRasterizationStateStreamCreateFlagsEXT :: VkFlags;

VkPhysicalDeviceTransformFeedbackFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    transformFeedback: VkBool32,
    geometryStreams: VkBool32,
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxTransformFeedbackStreams: u32,
    maxTransformFeedbackBuffers: u32,
    maxTransformFeedbackBufferSize: VkDeviceSize,
    maxTransformFeedbackStreamDataSize: u32,
    maxTransformFeedbackBufferDataSize: u32,
    maxTransformFeedbackBufferDataStride: u32,
    transformFeedbackQueries: VkBool32,
    transformFeedbackStreamsLinesTriangles: VkBool32,
    transformFeedbackRasterizationStreamSelect: VkBool32,
    transformFeedbackDraw: VkBool32,
};

VkPipelineRasterizationStateStreamCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineRasterizationStateStreamCreateFlagsEXT,
    rasterizationStream: u32,
};

PFN_vkCmdBindTransformFeedbackBuffersEXT :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkBuffer, _4: *VkDeviceSize, _5: *VkDeviceSize) ;

PFN_vkCmdBeginTransformFeedbackEXT :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkBuffer, _4: *VkDeviceSize) ;

PFN_vkCmdEndTransformFeedbackEXT :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkBuffer, _4: *VkDeviceSize) ;

PFN_vkCmdBeginQueryIndexedEXT :: *fn (_0: VkCommandBuffer, _1: VkQueryPool, _2: u32, _3: VkQueryControlFlags, _4: u32) ;

PFN_vkCmdEndQueryIndexedEXT :: *fn (_0: VkCommandBuffer, _1: VkQueryPool, _2: u32, _3: u32) ;

PFN_vkCmdDrawIndirectByteCountEXT :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: VkBuffer, _4: VkDeviceSize, _5: u32, _6: u32) ;

vkCmdBindTransformFeedbackBuffersEXT :: fn (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize)  #extern;
vkCmdBeginTransformFeedbackEXT :: fn (commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *VkBuffer, pCounterBufferOffsets: *VkDeviceSize)  #extern;
vkCmdEndTransformFeedbackEXT :: fn (commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *VkBuffer, pCounterBufferOffsets: *VkDeviceSize)  #extern;
vkCmdBeginQueryIndexedEXT :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags, index: u32)  #extern;
vkCmdEndQueryIndexedEXT :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, index: u32)  #extern;
vkCmdDrawIndirectByteCountEXT :: fn (commandBuffer: VkCommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: VkBuffer, counterBufferOffset: VkDeviceSize, counterOffset: u32, vertexStride: u32)  #extern;
VkImageViewHandleInfoNVX :: struct {
    sType: VkStructureType,
    pNext: *u8,
    imageView: VkImageView,
    descriptorType: VkDescriptorType,
    sampler: VkSampler,
};

PFN_vkGetImageViewHandleNVX :: *fn (_0: VkDevice, _1: *VkImageViewHandleInfoNVX) u32;

vkGetImageViewHandleNVX :: fn (device: VkDevice, pInfo: *VkImageViewHandleInfoNVX) u32 #extern;
PFN_vkCmdDrawIndirectCountAMD :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkBuffer, _4: VkDeviceSize, _5: u32, _6: u32) ;

PFN_vkCmdDrawIndexedIndirectCountAMD :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkBuffer, _4: VkDeviceSize, _5: u32, _6: u32) ;

vkCmdDrawIndirectCountAMD :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32)  #extern;
vkCmdDrawIndexedIndirectCountAMD :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32)  #extern;
VkTextureLODGatherFormatPropertiesAMD :: struct {
    sType: VkStructureType,
    pNext: *u8,
    supportsTextureGatherLODBiasAMD: VkBool32,
};

VkShaderInfoTypeAMD :: enum {
    STATISTICS_AMD :: 0,
    BINARY_AMD :: 1,
    DISASSEMBLY_AMD :: 2,
    BEGIN_RANGE_AMD :: 0,
    END_RANGE_AMD :: 2,
    RANGE_SIZE_AMD :: 3,
    MAX_ENUM_AMD :: 2147483647,
};

VkShaderResourceUsageAMD :: struct {
    numUsedVgprs: u32,
    numUsedSgprs: u32,
    ldsSizePerLocalWorkGroup: u32,
    ldsUsageSizeInBytes: usize,
    scratchMemUsageInBytes: usize,
};

VkShaderStatisticsInfoAMD :: struct {
    shaderStageMask: VkShaderStageFlags,
    resourceUsage: VkShaderResourceUsageAMD,
    numPhysicalVgprs: u32,
    numPhysicalSgprs: u32,
    numAvailableVgprs: u32,
    numAvailableSgprs: u32,
    computeWorkGroupSize: [3]u32,
};

PFN_vkGetShaderInfoAMD :: *fn (_0: VkDevice, _1: VkPipeline, _2: VkShaderStageFlagBits, _3: VkShaderInfoTypeAMD, _4: *usize, _5: *u8) VkResult;

vkGetShaderInfoAMD :: fn (device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *usize, pInfo: *u8) VkResult #extern;
VkPhysicalDeviceCornerSampledImageFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    cornerSampledImage: VkBool32,
};

VkExternalMemoryHandleTypeFlagBitsNV :: enum {
    OPAQUE_WIN32_BIT_NV :: 1,
    OPAQUE_WIN32_KMT_BIT_NV :: 2,
    D3D11_IMAGE_BIT_NV :: 4,
    D3D11_IMAGE_KMT_BIT_NV :: 8,
    FLAG_BITS_MAX_ENUM_NV :: 2147483647,
};

VkExternalMemoryHandleTypeFlagsNV :: VkFlags;

VkExternalMemoryFeatureFlagBitsNV :: enum {
    DEDICATED_ONLY_BIT_NV :: 1,
    EXPORTABLE_BIT_NV :: 2,
    IMPORTABLE_BIT_NV :: 4,
    FLAG_BITS_MAX_ENUM_NV :: 2147483647,
};

VkExternalMemoryFeatureFlagsNV :: VkFlags;

VkExternalImageFormatPropertiesNV :: struct {
    imageFormatProperties: VkImageFormatProperties,
    externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV,
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
};

PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: *fn (_0: VkPhysicalDevice, _1: VkFormat, _2: VkImageType, _3: VkImageTiling, _4: VkImageUsageFlags, _5: VkImageCreateFlags, _6: VkExternalMemoryHandleTypeFlagsNV, _7: *VkExternalImageFormatPropertiesNV) VkResult;

vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *VkExternalImageFormatPropertiesNV) VkResult #extern;
VkExternalMemoryImageCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleTypes: VkExternalMemoryHandleTypeFlagsNV,
};

VkExportMemoryAllocateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleTypes: VkExternalMemoryHandleTypeFlagsNV,
};

VkValidationCheckEXT :: enum {
    ALL_EXT :: 0,
    SHADERS_EXT :: 1,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 1,
    RANGE_SIZE_EXT :: 2,
    MAX_ENUM_EXT :: 2147483647,
};

VkValidationFlagsEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    disabledValidationCheckCount: u32,
    pDisabledValidationChecks: *VkValidationCheckEXT,
};

VkImageViewASTCDecodeModeEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    decodeMode: VkFormat,
};

VkPhysicalDeviceASTCDecodeFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    decodeModeSharedExponent: VkBool32,
};

VkConditionalRenderingFlagBitsEXT :: enum {
    INVERTED_BIT_EXT :: 1,
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647,
};

VkConditionalRenderingFlagsEXT :: VkFlags;

VkConditionalRenderingBeginInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    buffer: VkBuffer,
    offset: VkDeviceSize,
    flags: VkConditionalRenderingFlagsEXT,
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    conditionalRendering: VkBool32,
    inheritedConditionalRendering: VkBool32,
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    conditionalRenderingEnable: VkBool32,
};

PFN_vkCmdBeginConditionalRenderingEXT :: *fn (_0: VkCommandBuffer, _1: *VkConditionalRenderingBeginInfoEXT) ;

PFN_vkCmdEndConditionalRenderingEXT :: *fn (_0: VkCommandBuffer) ;

vkCmdBeginConditionalRenderingEXT :: fn (commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *VkConditionalRenderingBeginInfoEXT)  #extern;
vkCmdEndConditionalRenderingEXT :: fn (commandBuffer: VkCommandBuffer)  #extern;
VkIndirectCommandsTokenTypeNVX :: enum {
    PIPELINE_NVX :: 0,
    DESCRIPTOR_SET_NVX :: 1,
    INDEX_BUFFER_NVX :: 2,
    VERTEX_BUFFER_NVX :: 3,
    PUSH_CONSTANT_NVX :: 4,
    DRAW_INDEXED_NVX :: 5,
    DRAW_NVX :: 6,
    DISPATCH_NVX :: 7,
    BEGIN_RANGE_NVX :: 0,
    END_RANGE_NVX :: 7,
    RANGE_SIZE_NVX :: 8,
    MAX_ENUM_NVX :: 2147483647,
};

VkObjectEntryTypeNVX :: enum {
    DESCRIPTOR_SET_NVX :: 0,
    PIPELINE_NVX :: 1,
    INDEX_BUFFER_NVX :: 2,
    VERTEX_BUFFER_NVX :: 3,
    PUSH_CONSTANT_NVX :: 4,
    BEGIN_RANGE_NVX :: 0,
    END_RANGE_NVX :: 4,
    RANGE_SIZE_NVX :: 5,
    MAX_ENUM_NVX :: 2147483647,
};

VkIndirectCommandsLayoutUsageFlagBitsNVX :: enum {
    UNORDERED_SEQUENCES_BIT_NVX :: 1,
    SPARSE_SEQUENCES_BIT_NVX :: 2,
    EMPTY_EXECUTIONS_BIT_NVX :: 4,
    INDEXED_SEQUENCES_BIT_NVX :: 8,
    FLAG_BITS_MAX_ENUM_NVX :: 2147483647,
};

VkIndirectCommandsLayoutUsageFlagsNVX :: VkFlags;

VkObjectEntryUsageFlagBitsNVX :: enum {
    GRAPHICS_BIT_NVX :: 1,
    COMPUTE_BIT_NVX :: 2,
    FLAG_BITS_MAX_ENUM_NVX :: 2147483647,
};

VkObjectEntryUsageFlagsNVX :: VkFlags;

VkDeviceGeneratedCommandsFeaturesNVX :: struct {
    sType: VkStructureType,
    pNext: *u8,
    computeBindingPointSupport: VkBool32,
};

VkDeviceGeneratedCommandsLimitsNVX :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxIndirectCommandsLayoutTokenCount: u32,
    maxObjectEntryCounts: u32,
    minSequenceCountBufferOffsetAlignment: u32,
    minSequenceIndexBufferOffsetAlignment: u32,
    minCommandsTokenBufferOffsetAlignment: u32,
};

VkIndirectCommandsTokenNVX :: struct {
    tokenType: VkIndirectCommandsTokenTypeNVX,
    buffer: VkBuffer,
    offset: VkDeviceSize,
};

VkIndirectCommandsLayoutTokenNVX :: struct {
    tokenType: VkIndirectCommandsTokenTypeNVX,
    bindingUnit: u32,
    dynamicCount: u32,
    divisor: u32,
};

VkIndirectCommandsLayoutCreateInfoNVX :: struct {
    sType: VkStructureType,
    pNext: *u8,
    pipelineBindPoint: VkPipelineBindPoint,
    flags: VkIndirectCommandsLayoutUsageFlagsNVX,
    tokenCount: u32,
    pTokens: *VkIndirectCommandsLayoutTokenNVX,
};

VkCmdProcessCommandsInfoNVX :: struct {
    sType: VkStructureType,
    pNext: *u8,
    objectTable: VkObjectTableNVX,
    indirectCommandsLayout: VkIndirectCommandsLayoutNVX,
    indirectCommandsTokenCount: u32,
    pIndirectCommandsTokens: *VkIndirectCommandsTokenNVX,
    maxSequencesCount: u32,
    targetCommandBuffer: VkCommandBuffer,
    sequencesCountBuffer: VkBuffer,
    sequencesCountOffset: VkDeviceSize,
    sequencesIndexBuffer: VkBuffer,
    sequencesIndexOffset: VkDeviceSize,
};

VkCmdReserveSpaceForCommandsInfoNVX :: struct {
    sType: VkStructureType,
    pNext: *u8,
    objectTable: VkObjectTableNVX,
    indirectCommandsLayout: VkIndirectCommandsLayoutNVX,
    maxSequencesCount: u32,
};

VkObjectTableCreateInfoNVX :: struct {
    sType: VkStructureType,
    pNext: *u8,
    objectCount: u32,
    pObjectEntryTypes: *VkObjectEntryTypeNVX,
    pObjectEntryCounts: *u32,
    pObjectEntryUsageFlags: *VkObjectEntryUsageFlagsNVX,
    maxUniformBuffersPerDescriptor: u32,
    maxStorageBuffersPerDescriptor: u32,
    maxStorageImagesPerDescriptor: u32,
    maxSampledImagesPerDescriptor: u32,
    maxPipelineLayouts: u32,
};

VkObjectTableEntryNVX :: struct {
    type: VkObjectEntryTypeNVX,
    flags: VkObjectEntryUsageFlagsNVX,
};

VkObjectTablePipelineEntryNVX :: struct {
    type: VkObjectEntryTypeNVX,
    flags: VkObjectEntryUsageFlagsNVX,
    pipeline: VkPipeline,
};

VkObjectTableDescriptorSetEntryNVX :: struct {
    type: VkObjectEntryTypeNVX,
    flags: VkObjectEntryUsageFlagsNVX,
    pipelineLayout: VkPipelineLayout,
    descriptorSet: VkDescriptorSet,
};

VkObjectTableVertexBufferEntryNVX :: struct {
    type: VkObjectEntryTypeNVX,
    flags: VkObjectEntryUsageFlagsNVX,
    buffer: VkBuffer,
};

VkObjectTableIndexBufferEntryNVX :: struct {
    type: VkObjectEntryTypeNVX,
    flags: VkObjectEntryUsageFlagsNVX,
    buffer: VkBuffer,
    indexType: VkIndexType,
};

VkObjectTablePushConstantEntryNVX :: struct {
    type: VkObjectEntryTypeNVX,
    flags: VkObjectEntryUsageFlagsNVX,
    pipelineLayout: VkPipelineLayout,
    stageFlags: VkShaderStageFlags,
};

PFN_vkCmdProcessCommandsNVX :: *fn (_0: VkCommandBuffer, _1: *VkCmdProcessCommandsInfoNVX) ;

PFN_vkCmdReserveSpaceForCommandsNVX :: *fn (_0: VkCommandBuffer, _1: *VkCmdReserveSpaceForCommandsInfoNVX) ;

PFN_vkCreateIndirectCommandsLayoutNVX :: *fn (_0: VkDevice, _1: *VkIndirectCommandsLayoutCreateInfoNVX, _2: *VkAllocationCallbacks, _3: *VkIndirectCommandsLayoutNVX) VkResult;

PFN_vkDestroyIndirectCommandsLayoutNVX :: *fn (_0: VkDevice, _1: VkIndirectCommandsLayoutNVX, _2: *VkAllocationCallbacks) ;

PFN_vkCreateObjectTableNVX :: *fn (_0: VkDevice, _1: *VkObjectTableCreateInfoNVX, _2: *VkAllocationCallbacks, _3: *VkObjectTableNVX) VkResult;

PFN_vkDestroyObjectTableNVX :: *fn (_0: VkDevice, _1: VkObjectTableNVX, _2: *VkAllocationCallbacks) ;

PFN_vkRegisterObjectsNVX :: *fn (_0: VkDevice, _1: VkObjectTableNVX, _2: u32, _3: **VkObjectTableEntryNVX, _4: *u32) VkResult;

PFN_vkUnregisterObjectsNVX :: *fn (_0: VkDevice, _1: VkObjectTableNVX, _2: u32, _3: *VkObjectEntryTypeNVX, _4: *u32) VkResult;

PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX :: *fn (_0: VkPhysicalDevice, _1: *VkDeviceGeneratedCommandsFeaturesNVX, _2: *VkDeviceGeneratedCommandsLimitsNVX) ;

vkCmdProcessCommandsNVX :: fn (commandBuffer: VkCommandBuffer, pProcessCommandsInfo: *VkCmdProcessCommandsInfoNVX)  #extern;
vkCmdReserveSpaceForCommandsNVX :: fn (commandBuffer: VkCommandBuffer, pReserveSpaceInfo: *VkCmdReserveSpaceForCommandsInfoNVX)  #extern;
vkCreateIndirectCommandsLayoutNVX :: fn (device: VkDevice, pCreateInfo: *VkIndirectCommandsLayoutCreateInfoNVX, pAllocator: *VkAllocationCallbacks, pIndirectCommandsLayout: *VkIndirectCommandsLayoutNVX) VkResult #extern;
vkDestroyIndirectCommandsLayoutNVX :: fn (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutNVX, pAllocator: *VkAllocationCallbacks)  #extern;
vkCreateObjectTableNVX :: fn (device: VkDevice, pCreateInfo: *VkObjectTableCreateInfoNVX, pAllocator: *VkAllocationCallbacks, pObjectTable: *VkObjectTableNVX) VkResult #extern;
vkDestroyObjectTableNVX :: fn (device: VkDevice, objectTable: VkObjectTableNVX, pAllocator: *VkAllocationCallbacks)  #extern;
vkRegisterObjectsNVX :: fn (device: VkDevice, objectTable: VkObjectTableNVX, objectCount: u32, ppObjectTableEntries: **VkObjectTableEntryNVX, pObjectIndices: *u32) VkResult #extern;
vkUnregisterObjectsNVX :: fn (device: VkDevice, objectTable: VkObjectTableNVX, objectCount: u32, pObjectEntryTypes: *VkObjectEntryTypeNVX, pObjectIndices: *u32) VkResult #extern;
vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX :: fn (physicalDevice: VkPhysicalDevice, pFeatures: *VkDeviceGeneratedCommandsFeaturesNVX, pLimits: *VkDeviceGeneratedCommandsLimitsNVX)  #extern;
VkViewportWScalingNV :: struct {
    xcoeff: f32,
    ycoeff: f32,
};

VkPipelineViewportWScalingStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    viewportWScalingEnable: VkBool32,
    viewportCount: u32,
    pViewportWScalings: *VkViewportWScalingNV,
};

PFN_vkCmdSetViewportWScalingNV :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkViewportWScalingNV) ;

vkCmdSetViewportWScalingNV :: fn (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *VkViewportWScalingNV)  #extern;
PFN_vkReleaseDisplayEXT :: *fn (_0: VkPhysicalDevice, _1: VkDisplayKHR) VkResult;

vkReleaseDisplayEXT :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) VkResult #extern;
VkSurfaceCounterFlagBitsEXT :: enum {
    VBLANK_EXT :: 1,
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647,
};

VkSurfaceCounterFlagsEXT :: VkFlags;

VkSurfaceCapabilities2EXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    minImageCount: u32,
    maxImageCount: u32,
    currentExtent: VkExtent2D,
    minImageExtent: VkExtent2D,
    maxImageExtent: VkExtent2D,
    maxImageArrayLayers: u32,
    supportedTransforms: VkSurfaceTransformFlagsKHR,
    currentTransform: VkSurfaceTransformFlagBitsKHR,
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    supportedUsageFlags: VkImageUsageFlags,
    supportedSurfaceCounters: VkSurfaceCounterFlagsEXT,
};

PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT :: *fn (_0: VkPhysicalDevice, _1: VkSurfaceKHR, _2: *VkSurfaceCapabilities2EXT) VkResult;

vkGetPhysicalDeviceSurfaceCapabilities2EXT :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *VkSurfaceCapabilities2EXT) VkResult #extern;
VkDisplayPowerStateEXT :: enum {
    OFF_EXT :: 0,
    SUSPEND_EXT :: 1,
    ON_EXT :: 2,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 2,
    RANGE_SIZE_EXT :: 3,
    MAX_ENUM_EXT :: 2147483647,
};

VkDeviceEventTypeEXT :: enum {
    DISPLAY_HOTPLUG_EXT :: 0,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 0,
    RANGE_SIZE_EXT :: 1,
    MAX_ENUM_EXT :: 2147483647,
};

VkDisplayEventTypeEXT :: enum {
    FIRST_PIXEL_OUT_EXT :: 0,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 0,
    RANGE_SIZE_EXT :: 1,
    MAX_ENUM_EXT :: 2147483647,
};

VkDisplayPowerInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    powerState: VkDisplayPowerStateEXT,
};

VkDeviceEventInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    deviceEvent: VkDeviceEventTypeEXT,
};

VkDisplayEventInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    displayEvent: VkDisplayEventTypeEXT,
};

VkSwapchainCounterCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    surfaceCounters: VkSurfaceCounterFlagsEXT,
};

PFN_vkDisplayPowerControlEXT :: *fn (_0: VkDevice, _1: VkDisplayKHR, _2: *VkDisplayPowerInfoEXT) VkResult;

PFN_vkRegisterDeviceEventEXT :: *fn (_0: VkDevice, _1: *VkDeviceEventInfoEXT, _2: *VkAllocationCallbacks, _3: *VkFence) VkResult;

PFN_vkRegisterDisplayEventEXT :: *fn (_0: VkDevice, _1: VkDisplayKHR, _2: *VkDisplayEventInfoEXT, _3: *VkAllocationCallbacks, _4: *VkFence) VkResult;

PFN_vkGetSwapchainCounterEXT :: *fn (_0: VkDevice, _1: VkSwapchainKHR, _2: VkSurfaceCounterFlagBitsEXT, _3: *u64) VkResult;

vkDisplayPowerControlEXT :: fn (device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *VkDisplayPowerInfoEXT) VkResult #extern;
vkRegisterDeviceEventEXT :: fn (device: VkDevice, pDeviceEventInfo: *VkDeviceEventInfoEXT, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) VkResult #extern;
vkRegisterDisplayEventEXT :: fn (device: VkDevice, display: VkDisplayKHR, pDisplayEventInfo: *VkDisplayEventInfoEXT, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) VkResult #extern;
vkGetSwapchainCounterEXT :: fn (device: VkDevice, swapchain: VkSwapchainKHR, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: *u64) VkResult #extern;
VkRefreshCycleDurationGOOGLE :: struct {
    refreshDuration: u64,
};

VkPastPresentationTimingGOOGLE :: struct {
    presentID: u32,
    desiredPresentTime: u64,
    actualPresentTime: u64,
    earliestPresentTime: u64,
    presentMargin: u64,
};

VkPresentTimeGOOGLE :: struct {
    presentID: u32,
    desiredPresentTime: u64,
};

VkPresentTimesInfoGOOGLE :: struct {
    sType: VkStructureType,
    pNext: *u8,
    swapchainCount: u32,
    pTimes: *VkPresentTimeGOOGLE,
};

PFN_vkGetRefreshCycleDurationGOOGLE :: *fn (_0: VkDevice, _1: VkSwapchainKHR, _2: *VkRefreshCycleDurationGOOGLE) VkResult;

PFN_vkGetPastPresentationTimingGOOGLE :: *fn (_0: VkDevice, _1: VkSwapchainKHR, _2: *u32, _3: *VkPastPresentationTimingGOOGLE) VkResult;

vkGetRefreshCycleDurationGOOGLE :: fn (device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *VkRefreshCycleDurationGOOGLE) VkResult #extern;
vkGetPastPresentationTimingGOOGLE :: fn (device: VkDevice, swapchain: VkSwapchainKHR, pPresentationTimingCount: *u32, pPresentationTimings: *VkPastPresentationTimingGOOGLE) VkResult #extern;
VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX :: struct {
    sType: VkStructureType,
    pNext: *u8,
    perViewPositionAllComponents: VkBool32,
};

VkViewportCoordinateSwizzleNV :: enum {
    POSITIVE_X_NV :: 0,
    NEGATIVE_X_NV :: 1,
    POSITIVE_Y_NV :: 2,
    NEGATIVE_Y_NV :: 3,
    POSITIVE_Z_NV :: 4,
    NEGATIVE_Z_NV :: 5,
    POSITIVE_W_NV :: 6,
    NEGATIVE_W_NV :: 7,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 7,
    RANGE_SIZE_NV :: 8,
    MAX_ENUM_NV :: 2147483647,
};

VkPipelineViewportSwizzleStateCreateFlagsNV :: VkFlags;

VkViewportSwizzleNV :: struct {
    x: VkViewportCoordinateSwizzleNV,
    y: VkViewportCoordinateSwizzleNV,
    z: VkViewportCoordinateSwizzleNV,
    w: VkViewportCoordinateSwizzleNV,
};

VkPipelineViewportSwizzleStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineViewportSwizzleStateCreateFlagsNV,
    viewportCount: u32,
    pViewportSwizzles: *VkViewportSwizzleNV,
};

VkDiscardRectangleModeEXT :: enum {
    INCLUSIVE_EXT :: 0,
    EXCLUSIVE_EXT :: 1,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 1,
    RANGE_SIZE_EXT :: 2,
    MAX_ENUM_EXT :: 2147483647,
};

VkPipelineDiscardRectangleStateCreateFlagsEXT :: VkFlags;

VkPhysicalDeviceDiscardRectanglePropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxDiscardRectangles: u32,
};

VkPipelineDiscardRectangleStateCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineDiscardRectangleStateCreateFlagsEXT,
    discardRectangleMode: VkDiscardRectangleModeEXT,
    discardRectangleCount: u32,
    pDiscardRectangles: *VkRect2D,
};

PFN_vkCmdSetDiscardRectangleEXT :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkRect2D) ;

vkCmdSetDiscardRectangleEXT :: fn (commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *VkRect2D)  #extern;
VkConservativeRasterizationModeEXT :: enum {
    DISABLED_EXT :: 0,
    OVERESTIMATE_EXT :: 1,
    UNDERESTIMATE_EXT :: 2,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 2,
    RANGE_SIZE_EXT :: 3,
    MAX_ENUM_EXT :: 2147483647,
};

VkPipelineRasterizationConservativeStateCreateFlagsEXT :: VkFlags;

VkPhysicalDeviceConservativeRasterizationPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    primitiveOverestimationSize: f32,
    maxExtraPrimitiveOverestimationSize: f32,
    extraPrimitiveOverestimationSizeGranularity: f32,
    primitiveUnderestimation: VkBool32,
    conservativePointAndLineRasterization: VkBool32,
    degenerateTrianglesRasterized: VkBool32,
    degenerateLinesRasterized: VkBool32,
    fullyCoveredFragmentShaderInputVariable: VkBool32,
    conservativeRasterizationPostDepthCoverage: VkBool32,
};

VkPipelineRasterizationConservativeStateCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT,
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
    extraPrimitiveOverestimationSize: f32,
};

VkPipelineRasterizationDepthClipStateCreateFlagsEXT :: VkFlags;

VkPhysicalDeviceDepthClipEnableFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    depthClipEnable: VkBool32,
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT,
    depthClipEnable: VkBool32,
};

VkXYColorEXT :: struct {
    x: f32,
    y: f32,
};

VkHdrMetadataEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    displayPrimaryRed: VkXYColorEXT,
    displayPrimaryGreen: VkXYColorEXT,
    displayPrimaryBlue: VkXYColorEXT,
    whitePoint: VkXYColorEXT,
    maxLuminance: f32,
    minLuminance: f32,
    maxContentLightLevel: f32,
    maxFrameAverageLightLevel: f32,
};

PFN_vkSetHdrMetadataEXT :: *fn (_0: VkDevice, _1: u32, _2: *VkSwapchainKHR, _3: *VkHdrMetadataEXT) ;

vkSetHdrMetadataEXT :: fn (device: VkDevice, swapchainCount: u32, pSwapchains: *VkSwapchainKHR, pMetadata: *VkHdrMetadataEXT)  #extern;
VkDebugUtilsMessengerCallbackDataFlagsEXT :: VkFlags;

VkDebugUtilsMessengerCreateFlagsEXT :: VkFlags;

VkDebugUtilsMessageSeverityFlagBitsEXT :: enum {
    VERBOSE_BIT_EXT :: 1,
    INFO_BIT_EXT :: 16,
    WARNING_BIT_EXT :: 256,
    ERROR_BIT_EXT :: 4096,
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647,
};

VkDebugUtilsMessageSeverityFlagsEXT :: VkFlags;

VkDebugUtilsMessageTypeFlagBitsEXT :: enum {
    GENERAL_BIT_EXT :: 1,
    VALIDATION_BIT_EXT :: 2,
    PERFORMANCE_BIT_EXT :: 4,
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647,
};

VkDebugUtilsMessageTypeFlagsEXT :: VkFlags;

VkDebugUtilsObjectNameInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    objectType: VkObjectType,
    objectHandle: u64,
    pObjectName: *u8,
};

VkDebugUtilsObjectTagInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    objectType: VkObjectType,
    objectHandle: u64,
    tagName: u64,
    tagSize: usize,
    pTag: *u8,
};

VkDebugUtilsLabelEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    pLabelName: *u8,
    color: [4]f32,
};

VkDebugUtilsMessengerCallbackDataEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDebugUtilsMessengerCallbackDataFlagsEXT,
    pMessageIdName: *u8,
    messageIdNumber: s32,
    pMessage: *s8,
    queueLabelCount: u32,
    pQueueLabels: *VkDebugUtilsLabelEXT,
    cmdBufLabelCount: u32,
    pCmdBufLabels: *VkDebugUtilsLabelEXT,
    objectCount: u32,
    pObjects: *VkDebugUtilsObjectNameInfoEXT,
};

PFN_vkDebugUtilsMessengerCallbackEXT :: *fn (_0: VkDebugUtilsMessageSeverityFlagBitsEXT, _1: VkDebugUtilsMessageTypeFlagsEXT, _2: *VkDebugUtilsMessengerCallbackDataEXT, _3: *u8) VkBool32;

VkDebugUtilsMessengerCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkDebugUtilsMessengerCreateFlagsEXT,
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
    messageType: VkDebugUtilsMessageTypeFlagsEXT,
    pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT,
    pUserData: *u8,
};

PFN_vkSetDebugUtilsObjectNameEXT :: *fn (_0: VkDevice, _1: *VkDebugUtilsObjectNameInfoEXT) VkResult;

PFN_vkSetDebugUtilsObjectTagEXT :: *fn (_0: VkDevice, _1: *VkDebugUtilsObjectTagInfoEXT) VkResult;

PFN_vkQueueBeginDebugUtilsLabelEXT :: *fn (_0: VkQueue, _1: *VkDebugUtilsLabelEXT) ;

PFN_vkQueueEndDebugUtilsLabelEXT :: *fn (_0: VkQueue) ;

PFN_vkQueueInsertDebugUtilsLabelEXT :: *fn (_0: VkQueue, _1: *VkDebugUtilsLabelEXT) ;

PFN_vkCmdBeginDebugUtilsLabelEXT :: *fn (_0: VkCommandBuffer, _1: *VkDebugUtilsLabelEXT) ;

PFN_vkCmdEndDebugUtilsLabelEXT :: *fn (_0: VkCommandBuffer) ;

PFN_vkCmdInsertDebugUtilsLabelEXT :: *fn (_0: VkCommandBuffer, _1: *VkDebugUtilsLabelEXT) ;

PFN_vkCreateDebugUtilsMessengerEXT :: *fn (_0: VkInstance, _1: *VkDebugUtilsMessengerCreateInfoEXT, _2: *VkAllocationCallbacks, _3: *VkDebugUtilsMessengerEXT) VkResult;

PFN_vkDestroyDebugUtilsMessengerEXT :: *fn (_0: VkInstance, _1: VkDebugUtilsMessengerEXT, _2: *VkAllocationCallbacks) ;

PFN_vkSubmitDebugUtilsMessageEXT :: *fn (_0: VkInstance, _1: VkDebugUtilsMessageSeverityFlagBitsEXT, _2: VkDebugUtilsMessageTypeFlagsEXT, _3: *VkDebugUtilsMessengerCallbackDataEXT) ;

vkSetDebugUtilsObjectNameEXT :: fn (device: VkDevice, pNameInfo: *VkDebugUtilsObjectNameInfoEXT) VkResult #extern;
vkSetDebugUtilsObjectTagEXT :: fn (device: VkDevice, pTagInfo: *VkDebugUtilsObjectTagInfoEXT) VkResult #extern;
vkQueueBeginDebugUtilsLabelEXT :: fn (queue: VkQueue, pLabelInfo: *VkDebugUtilsLabelEXT)  #extern;
vkQueueEndDebugUtilsLabelEXT :: fn (queue: VkQueue)  #extern;
vkQueueInsertDebugUtilsLabelEXT :: fn (queue: VkQueue, pLabelInfo: *VkDebugUtilsLabelEXT)  #extern;
vkCmdBeginDebugUtilsLabelEXT :: fn (commandBuffer: VkCommandBuffer, pLabelInfo: *VkDebugUtilsLabelEXT)  #extern;
vkCmdEndDebugUtilsLabelEXT :: fn (commandBuffer: VkCommandBuffer)  #extern;
vkCmdInsertDebugUtilsLabelEXT :: fn (commandBuffer: VkCommandBuffer, pLabelInfo: *VkDebugUtilsLabelEXT)  #extern;
vkCreateDebugUtilsMessengerEXT :: fn (instance: VkInstance, pCreateInfo: *VkDebugUtilsMessengerCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pMessenger: *VkDebugUtilsMessengerEXT) VkResult #extern;
vkDestroyDebugUtilsMessengerEXT :: fn (instance: VkInstance, messenger: VkDebugUtilsMessengerEXT, pAllocator: *VkAllocationCallbacks)  #extern;
vkSubmitDebugUtilsMessageEXT :: fn (instance: VkInstance, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *VkDebugUtilsMessengerCallbackDataEXT)  #extern;
VkSamplerReductionModeEXT :: enum {
    WEIGHTED_AVERAGE_EXT :: 0,
    MIN_EXT :: 1,
    MAX_EXT :: 2,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 2,
    RANGE_SIZE_EXT :: 3,
    MAX_ENUM_EXT :: 2147483647,
};

VkSamplerReductionModeCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    reductionMode: VkSamplerReductionModeEXT,
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    filterMinmaxSingleComponentFormats: VkBool32,
    filterMinmaxImageComponentMapping: VkBool32,
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    inlineUniformBlock: VkBool32,
    descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxInlineUniformBlockSize: u32,
    maxPerStageDescriptorInlineUniformBlocks: u32,
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
    maxDescriptorSetInlineUniformBlocks: u32,
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
};

VkWriteDescriptorSetInlineUniformBlockEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    dataSize: u32,
    pData: *u8,
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxInlineUniformBlockBindings: u32,
};

VkSampleLocationEXT :: struct {
    x: f32,
    y: f32,
};

VkSampleLocationsInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    sampleLocationsPerPixel: VkSampleCountFlagBits,
    sampleLocationGridSize: VkExtent2D,
    sampleLocationsCount: u32,
    pSampleLocations: *VkSampleLocationEXT,
};

VkAttachmentSampleLocationsEXT :: struct {
    attachmentIndex: u32,
    sampleLocationsInfo: VkSampleLocationsInfoEXT,
};

VkSubpassSampleLocationsEXT :: struct {
    subpassIndex: u32,
    sampleLocationsInfo: VkSampleLocationsInfoEXT,
};

VkRenderPassSampleLocationsBeginInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    attachmentInitialSampleLocationsCount: u32,
    pAttachmentInitialSampleLocations: *VkAttachmentSampleLocationsEXT,
    postSubpassSampleLocationsCount: u32,
    pPostSubpassSampleLocations: *VkSubpassSampleLocationsEXT,
};

VkPipelineSampleLocationsStateCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    sampleLocationsEnable: VkBool32,
    sampleLocationsInfo: VkSampleLocationsInfoEXT,
};

VkPhysicalDeviceSampleLocationsPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    sampleLocationSampleCounts: VkSampleCountFlags,
    maxSampleLocationGridSize: VkExtent2D,
    sampleLocationCoordinateRange: [2]f32,
    sampleLocationSubPixelBits: u32,
    variableSampleLocations: VkBool32,
};

VkMultisamplePropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxSampleLocationGridSize: VkExtent2D,
};

PFN_vkCmdSetSampleLocationsEXT :: *fn (_0: VkCommandBuffer, _1: *VkSampleLocationsInfoEXT) ;

PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT :: *fn (_0: VkPhysicalDevice, _1: VkSampleCountFlagBits, _2: *VkMultisamplePropertiesEXT) ;

vkCmdSetSampleLocationsEXT :: fn (commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *VkSampleLocationsInfoEXT)  #extern;
vkGetPhysicalDeviceMultisamplePropertiesEXT :: fn (physicalDevice: VkPhysicalDevice, samples: VkSampleCountFlagBits, pMultisampleProperties: *VkMultisamplePropertiesEXT)  #extern;
VkBlendOverlapEXT :: enum {
    UNCORRELATED_EXT :: 0,
    DISJOINT_EXT :: 1,
    CONJOINT_EXT :: 2,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 2,
    RANGE_SIZE_EXT :: 3,
    MAX_ENUM_EXT :: 2147483647,
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    advancedBlendCoherentOperations: VkBool32,
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    advancedBlendMaxColorAttachments: u32,
    advancedBlendIndependentBlend: VkBool32,
    advancedBlendNonPremultipliedSrcColor: VkBool32,
    advancedBlendNonPremultipliedDstColor: VkBool32,
    advancedBlendCorrelatedOverlap: VkBool32,
    advancedBlendAllOperations: VkBool32,
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    srcPremultiplied: VkBool32,
    dstPremultiplied: VkBool32,
    blendOverlap: VkBlendOverlapEXT,
};

VkPipelineCoverageToColorStateCreateFlagsNV :: VkFlags;

VkPipelineCoverageToColorStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineCoverageToColorStateCreateFlagsNV,
    coverageToColorEnable: VkBool32,
    coverageToColorLocation: u32,
};

VkCoverageModulationModeNV :: enum {
    NONE_NV :: 0,
    RGB_NV :: 1,
    ALPHA_NV :: 2,
    RGBA_NV :: 3,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 3,
    RANGE_SIZE_NV :: 4,
    MAX_ENUM_NV :: 2147483647,
};

VkPipelineCoverageModulationStateCreateFlagsNV :: VkFlags;

VkPipelineCoverageModulationStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineCoverageModulationStateCreateFlagsNV,
    coverageModulationMode: VkCoverageModulationModeNV,
    coverageModulationTableEnable: VkBool32,
    coverageModulationTableCount: u32,
    pCoverageModulationTable: *f32,
};

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderSMCount: u32,
    shaderWarpsPerSM: u32,
};

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderSMBuiltins: VkBool32,
};

VkDrmFormatModifierPropertiesEXT :: struct {
    drmFormatModifier: u64,
    drmFormatModifierPlaneCount: u32,
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags,
};

VkDrmFormatModifierPropertiesListEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    drmFormatModifierCount: u32,
    pDrmFormatModifierProperties: *VkDrmFormatModifierPropertiesEXT,
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    drmFormatModifier: u64,
    sharingMode: VkSharingMode,
    queueFamilyIndexCount: u32,
    pQueueFamilyIndices: *u32,
};

VkImageDrmFormatModifierListCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    drmFormatModifierCount: u32,
    pDrmFormatModifiers: *u64,
};

VkImageDrmFormatModifierExplicitCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    drmFormatModifier: u64,
    drmFormatModifierPlaneCount: u32,
    pPlaneLayouts: *VkSubresourceLayout,
};

VkImageDrmFormatModifierPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    drmFormatModifier: u64,
};

PFN_vkGetImageDrmFormatModifierPropertiesEXT :: *fn (_0: VkDevice, _1: VkImage, _2: *VkImageDrmFormatModifierPropertiesEXT) VkResult;

vkGetImageDrmFormatModifierPropertiesEXT :: fn (device: VkDevice, image: VkImage, pProperties: *VkImageDrmFormatModifierPropertiesEXT) VkResult #extern;
VkValidationCacheHeaderVersionEXT :: enum {
    ONE_EXT :: 1,
    BEGIN_RANGE_EXT :: 1,
    END_RANGE_EXT :: 1,
    RANGE_SIZE_EXT :: 1,
    MAX_ENUM_EXT :: 2147483647,
};

VkValidationCacheCreateFlagsEXT :: VkFlags;

VkValidationCacheCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkValidationCacheCreateFlagsEXT,
    initialDataSize: usize,
    pInitialData: *u8,
};

VkShaderModuleValidationCacheCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    validationCache: VkValidationCacheEXT,
};

PFN_vkCreateValidationCacheEXT :: *fn (_0: VkDevice, _1: *VkValidationCacheCreateInfoEXT, _2: *VkAllocationCallbacks, _3: *VkValidationCacheEXT) VkResult;

PFN_vkDestroyValidationCacheEXT :: *fn (_0: VkDevice, _1: VkValidationCacheEXT, _2: *VkAllocationCallbacks) ;

PFN_vkMergeValidationCachesEXT :: *fn (_0: VkDevice, _1: VkValidationCacheEXT, _2: u32, _3: *VkValidationCacheEXT) VkResult;

PFN_vkGetValidationCacheDataEXT :: *fn (_0: VkDevice, _1: VkValidationCacheEXT, _2: *usize, _3: *u8) VkResult;

vkCreateValidationCacheEXT :: fn (device: VkDevice, pCreateInfo: *VkValidationCacheCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pValidationCache: *VkValidationCacheEXT) VkResult #extern;
vkDestroyValidationCacheEXT :: fn (device: VkDevice, validationCache: VkValidationCacheEXT, pAllocator: *VkAllocationCallbacks)  #extern;
vkMergeValidationCachesEXT :: fn (device: VkDevice, dstCache: VkValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *VkValidationCacheEXT) VkResult #extern;
vkGetValidationCacheDataEXT :: fn (device: VkDevice, validationCache: VkValidationCacheEXT, pDataSize: *usize, pData: *u8) VkResult #extern;
VkDescriptorBindingFlagBitsEXT :: enum {
    UPDATE_AFTER_BIND_BIT_EXT :: 1,
    UPDATE_UNUSED_WHILE_PENDING_BIT_EXT :: 2,
    PARTIALLY_BOUND_BIT_EXT :: 4,
    VARIABLE_DESCRIPTOR_COUNT_BIT_EXT :: 8,
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647,
};

VkDescriptorBindingFlagsEXT :: VkFlags;

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    bindingCount: u32,
    pBindingFlags: *VkDescriptorBindingFlagsEXT,
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderInputAttachmentArrayDynamicIndexing: VkBool32,
    shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
    shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
    shaderUniformBufferArrayNonUniformIndexing: VkBool32,
    shaderSampledImageArrayNonUniformIndexing: VkBool32,
    shaderStorageBufferArrayNonUniformIndexing: VkBool32,
    shaderStorageImageArrayNonUniformIndexing: VkBool32,
    shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
    shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
    shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
    descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
    descriptorBindingSampledImageUpdateAfterBind: VkBool32,
    descriptorBindingStorageImageUpdateAfterBind: VkBool32,
    descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
    descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
    descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
    descriptorBindingUpdateUnusedWhilePending: VkBool32,
    descriptorBindingPartiallyBound: VkBool32,
    descriptorBindingVariableDescriptorCount: VkBool32,
    runtimeDescriptorArray: VkBool32,
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxUpdateAfterBindDescriptorsInAllPools: u32,
    shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
    shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
    shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
    shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
    shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
    robustBufferAccessUpdateAfterBind: VkBool32,
    quadDivergentImplicitLod: VkBool32,
    maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    maxPerStageUpdateAfterBindResources: u32,
    maxDescriptorSetUpdateAfterBindSamplers: u32,
    maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    maxDescriptorSetUpdateAfterBindSampledImages: u32,
    maxDescriptorSetUpdateAfterBindStorageImages: u32,
    maxDescriptorSetUpdateAfterBindInputAttachments: u32,
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    descriptorSetCount: u32,
    pDescriptorCounts: *u32,
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxVariableDescriptorCount: u32,
};

VkShadingRatePaletteEntryNV :: enum {
    NO_INVOCATIONS_NV :: 0,
    _16_INVOCATIONS_PER_PIXEL_NV :: 1,
    _8_INVOCATIONS_PER_PIXEL_NV :: 2,
    _4_INVOCATIONS_PER_PIXEL_NV :: 3,
    _2_INVOCATIONS_PER_PIXEL_NV :: 4,
    _1_INVOCATION_PER_PIXEL_NV :: 5,
    _1_INVOCATION_PER_2X1_PIXELS_NV :: 6,
    _1_INVOCATION_PER_1X2_PIXELS_NV :: 7,
    _1_INVOCATION_PER_2X2_PIXELS_NV :: 8,
    _1_INVOCATION_PER_4X2_PIXELS_NV :: 9,
    _1_INVOCATION_PER_2X4_PIXELS_NV :: 10,
    _1_INVOCATION_PER_4X4_PIXELS_NV :: 11,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 11,
    RANGE_SIZE_NV :: 12,
    MAX_ENUM_NV :: 2147483647,
};

VkCoarseSampleOrderTypeNV :: enum {
    DEFAULT_NV :: 0,
    CUSTOM_NV :: 1,
    PIXEL_MAJOR_NV :: 2,
    SAMPLE_MAJOR_NV :: 3,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 3,
    RANGE_SIZE_NV :: 4,
    MAX_ENUM_NV :: 2147483647,
};

VkShadingRatePaletteNV :: struct {
    shadingRatePaletteEntryCount: u32,
    pShadingRatePaletteEntries: *VkShadingRatePaletteEntryNV,
};

VkPipelineViewportShadingRateImageStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shadingRateImageEnable: VkBool32,
    viewportCount: u32,
    pShadingRatePalettes: *VkShadingRatePaletteNV,
};

VkPhysicalDeviceShadingRateImageFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shadingRateImage: VkBool32,
    shadingRateCoarseSampleOrder: VkBool32,
};

VkPhysicalDeviceShadingRateImagePropertiesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shadingRateTexelSize: VkExtent2D,
    shadingRatePaletteSize: u32,
    shadingRateMaxCoarseSamples: u32,
};

VkCoarseSampleLocationNV :: struct {
    pixelX: u32,
    pixelY: u32,
    sample: u32,
};

VkCoarseSampleOrderCustomNV :: struct {
    shadingRate: VkShadingRatePaletteEntryNV,
    sampleCount: u32,
    sampleLocationCount: u32,
    pSampleLocations: *VkCoarseSampleLocationNV,
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    sampleOrderType: VkCoarseSampleOrderTypeNV,
    customSampleOrderCount: u32,
    pCustomSampleOrders: *VkCoarseSampleOrderCustomNV,
};

PFN_vkCmdBindShadingRateImageNV :: *fn (_0: VkCommandBuffer, _1: VkImageView, _2: VkImageLayout) ;

PFN_vkCmdSetViewportShadingRatePaletteNV :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkShadingRatePaletteNV) ;

PFN_vkCmdSetCoarseSampleOrderNV :: *fn (_0: VkCommandBuffer, _1: VkCoarseSampleOrderTypeNV, _2: u32, _3: *VkCoarseSampleOrderCustomNV) ;

vkCmdBindShadingRateImageNV :: fn (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout)  #extern;
vkCmdSetViewportShadingRatePaletteNV :: fn (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *VkShadingRatePaletteNV)  #extern;
vkCmdSetCoarseSampleOrderNV :: fn (commandBuffer: VkCommandBuffer, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *VkCoarseSampleOrderCustomNV)  #extern;
VkRayTracingShaderGroupTypeNV :: enum {
    GENERAL_NV :: 0,
    TRIANGLES_HIT_GROUP_NV :: 1,
    PROCEDURAL_HIT_GROUP_NV :: 2,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 2,
    RANGE_SIZE_NV :: 3,
    MAX_ENUM_NV :: 2147483647,
};

VkGeometryTypeNV :: enum {
    TRIANGLES_NV :: 0,
    AABBS_NV :: 1,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 1,
    RANGE_SIZE_NV :: 2,
    MAX_ENUM_NV :: 2147483647,
};

VkAccelerationStructureTypeNV :: enum {
    TOP_LEVEL_NV :: 0,
    BOTTOM_LEVEL_NV :: 1,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 1,
    RANGE_SIZE_NV :: 2,
    MAX_ENUM_NV :: 2147483647,
};

VkCopyAccelerationStructureModeNV :: enum {
    CLONE_NV :: 0,
    COMPACT_NV :: 1,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 1,
    RANGE_SIZE_NV :: 2,
    MAX_ENUM_NV :: 2147483647,
};

VkAccelerationStructureMemoryRequirementsTypeNV :: enum {
    OBJECT_NV :: 0,
    BUILD_SCRATCH_NV :: 1,
    UPDATE_SCRATCH_NV :: 2,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 2,
    RANGE_SIZE_NV :: 3,
    MAX_ENUM_NV :: 2147483647,
};

VkGeometryFlagBitsNV :: enum {
    OPAQUE_BIT_NV :: 1,
    NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV :: 2,
    FLAG_BITS_MAX_ENUM_NV :: 2147483647,
};

VkGeometryFlagsNV :: VkFlags;

VkGeometryInstanceFlagBitsNV :: enum {
    TRIANGLE_CULL_DISABLE_BIT_NV :: 1,
    TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV :: 2,
    FORCE_OPAQUE_BIT_NV :: 4,
    FORCE_NO_OPAQUE_BIT_NV :: 8,
    FLAG_BITS_MAX_ENUM_NV :: 2147483647,
};

VkGeometryInstanceFlagsNV :: VkFlags;

VkBuildAccelerationStructureFlagBitsNV :: enum {
    ALLOW_UPDATE_BIT_NV :: 1,
    ALLOW_COMPACTION_BIT_NV :: 2,
    PREFER_FAST_TRACE_BIT_NV :: 4,
    PREFER_FAST_BUILD_BIT_NV :: 8,
    LOW_MEMORY_BIT_NV :: 16,
    FLAG_BITS_MAX_ENUM_NV :: 2147483647,
};

VkBuildAccelerationStructureFlagsNV :: VkFlags;

VkRayTracingShaderGroupCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    type: VkRayTracingShaderGroupTypeNV,
    generalShader: u32,
    closestHitShader: u32,
    anyHitShader: u32,
    intersectionShader: u32,
};

VkRayTracingPipelineCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineCreateFlags,
    stageCount: u32,
    pStages: *VkPipelineShaderStageCreateInfo,
    groupCount: u32,
    pGroups: *VkRayTracingShaderGroupCreateInfoNV,
    maxRecursionDepth: u32,
    layout: VkPipelineLayout,
    basePipelineHandle: VkPipeline,
    basePipelineIndex: s32,
};

VkGeometryTrianglesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    vertexData: VkBuffer,
    vertexOffset: VkDeviceSize,
    vertexCount: u32,
    vertexStride: VkDeviceSize,
    vertexFormat: VkFormat,
    indexData: VkBuffer,
    indexOffset: VkDeviceSize,
    indexCount: u32,
    indexType: VkIndexType,
    transformData: VkBuffer,
    transformOffset: VkDeviceSize,
};

VkGeometryAABBNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    aabbData: VkBuffer,
    numAABBs: u32,
    stride: u32,
    offset: VkDeviceSize,
};

VkGeometryDataNV :: struct {
    triangles: VkGeometryTrianglesNV,
    aabbs: VkGeometryAABBNV,
};

VkGeometryNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    geometryType: VkGeometryTypeNV,
    geometry: VkGeometryDataNV,
    flags: VkGeometryFlagsNV,
};

VkAccelerationStructureInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    type: VkAccelerationStructureTypeNV,
    flags: VkBuildAccelerationStructureFlagsNV,
    instanceCount: u32,
    geometryCount: u32,
    pGeometries: *VkGeometryNV,
};

VkAccelerationStructureCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    compactedSize: VkDeviceSize,
    info: VkAccelerationStructureInfoNV,
};

VkBindAccelerationStructureMemoryInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    accelerationStructure: VkAccelerationStructureNV,
    memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize,
    deviceIndexCount: u32,
    pDeviceIndices: *u32,
};

VkWriteDescriptorSetAccelerationStructureNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    accelerationStructureCount: u32,
    pAccelerationStructures: *VkAccelerationStructureNV,
};

VkAccelerationStructureMemoryRequirementsInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    type: VkAccelerationStructureMemoryRequirementsTypeNV,
    accelerationStructure: VkAccelerationStructureNV,
};

VkPhysicalDeviceRayTracingPropertiesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderGroupHandleSize: u32,
    maxRecursionDepth: u32,
    maxShaderGroupStride: u32,
    shaderGroupBaseAlignment: u32,
    maxGeometryCount: u64,
    maxInstanceCount: u64,
    maxTriangleCount: u64,
    maxDescriptorSetAccelerationStructures: u32,
};

PFN_vkCreateAccelerationStructureNV :: *fn (_0: VkDevice, _1: *VkAccelerationStructureCreateInfoNV, _2: *VkAllocationCallbacks, _3: *VkAccelerationStructureNV) VkResult;

PFN_vkDestroyAccelerationStructureNV :: *fn (_0: VkDevice, _1: VkAccelerationStructureNV, _2: *VkAllocationCallbacks) ;

PFN_vkGetAccelerationStructureMemoryRequirementsNV :: *fn (_0: VkDevice, _1: *VkAccelerationStructureMemoryRequirementsInfoNV, _2: *VkMemoryRequirements2KHR) ;

PFN_vkBindAccelerationStructureMemoryNV :: *fn (_0: VkDevice, _1: u32, _2: *VkBindAccelerationStructureMemoryInfoNV) VkResult;

PFN_vkCmdBuildAccelerationStructureNV :: *fn (_0: VkCommandBuffer, _1: *VkAccelerationStructureInfoNV, _2: VkBuffer, _3: VkDeviceSize, _4: VkBool32, _5: VkAccelerationStructureNV, _6: VkAccelerationStructureNV, _7: VkBuffer, _8: VkDeviceSize) ;

PFN_vkCmdCopyAccelerationStructureNV :: *fn (_0: VkCommandBuffer, _1: VkAccelerationStructureNV, _2: VkAccelerationStructureNV, _3: VkCopyAccelerationStructureModeNV) ;

PFN_vkCmdTraceRaysNV :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkBuffer, _4: VkDeviceSize, _5: VkDeviceSize, _6: VkBuffer, _7: VkDeviceSize, _8: VkDeviceSize, _9: VkBuffer, _10: VkDeviceSize, _11: VkDeviceSize, _12: u32, _13: u32, _14: u32) ;

PFN_vkCreateRayTracingPipelinesNV :: *fn (_0: VkDevice, _1: VkPipelineCache, _2: u32, _3: *VkRayTracingPipelineCreateInfoNV, _4: *VkAllocationCallbacks, _5: *VkPipeline) VkResult;

PFN_vkGetRayTracingShaderGroupHandlesNV :: *fn (_0: VkDevice, _1: VkPipeline, _2: u32, _3: u32, _4: usize, _5: *u8) VkResult;

PFN_vkGetAccelerationStructureHandleNV :: *fn (_0: VkDevice, _1: VkAccelerationStructureNV, _2: usize, _3: *u8) VkResult;

PFN_vkCmdWriteAccelerationStructuresPropertiesNV :: *fn (_0: VkCommandBuffer, _1: u32, _2: *VkAccelerationStructureNV, _3: VkQueryType, _4: VkQueryPool, _5: u32) ;

PFN_vkCompileDeferredNV :: *fn (_0: VkDevice, _1: VkPipeline, _2: u32) VkResult;

vkCreateAccelerationStructureNV :: fn (device: VkDevice, pCreateInfo: *VkAccelerationStructureCreateInfoNV, pAllocator: *VkAllocationCallbacks, pAccelerationStructure: *VkAccelerationStructureNV) VkResult #extern;
vkDestroyAccelerationStructureNV :: fn (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, pAllocator: *VkAllocationCallbacks)  #extern;
vkGetAccelerationStructureMemoryRequirementsNV :: fn (device: VkDevice, pInfo: *VkAccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *VkMemoryRequirements2KHR)  #extern;
vkBindAccelerationStructureMemoryNV :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindAccelerationStructureMemoryInfoNV) VkResult #extern;
vkCmdBuildAccelerationStructureNV :: fn (commandBuffer: VkCommandBuffer, pInfo: *VkAccelerationStructureInfoNV, instanceData: VkBuffer, instanceOffset: VkDeviceSize, update: VkBool32, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, scratch: VkBuffer, scratchOffset: VkDeviceSize)  #extern;
vkCmdCopyAccelerationStructureNV :: fn (commandBuffer: VkCommandBuffer, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, mode: VkCopyAccelerationStructureModeNV)  #extern;
vkCmdTraceRaysNV :: fn (commandBuffer: VkCommandBuffer, raygenShaderBindingTableBuffer: VkBuffer, raygenShaderBindingOffset: VkDeviceSize, missShaderBindingTableBuffer: VkBuffer, missShaderBindingOffset: VkDeviceSize, missShaderBindingStride: VkDeviceSize, hitShaderBindingTableBuffer: VkBuffer, hitShaderBindingOffset: VkDeviceSize, hitShaderBindingStride: VkDeviceSize, callableShaderBindingTableBuffer: VkBuffer, callableShaderBindingOffset: VkDeviceSize, callableShaderBindingStride: VkDeviceSize, width: u32, height: u32, depth: u32)  #extern;
vkCreateRayTracingPipelinesNV :: fn (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkRayTracingPipelineCreateInfoNV, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) VkResult #extern;
vkGetRayTracingShaderGroupHandlesNV :: fn (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *u8) VkResult #extern;
vkGetAccelerationStructureHandleNV :: fn (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, dataSize: usize, pData: *u8) VkResult #extern;
vkCmdWriteAccelerationStructuresPropertiesNV :: fn (commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureNV, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32)  #extern;
vkCompileDeferredNV :: fn (device: VkDevice, pipeline: VkPipeline, shader: u32) VkResult #extern;
VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    representativeFragmentTest: VkBool32,
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    representativeFragmentTestEnable: VkBool32,
};

VkPhysicalDeviceImageViewImageFormatInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    imageViewType: VkImageViewType,
};

VkFilterCubicImageViewImageFormatPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    filterCubic: VkBool32,
    filterCubicMinmax: VkBool32,
};

VkQueueGlobalPriorityEXT :: enum {
    LOW_EXT :: 128,
    MEDIUM_EXT :: 256,
    HIGH_EXT :: 512,
    REALTIME_EXT :: 1024,
    BEGIN_RANGE_EXT :: 128,
    END_RANGE_EXT :: 1024,
    RANGE_SIZE_EXT :: 897,
    MAX_ENUM_EXT :: 2147483647,
};

VkDeviceQueueGlobalPriorityCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    globalPriority: VkQueueGlobalPriorityEXT,
};

VkImportMemoryHostPointerInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    handleType: VkExternalMemoryHandleTypeFlagBits,
    pHostPointer: *u8,
};

VkMemoryHostPointerPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    memoryTypeBits: u32,
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    minImportedHostPointerAlignment: VkDeviceSize,
};

PFN_vkGetMemoryHostPointerPropertiesEXT :: *fn (_0: VkDevice, _1: VkExternalMemoryHandleTypeFlagBits, _2: *u8, _3: *VkMemoryHostPointerPropertiesEXT) VkResult;

vkGetMemoryHostPointerPropertiesEXT :: fn (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *u8, pMemoryHostPointerProperties: *VkMemoryHostPointerPropertiesEXT) VkResult #extern;
PFN_vkCmdWriteBufferMarkerAMD :: *fn (_0: VkCommandBuffer, _1: VkPipelineStageFlagBits, _2: VkBuffer, _3: VkDeviceSize, _4: u32) ;

vkCmdWriteBufferMarkerAMD :: fn (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32)  #extern;
VkTimeDomainEXT :: enum {
    DEVICE_EXT :: 0,
    CLOCK_MONOTONIC_EXT :: 1,
    CLOCK_MONOTONIC_RAW_EXT :: 2,
    QUERY_PERFORMANCE_COUNTER_EXT :: 3,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 3,
    RANGE_SIZE_EXT :: 4,
    MAX_ENUM_EXT :: 2147483647,
};

VkCalibratedTimestampInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    timeDomain: VkTimeDomainEXT,
};

PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkTimeDomainEXT) VkResult;

PFN_vkGetCalibratedTimestampsEXT :: *fn (_0: VkDevice, _1: u32, _2: *VkCalibratedTimestampInfoEXT, _3: *u64, _4: *u64) VkResult;

vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: fn (physicalDevice: VkPhysicalDevice, pTimeDomainCount: *u32, pTimeDomains: *VkTimeDomainEXT) VkResult #extern;
vkGetCalibratedTimestampsEXT :: fn (device: VkDevice, timestampCount: u32, pTimestampInfos: *VkCalibratedTimestampInfoEXT, pTimestamps: *u64, pMaxDeviation: *u64) VkResult #extern;
VkPhysicalDeviceShaderCorePropertiesAMD :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderEngineCount: u32,
    shaderArraysPerEngineCount: u32,
    computeUnitsPerShaderArray: u32,
    simdPerComputeUnit: u32,
    wavefrontsPerSimd: u32,
    wavefrontSize: u32,
    sgprsPerSimd: u32,
    minSgprAllocation: u32,
    maxSgprAllocation: u32,
    sgprAllocationGranularity: u32,
    vgprsPerSimd: u32,
    minVgprAllocation: u32,
    maxVgprAllocation: u32,
    vgprAllocationGranularity: u32,
};

VkMemoryOverallocationBehaviorAMD :: enum {
    DEFAULT_AMD :: 0,
    ALLOWED_AMD :: 1,
    DISALLOWED_AMD :: 2,
    BEGIN_RANGE_AMD :: 0,
    END_RANGE_AMD :: 2,
    RANGE_SIZE_AMD :: 3,
    MAX_ENUM_AMD :: 2147483647,
};

VkDeviceMemoryOverallocationCreateInfoAMD :: struct {
    sType: VkStructureType,
    pNext: *u8,
    overallocationBehavior: VkMemoryOverallocationBehaviorAMD,
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxVertexAttribDivisor: u32,
};

VkVertexInputBindingDivisorDescriptionEXT :: struct {
    binding: u32,
    divisor: u32,
};

VkPipelineVertexInputDivisorStateCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    vertexBindingDivisorCount: u32,
    pVertexBindingDivisors: *VkVertexInputBindingDivisorDescriptionEXT,
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    vertexAttributeInstanceRateDivisor: VkBool32,
    vertexAttributeInstanceRateZeroDivisor: VkBool32,
};

VkPipelineCreationFeedbackFlagBitsEXT :: enum {
    VALID_BIT_EXT :: 1,
    APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT :: 2,
    BASE_PIPELINE_ACCELERATION_BIT_EXT :: 4,
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647,
};

VkPipelineCreationFeedbackFlagsEXT :: VkFlags;

VkPipelineCreationFeedbackEXT :: struct {
    flags: VkPipelineCreationFeedbackFlagsEXT,
    duration: u64,
};

VkPipelineCreationFeedbackCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    pPipelineCreationFeedback: *VkPipelineCreationFeedbackEXT,
    pipelineStageCreationFeedbackCount: u32,
    pPipelineStageCreationFeedbacks: *VkPipelineCreationFeedbackEXT,
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    computeDerivativeGroupQuads: VkBool32,
    computeDerivativeGroupLinear: VkBool32,
};

VkPhysicalDeviceMeshShaderFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    taskShader: VkBool32,
    meshShader: VkBool32,
};

VkPhysicalDeviceMeshShaderPropertiesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    maxDrawMeshTasksCount: u32,
    maxTaskWorkGroupInvocations: u32,
    maxTaskWorkGroupSize: [3]u32,
    maxTaskTotalMemorySize: u32,
    maxTaskOutputCount: u32,
    maxMeshWorkGroupInvocations: u32,
    maxMeshWorkGroupSize: [3]u32,
    maxMeshTotalMemorySize: u32,
    maxMeshOutputVertices: u32,
    maxMeshOutputPrimitives: u32,
    maxMeshMultiviewViewCount: u32,
    meshOutputPerVertexGranularity: u32,
    meshOutputPerPrimitiveGranularity: u32,
};

VkDrawMeshTasksIndirectCommandNV :: struct {
    taskCount: u32,
    firstTask: u32,
};

PFN_vkCmdDrawMeshTasksNV :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32) ;

PFN_vkCmdDrawMeshTasksIndirectNV :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: u32, _4: u32) ;

PFN_vkCmdDrawMeshTasksIndirectCountNV :: *fn (_0: VkCommandBuffer, _1: VkBuffer, _2: VkDeviceSize, _3: VkBuffer, _4: VkDeviceSize, _5: u32, _6: u32) ;

vkCmdDrawMeshTasksNV :: fn (commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32)  #extern;
vkCmdDrawMeshTasksIndirectNV :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32)  #extern;
vkCmdDrawMeshTasksIndirectCountNV :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32)  #extern;
VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    fragmentShaderBarycentric: VkBool32,
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    imageFootprint: VkBool32,
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    exclusiveScissorCount: u32,
    pExclusiveScissors: *VkRect2D,
};

VkPhysicalDeviceExclusiveScissorFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    exclusiveScissor: VkBool32,
};

PFN_vkCmdSetExclusiveScissorNV :: *fn (_0: VkCommandBuffer, _1: u32, _2: u32, _3: *VkRect2D) ;

vkCmdSetExclusiveScissorNV :: fn (commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *VkRect2D)  #extern;
VkQueueFamilyCheckpointPropertiesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    checkpointExecutionStageMask: VkPipelineStageFlags,
};

VkCheckpointDataNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    stage: VkPipelineStageFlagBits,
    pCheckpointMarker: *u8,
};

PFN_vkCmdSetCheckpointNV :: *fn (_0: VkCommandBuffer, _1: *u8) ;

PFN_vkGetQueueCheckpointDataNV :: *fn (_0: VkQueue, _1: *u32, _2: *VkCheckpointDataNV) ;

vkCmdSetCheckpointNV :: fn (commandBuffer: VkCommandBuffer, pCheckpointMarker: *u8)  #extern;
vkGetQueueCheckpointDataNV :: fn (queue: VkQueue, pCheckpointDataCount: *u32, pCheckpointData: *VkCheckpointDataNV)  #extern;
VkPhysicalDeviceShaderIntegerFunctions2INTEL :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderIntegerFunctions2: VkBool32,
};

VkPerformanceConfigurationTypeINTEL :: enum {
    COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL :: 0,
    BEGIN_RANGE_INTEL :: 0,
    END_RANGE_INTEL :: 0,
    RANGE_SIZE_INTEL :: 1,
    MAX_ENUM_INTEL :: 2147483647,
};

VkQueryPoolSamplingModeINTEL :: enum {
    MANUAL_INTEL :: 0,
    BEGIN_RANGE_INTEL :: 0,
    END_RANGE_INTEL :: 0,
    RANGE_SIZE_INTEL :: 1,
    MAX_ENUM_INTEL :: 2147483647,
};

VkPerformanceOverrideTypeINTEL :: enum {
    NULL_HARDWARE_INTEL :: 0,
    FLUSH_GPU_CACHES_INTEL :: 1,
    BEGIN_RANGE_INTEL :: 0,
    END_RANGE_INTEL :: 1,
    RANGE_SIZE_INTEL :: 2,
    MAX_ENUM_INTEL :: 2147483647,
};

VkPerformanceParameterTypeINTEL :: enum {
    HW_COUNTERS_SUPPORTED_INTEL :: 0,
    STREAM_MARKER_VALID_BITS_INTEL :: 1,
    BEGIN_RANGE_INTEL :: 0,
    END_RANGE_INTEL :: 1,
    RANGE_SIZE_INTEL :: 2,
    MAX_ENUM_INTEL :: 2147483647,
};

VkPerformanceValueTypeINTEL :: enum {
    UINT32_INTEL :: 0,
    UINT64_INTEL :: 1,
    FLOAT_INTEL :: 2,
    BOOL_INTEL :: 3,
    STRING_INTEL :: 4,
    BEGIN_RANGE_INTEL :: 0,
    END_RANGE_INTEL :: 4,
    RANGE_SIZE_INTEL :: 5,
    MAX_ENUM_INTEL :: 2147483647,
};

VkPerformanceValueDataINTEL :: u64;

VkPerformanceValueINTEL :: struct {
    type: VkPerformanceValueTypeINTEL,
    data: VkPerformanceValueDataINTEL,
};

VkInitializePerformanceApiInfoINTEL :: struct {
    sType: VkStructureType,
    pNext: *u8,
    pUserData: *u8,
};

VkQueryPoolCreateInfoINTEL :: struct {
    sType: VkStructureType,
    pNext: *u8,
    performanceCountersSampling: VkQueryPoolSamplingModeINTEL,
};

VkPerformanceMarkerInfoINTEL :: struct {
    sType: VkStructureType,
    pNext: *u8,
    marker: u64,
};

VkPerformanceStreamMarkerInfoINTEL :: struct {
    sType: VkStructureType,
    pNext: *u8,
    marker: u32,
};

VkPerformanceOverrideInfoINTEL :: struct {
    sType: VkStructureType,
    pNext: *u8,
    type: VkPerformanceOverrideTypeINTEL,
    enable: VkBool32,
    parameter: u64,
};

VkPerformanceConfigurationAcquireInfoINTEL :: struct {
    sType: VkStructureType,
    pNext: *u8,
    type: VkPerformanceConfigurationTypeINTEL,
};

PFN_vkInitializePerformanceApiINTEL :: *fn (_0: VkDevice, _1: *VkInitializePerformanceApiInfoINTEL) VkResult;

PFN_vkUninitializePerformanceApiINTEL :: *fn (_0: VkDevice) ;

PFN_vkCmdSetPerformanceMarkerINTEL :: *fn (_0: VkCommandBuffer, _1: *VkPerformanceMarkerInfoINTEL) VkResult;

PFN_vkCmdSetPerformanceStreamMarkerINTEL :: *fn (_0: VkCommandBuffer, _1: *VkPerformanceStreamMarkerInfoINTEL) VkResult;

PFN_vkCmdSetPerformanceOverrideINTEL :: *fn (_0: VkCommandBuffer, _1: *VkPerformanceOverrideInfoINTEL) VkResult;

PFN_vkAcquirePerformanceConfigurationINTEL :: *fn (_0: VkDevice, _1: *VkPerformanceConfigurationAcquireInfoINTEL, _2: *VkPerformanceConfigurationINTEL) VkResult;

PFN_vkReleasePerformanceConfigurationINTEL :: *fn (_0: VkDevice, _1: VkPerformanceConfigurationINTEL) VkResult;

PFN_vkQueueSetPerformanceConfigurationINTEL :: *fn (_0: VkQueue, _1: VkPerformanceConfigurationINTEL) VkResult;

PFN_vkGetPerformanceParameterINTEL :: *fn (_0: VkDevice, _1: VkPerformanceParameterTypeINTEL, _2: *VkPerformanceValueINTEL) VkResult;

vkInitializePerformanceApiINTEL :: fn (device: VkDevice, pInitializeInfo: *VkInitializePerformanceApiInfoINTEL) VkResult #extern;
vkUninitializePerformanceApiINTEL :: fn (device: VkDevice)  #extern;
vkCmdSetPerformanceMarkerINTEL :: fn (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkPerformanceMarkerInfoINTEL) VkResult #extern;
vkCmdSetPerformanceStreamMarkerINTEL :: fn (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkPerformanceStreamMarkerInfoINTEL) VkResult #extern;
vkCmdSetPerformanceOverrideINTEL :: fn (commandBuffer: VkCommandBuffer, pOverrideInfo: *VkPerformanceOverrideInfoINTEL) VkResult #extern;
vkAcquirePerformanceConfigurationINTEL :: fn (device: VkDevice, pAcquireInfo: *VkPerformanceConfigurationAcquireInfoINTEL, pConfiguration: *VkPerformanceConfigurationINTEL) VkResult #extern;
vkReleasePerformanceConfigurationINTEL :: fn (device: VkDevice, configuration: VkPerformanceConfigurationINTEL) VkResult #extern;
vkQueueSetPerformanceConfigurationINTEL :: fn (queue: VkQueue, configuration: VkPerformanceConfigurationINTEL) VkResult #extern;
vkGetPerformanceParameterINTEL :: fn (device: VkDevice, parameter: VkPerformanceParameterTypeINTEL, pValue: *VkPerformanceValueINTEL) VkResult #extern;
VkPhysicalDevicePCIBusInfoPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    pciDomain: u32,
    pciBus: u32,
    pciDevice: u32,
    pciFunction: u32,
};

VkDisplayNativeHdrSurfaceCapabilitiesAMD :: struct {
    sType: VkStructureType,
    pNext: *u8,
    localDimmingSupport: VkBool32,
};

VkSwapchainDisplayNativeHdrCreateInfoAMD :: struct {
    sType: VkStructureType,
    pNext: *u8,
    localDimmingEnable: VkBool32,
};

PFN_vkSetLocalDimmingAMD :: *fn (_0: VkDevice, _1: VkSwapchainKHR, _2: VkBool32) ;

vkSetLocalDimmingAMD :: fn (device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32)  #extern;
VkPhysicalDeviceFragmentDensityMapFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    fragmentDensityMap: VkBool32,
    fragmentDensityMapDynamic: VkBool32,
    fragmentDensityMapNonSubsampledImages: VkBool32,
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    minFragmentDensityTexelSize: VkExtent2D,
    maxFragmentDensityTexelSize: VkExtent2D,
    fragmentDensityInvocations: VkBool32,
};

VkRenderPassFragmentDensityMapCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    fragmentDensityMapAttachment: VkAttachmentReference,
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    scalarBlockLayout: VkBool32,
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    heapBudget: [16]VkDeviceSize,
    heapUsage: [16]VkDeviceSize,
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    memoryPriority: VkBool32,
};

VkMemoryPriorityAllocateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    priority: f32,
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    dedicatedAllocationImageAliasing: VkBool32,
};

VkDeviceAddress :: u64;

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    bufferDeviceAddress: VkBool32,
    bufferDeviceAddressCaptureReplay: VkBool32,
    bufferDeviceAddressMultiDevice: VkBool32,
};

VkPhysicalDeviceBufferAddressFeaturesEXT :: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

VkBufferDeviceAddressInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    buffer: VkBuffer,
};

VkBufferDeviceAddressCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    deviceAddress: VkDeviceAddress,
};

PFN_vkGetBufferDeviceAddressEXT :: *fn (_0: VkDevice, _1: *VkBufferDeviceAddressInfoEXT) VkDeviceAddress;

vkGetBufferDeviceAddressEXT :: fn (device: VkDevice, pInfo: *VkBufferDeviceAddressInfoEXT) VkDeviceAddress #extern;
VkImageStencilUsageCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    stencilUsage: VkImageUsageFlags,
};

VkValidationFeatureEnableEXT :: enum {
    GPU_ASSISTED_EXT :: 0,
    GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT :: 1,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 1,
    RANGE_SIZE_EXT :: 2,
    MAX_ENUM_EXT :: 2147483647,
};

VkValidationFeatureDisableEXT :: enum {
    ALL_EXT :: 0,
    SHADERS_EXT :: 1,
    THREAD_SAFETY_EXT :: 2,
    API_PARAMETERS_EXT :: 3,
    OBJECT_LIFETIMES_EXT :: 4,
    CORE_CHECKS_EXT :: 5,
    UNIQUE_HANDLES_EXT :: 6,
    BEGIN_RANGE_EXT :: 0,
    END_RANGE_EXT :: 6,
    RANGE_SIZE_EXT :: 7,
    MAX_ENUM_EXT :: 2147483647,
};

VkValidationFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    enabledValidationFeatureCount: u32,
    pEnabledValidationFeatures: *VkValidationFeatureEnableEXT,
    disabledValidationFeatureCount: u32,
    pDisabledValidationFeatures: *VkValidationFeatureDisableEXT,
};

VkComponentTypeNV :: enum {
    FLOAT16_NV :: 0,
    FLOAT32_NV :: 1,
    FLOAT64_NV :: 2,
    SINT8_NV :: 3,
    SINT16_NV :: 4,
    SINT32_NV :: 5,
    SINT64_NV :: 6,
    UINT8_NV :: 7,
    UINT16_NV :: 8,
    UINT32_NV :: 9,
    UINT64_NV :: 10,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 10,
    RANGE_SIZE_NV :: 11,
    MAX_ENUM_NV :: 2147483647,
};

VkScopeNV :: enum {
    DEVICE_NV :: 1,
    WORKGROUP_NV :: 2,
    SUBGROUP_NV :: 3,
    QUEUE_FAMILY_NV :: 5,
    BEGIN_RANGE_NV :: 1,
    END_RANGE_NV :: 5,
    RANGE_SIZE_NV :: 5,
    MAX_ENUM_NV :: 2147483647,
};

VkCooperativeMatrixPropertiesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    MSize: u32,
    NSize: u32,
    KSize: u32,
    AType: VkComponentTypeNV,
    BType: VkComponentTypeNV,
    CType: VkComponentTypeNV,
    DType: VkComponentTypeNV,
    scope: VkScopeNV,
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    cooperativeMatrix: VkBool32,
    cooperativeMatrixRobustBufferAccess: VkBool32,
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    cooperativeMatrixSupportedStages: VkShaderStageFlags,
};

PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkCooperativeMatrixPropertiesNV) VkResult;

vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkCooperativeMatrixPropertiesNV) VkResult #extern;
VkCoverageReductionModeNV :: enum {
    MERGE_NV :: 0,
    TRUNCATE_NV :: 1,
    BEGIN_RANGE_NV :: 0,
    END_RANGE_NV :: 1,
    RANGE_SIZE_NV :: 2,
    MAX_ENUM_NV :: 2147483647,
};

VkPipelineCoverageReductionStateCreateFlagsNV :: VkFlags;

VkPhysicalDeviceCoverageReductionModeFeaturesNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    coverageReductionMode: VkBool32,
};

VkPipelineCoverageReductionStateCreateInfoNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkPipelineCoverageReductionStateCreateFlagsNV,
    coverageReductionMode: VkCoverageReductionModeNV,
};

VkFramebufferMixedSamplesCombinationNV :: struct {
    sType: VkStructureType,
    pNext: *u8,
    coverageReductionMode: VkCoverageReductionModeNV,
    rasterizationSamples: VkSampleCountFlagBits,
    depthStencilSamples: VkSampleCountFlags,
    colorSamples: VkSampleCountFlags,
};

PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: *fn (_0: VkPhysicalDevice, _1: *u32, _2: *VkFramebufferMixedSamplesCombinationNV) VkResult;

vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: fn (physicalDevice: VkPhysicalDevice, pCombinationCount: *u32, pCombinations: *VkFramebufferMixedSamplesCombinationNV) VkResult #extern;
VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    fragmentShaderSampleInterlock: VkBool32,
    fragmentShaderPixelInterlock: VkBool32,
    fragmentShaderShadingRateInterlock: VkBool32,
};

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    ycbcrImageArrays: VkBool32,
};

VkHeadlessSurfaceCreateFlagsEXT :: VkFlags;

VkHeadlessSurfaceCreateInfoEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    flags: VkHeadlessSurfaceCreateFlagsEXT,
};

PFN_vkCreateHeadlessSurfaceEXT :: *fn (_0: VkInstance, _1: *VkHeadlessSurfaceCreateInfoEXT, _2: *VkAllocationCallbacks, _3: *VkSurfaceKHR) VkResult;

vkCreateHeadlessSurfaceEXT :: fn (instance: VkInstance, pCreateInfo: *VkHeadlessSurfaceCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) VkResult #extern;
VkPhysicalDeviceHostQueryResetFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    hostQueryReset: VkBool32,
};

PFN_vkResetQueryPoolEXT :: *fn (_0: VkDevice, _1: VkQueryPool, _2: u32, _3: u32) ;

vkResetQueryPoolEXT :: fn (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32)  #extern;
VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    shaderDemoteToHelperInvocation: VkBool32,
};

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    texelBufferAlignment: VkBool32,
};

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT :: struct {
    sType: VkStructureType,
    pNext: *u8,
    storageTexelBufferOffsetAlignmentBytes: VkDeviceSize,
    storageTexelBufferOffsetSingleTexelAlignment: VkBool32,
    uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize,
    uniformTexelBufferOffsetSingleTexelAlignment: VkBool32,
};

VK_MAKE_VERSION :: fn (major: u32, minor: u32, patch: u32) u32 #inline {
    return ((major) << 22) | ((minor) << 12) | (patch);
};
