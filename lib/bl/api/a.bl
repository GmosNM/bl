//************************************************************************************************
// bl
//
// File:   _builtin.bl
// Author: Martin Dorazil
// Date:   2/11/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "std/memory.bl"
#load "std/debug.bl"
#load "std/utils.bl"

/*!
OSKind
======

Declaration
-----------
.. code-block:: c

    OSKind :: enum {
        Windows;
        Linux;
        MacOS;
    }

Description
-----------
Describe supported platforms.
*/
OSKind :: enum {
    Windows;
    Linux;
    MacOS;
}

/*!
TypeKind
========

Declaration
-----------
.. code-block:: c

    TypeKind :: enum #compiler {
        Type   :: 1;
        Void   :: 2;
        Int    :: 3;
        Real   :: 4;
        Fn     :: 5;
        Ptr    :: 6;
        Bool   :: 7;
        Array  :: 8;
        Struct :: 9;
        Enum   :: 10;
        Null   :: 11;
        String :: 12;
        FnGroup :: 16;
    }

Description
-----------
TypeKind describes kind of BL type returned in TypeInfo structure. This value can be used for 
safe casting.

Variants
--------
* `Type` Base type of all types in type system.
* `Void` Void type. (Implicitly used for functions without return value)
* `Int` Any integer type: `s8`, `s16`, `s32`, `s64`, `u8`, `u16`, `u32`, `u64`, `usize`.
* `Real` Any real type: `f32`, `f64`.
* `Fn` Function type. 
* `Ptr` Pointer type. 
* `Bool` Boolean type. 
* `Array` Array type. 
* `Struct` Structure type. 
* `Enum` Enumerator type. 
* `Null` Null-value type. 
* `String` String type. 
* `FnGroup` Function group type. 
*/
TypeKind :: enum #compiler {
    Type    :: 1;
    Void    :: 2;
    Int     :: 3;
    Real    :: 4;
    Fn      :: 5;
    Ptr     :: 6;
    Bool    :: 7;
    Array   :: 8;
    Struct  :: 9;
    Enum    :: 10;
    Null    :: 11;
    String  :: 12;
    FnGroup :: 16;
};

/*!
TypeInfo
========

Declaration
-----------
.. code-block:: c

    TypeInfo :: struct #compiler {
        kind: TypeKind;
        size_bytes: usize
    }

Description
-----------
Base `TypeInfo` structure returned by `typeinfo` operator. This structure pointer can be casted to 
child type to get more descriptive information about the type.

Members
-------
* `kind` Type info kind.
* `size_bytes` Size of type in bytes.
*/
TypeInfo :: struct #compiler {
    kind: TypeKind;
    size_bytes: usize
};

/*!
TypeInfoInt
===========

Declaration
-----------
.. code-block:: c

    TypeInfoInt :: struct #base TypeInfo #compiler {
        bit_count: s32;
        is_signed: bool;
    }

Description
-----------
Detailed information about integer types: `s8`, `s16`, `s32`, `s64`, `u8`, `u16`, `u32`, `u64`, `usize`.

Members
-------
* `bit_count` Size of type in bits.
* `is_signed` True when type is signed integer type.
*/
TypeInfoInt :: struct #base TypeInfo #compiler {
    bit_count: s32; 
    is_signed: bool;
};

/*!
TypeInfoReal
============

Declaration
-----------
.. code-block:: c

    TypeInfoReal :: struct #base TypeInfo  #compiler {
        bit_count: s32
    }

Description
-----------
Detailed information about real types: `f32`, `f64`.

Members
-------
* `bit_count` Size of type in bits.
*/
TypeInfoReal :: struct #base TypeInfo  #compiler {
    bit_count: s32 
};

/*!
TypeInfoFn
==========

Declaration
-----------
.. code-block:: c

    TypeInfoFn :: struct #base TypeInfo #compiler {
        args: []TypeInfoFnArg; 
        ret_type: *TypeInfo;
        is_vargs: bool;
    }

Description
-----------
Detailed information about function types.

Members
-------
* `args` Slice of argument type infos.
* `ret_type` Return type info.
* `is_vargs` True when function has variable argument list.
*/
TypeInfoFn :: struct #base TypeInfo #compiler {
    args: []TypeInfoFnArg; 
    ret_type: *TypeInfo;
    is_vargs: bool; 
};


/*!
TypeInfoFnGroup
===============

Declaration
-----------
.. code-block:: c

    TypeInfoFnGroup :: struct #base TypeInfo #compiler {
        variants: []*TypeInfoFn; 
    }

Description
-----------
Detailed information about function group and contained possible overloads.

Members
-------
* `variants` Group content. 
*/
TypeInfoFnGroup :: struct #base TypeInfo #compiler {
    variants: []*TypeInfoFn; 
}

/*!
TypeInfoPtr
===========

Declaration
-----------
.. code-block:: c

    TypeInfoPtr :: struct #base TypeInfo #compiler {
        pointee_type: *TypeInfo 
    }

Description
-----------
Detailed information about pointer types.

Members
-------
* `pointee_type` Underlaying pointed type info.
*/
TypeInfoPtr :: struct #base TypeInfo #compiler {
    pointee_type: *TypeInfo
};

/*!
TypeInfoArray
=============

Declaration
-----------
.. code-block:: c

    TypeInfoArray :: struct #base TypeInfo #compiler {
        name: string;
        elem_type: *TypeInfo; 
        len: s64 
    }

Description
-----------
Detailed information about array types.

Members
-------
* `name` Array name.
* `elem_type` Array element type info.
* `len` Array element count.
*/
TypeInfoArray :: struct #base TypeInfo #compiler {
    name: string;
    elem_type: *TypeInfo; 
    len: s64 
};

/*!
TypeInfoStruct
==============

Declaration
-----------
.. code-block:: c

    TypeInfoStruct :: struct #base TypeInfo #compiler {
        name: string;
        members: []TypeInfoStructMember; 
        is_slice: bool
        is_union: bool;
        is_dynamic_array: bool;
    }

Description
-----------
Detailed information about structure types.

Members
-------
* `name` Structure type name.
* `members` Slice of structure member infos.
* `is_slice` True when structure is slice.
* `is_union` True when structure is union.
* `is_dynamic_array` True when structure is dynamic array.
*/
TypeInfoStruct :: struct #base TypeInfo #compiler {
    name: string; 
    members: []TypeInfoStructMember; 
    is_slice: bool;
    is_union: bool;
    is_dynamic_array: bool;

    // @CLEANUP: slice cannot be union, better way will be create separate type
    // kind for struct, slice and union, dynamic array could act like regular
    // array in type info.
};

/*!
TypeInfoEnum
============

Declaration
-----------
.. code-block:: c

    TypeInfoEnum :: struct #base TypeInfo #compiler {
        name: string;
        base_type: *TypeInfo; 
        variants: []TypeInfoEnumVariant
    }

Description
-----------
Detailed information about enumerator types.

Members
-------
* `name` Enumerator type name.
* `base_type` Base type info.
* `variants` Slice of all enumerator variants.
*/
TypeInfoEnum :: struct #base TypeInfo #compiler {
    name: string;
    base_type: *TypeInfo; 
    variants: []TypeInfoEnumVariant
};

/*!
TypeInfoVoid
============

Declaration
-----------
.. code-block:: c

    TypeInfoVoid :: struct #base TypeInfo #compiler {
    }

Description
-----------
Placeholer for information about `void` type.
*/
TypeInfoVoid :: struct #base TypeInfo #compiler {
};

/*!
TypeInfoNull
============

Declaration
-----------
.. code-block:: c

    TypeInfoNull :: struct #base TypeInfo #compiler {
    }

Description
-----------
Placeholer for information about `null` type.
*/
TypeInfoNull :: struct #base TypeInfo #compiler {
};

/*!
TypeInfoString
==============

Declaration
-----------
.. code-block:: c

    TypeInfoString :: struct #base TypeInfo #compiler {
    }

Description
-----------
Placeholer for information about `string` type.
*/
TypeInfoString :: struct #base TypeInfo #compiler {
};

/*!
TypeInfoType
============

Declaration
-----------
.. code-block:: c

    TypeInfoType :: struct #base TypeInfo #compiler {
    }

Description
-----------
Placeholer for information about `type` type.
*/
TypeInfoType :: struct #base TypeInfo  #compiler {
};

/*!
TypeInfoBool
============

Declaration
-----------
.. code-block:: c

    TypeInfoBool :: struct #base TypeInfo #compiler {
    }

Description
-----------
Placeholer for information about `bool` type.
*/
TypeInfoBool :: struct #base TypeInfo #compiler {
};

/*!
TypeInfoStructMember
====================

Declaration
-----------
.. code-block:: c

    TypeInfoStructMember :: struct #compiler {
        name: string;
        base_type: *TypeInfo;
        offset_bytes: s32;
        index: s32;
        tags: s32;
        is_base: bool;
    }

Description
-----------
Detailed information about structure member.

Members
-------
* `name` Member type name.
* `base_type` Member type info.
* `offset_bytes` Byte-offset of member inside structure ABI.
* `index` Order in structure.
* `tags` User tags contains merge of all tag values assigned to member in structure declaration.
  Basically tags behave like a flags value, merge is done by binary `or` of all defined tag values.
  User tags can be defined by `#tags` hash directive written after member type in following way:

  .. code-block:: c

      Foo :: struct {
          i: s32 #tags TAG1;
          j: s32 #tags TAG1, TAG2;
      };

  Where tags must be `compile-time` constant of `s32` type.

  .. code-block:: text

        TAG1 :: 0x1;
        TAG2 :: 0x2;

* `is_base` True when member is inherrited base of the parent structure type.
*/
TypeInfoStructMember :: struct #compiler {
    name: string;
    base_type: *TypeInfo;
    offset_bytes: s32;
    index: s32;
    tags: s32;
    is_base: bool;
};

/*!
TypeInfoEnumVariant
===================

Declaration
-----------
.. code-block:: c

    TypeInfoEnumVariant :: struct #compiler {
        name: string;
        value: s64
    }

Description
-----------
Detailed information about enumerator variant.

Members
-------
* `name` Member type name.
* `value` Variant value.
*/
TypeInfoEnumVariant :: struct #compiler {
    name: string;
    value: s64
};

/*!
TypeInfoFnArg
=============

Declaration
-----------
.. code-block:: c

    TypeInfoFnArg :: struct #compiler {
        name: string;
        base_type: *TypeInfo
    }

Description
-----------
Detailed information about function's argument.

Members
-------
* `name` Member type name.
* `base_type` Argument type info.
*/
TypeInfoFnArg :: struct #compiler {
    name: string;
    base_type: *TypeInfo
};

/*!
Any
===

Declaration
-----------
.. code-block:: c

    Any :: struct #compiler {
        type_info: *TypeInfo;
        data: *u8
    }

Description
-----------
Any type is special builtin type used for passing value of "any" type as function argument. 

Members
-------
* `type_info` Type info associated to data type.
* `value` Data pointer. (not owner!)
*/
Any :: struct #compiler {
    type_info: *TypeInfo;
    data: *u8
};

/*!
TestCase
========

Declaration
-----------
.. code-block:: c

    TestCase :: struct #compiler {
        func: *fn();
        name: string;
    }

Description
-----------
Type of test case record found during compilation.

Members
-------
* `func` Pointer to test case function.
* `name` Name of the test case. 
*/
TestCase :: struct #compiler {
    func: *fn();
    name: string;
}

/*!
CodeLocation
============

Declaration
-----------
.. code-block:: c

    CodeLocation :: struct #compiler {
        file: string;
        line: s32;
    }

Description
-----------
Type of source code location used by `#call_location` directive.

Members
-------
* `file` Name of the source file.
* `line` Line in source file. 

Example
-------
.. code-block:: c 

    foo :: fn (loc: *CodeLocation = #call_location) {
        print("%\n", ^loc);
    }

    main :: fn () s32 {
        foo();
        return 0;
    }

*/
CodeLocation :: struct #compiler {
    file: string;
    line: s32;
}

/*!
PrintLogFn
===========

Declaration
-----------
::

    PrintLogFn :: * fn (kind: PrintLogKind, format: string, args: []Any, file: string, line: s32)

Description
-----------
Type of print log function.

Arguments
---------
* `kind` Kind of report message. 
* `format` Format string. 
* `args` Additional arguments. 
* `file` Call side filename. 
* `line` Call side line in source file. 
*/
PrintLogFn :: * fn (kind: PrintLogKind, file: string, line: s32, format: string, args: ...);

AbortFn :: * fn ();

/*!
Context
=======

Declaration
-----------
.. code-block:: c

    Context :: struct {
        alloc_fn: AllocFn;
        print_log_fn: PrintLogFn;
        abort_fn: AbortFn;
    }

Description
-----------
Default implicit context type. Implicit context is compiler internal global variable 
containing basic context for whole assembly. This variable is mutable and can 
be modified by user code. 

Members
-------
* `alloc_fn` Pointer to memory allocator function. 
* `print_log_fn` Pointer to log print function. 
* `abort_fn` Pointer to abort handler function. 
*/
Context :: struct {
    alloc_fn: AllocFn;
    print_log_fn: PrintLogFn;
    abort_fn: AbortFn;
};

/*!
_context
========

Declaration
-----------
.. code-block:: c

    _context := {:Context: 
                    &_default_allocator, 
                    &_print_log_default, 
                    &_os_abort_default,
                };

Description
-----------
Default implicit context. Implicit context is compiler internal global variable 
containing basic context for whole assembly. This variable is mutable and can 
be modified by user code. For example we can replace default memory allocator
with custom one, this will affect all allocations made later.
*/
_context := {:Context: 
                &_default_allocator, 
                &_print_log_default, 
                &_os_abort_default,
            };

/*!
command_line_arguments
======================

Declaration
-----------
::

    command_line_arguments: []string;

Description
-----------
Contains all arguments passed from command line. First argument is executable name.

*/
command_line_arguments: []string;





