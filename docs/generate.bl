#!/usr/local/bin/blc --silent -run
#import "std/fs"
#import "std/arg_parser"

Args :: struct #base ArgParser.Ctx {
    out_dir: string;
}

args: Args;

SRC_API_DIR :: "../lib/bl/api";

IGNORE :: {:[3]string:
           "sdl2",
           "glfw3",
           "gl",
          };

parse_args :: fn () bool {
    parser :: ArgParser.new();
    defer ArgParser.delete(parser);

    ArgParser.add(
        parser,
        "-o",
        "--output-dir",
        "<PATH> Specify the output directory.",
        &fn (_: ArgParser.Parser, a: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            if a.len == 1 { return 0, error("Expected output directory path!"); }
            args.out_dir = a[1];
            return 2, ok();
        });

    state :: ArgParser.run(parser, command_line_arguments, &args, 1);   
    if !is_ok(state) {
        print_err("%", state);
        ArgParser.print_help(parser);
        return false;
    }
    if args.positional.len > 0 { 
        print_err("Unexpected argument: '%'.", args.positional[0]); 
        return false;
    }
    if args.help { return false; }
    return true;
}

cmd :: fn (fmt: string, args: ...) Error {
    buf: [2048]u8;
    len :: bprint(buf, fmt, args);
    tmp :: {:string: len, buf.ptr};
    state :: os_execute(tmp);
    if state != 0 {
        return error(state, "Executed shell command failed '%'!", tmp);
    }
    return ok();
}

cleanup :: fn (out_dir: string) Error {
    print("Cleanup\n");
    if Fs.exist(out_dir) {
        err :: Fs.dir_remove_all(out_dir);
        if !is_ok(err) { return err; }
    }
    err :: Fs.dir_create_all(out_dir);
    if !is_ok(err) { return err; }
    return ok();
}

docs_dir :: fn (dest_path: string, src_path: string) Error {
    list, err :: Fs.dir_scan(src_path, &fn (info: *Fs.Info) bool {
        if String.is_empty(info.name)        { return false; }
        if String.compare(info.name, ".")    { return false; }
        if String.compare(info.name, "..")   { return false; }
        if String.compare(info.name, "_", 1) { return false; }
        loop i := 0; i < IGNORE.len; i += 1 {
            if String.compare(info.name, IGNORE[i]) { return false; }
        }
        if info.kind == Fs.InfoKind.File {
            ext :: Fs.get_extension(info.name);
            if !String.compare(ext, "bl") { return false; }
        }
        return true;
    });
    defer Fs.info_list_delete(list);
    if !is_ok(err) { return err; }

    file_list :: String.new(128);
    file_count: s32;
    defer String.delete(file_list);
    loop i := 0; i < list.len; i += 1 {
        info :: &list[i];
        switch info.kind {
            Fs.InfoKind.File {
                String.append(&file_list, src_path);
                String.append(&file_list, "/");
                String.append(&file_list, info.name);
                String.append(&file_list, " ");
                file_count += 1;
            }
            Fs.InfoKind.Directory {
                new_dest_path :: sprint("%/%", dest_path, info.name);
                new_src_path :: sprint("%/%", src_path, info.name);
                defer String.delete(new_dest_path);
                defer String.delete(new_src_path);
                
                err :: docs_dir(new_dest_path, new_src_path);
                if !is_ok(err) { return err; }
            }
        }
    }
    
    print("Process '%'\n", src_path);
    if String.is_empty(file_list) { return ok(); }
    if file_count == 1 {
        err_cmd :: cmd("blc -doc --doc-out-dir=\"%/..\" %", dest_path, file_list);
        if !is_ok(err_cmd) { return err_cmd; }
    } else {
        if !Fs.exist(dest_path) {
            err :: Fs.dir_create_all(dest_path);
            if !is_ok(err) { return err; }
        }
        err_cmd :: cmd("blc -doc --doc-out-dir=\"%\" %", dest_path, file_list);
        if !is_ok(err_cmd) { return err_cmd; }
    }
    return ok();
}

main :: fn () s32 {
    defer ArgParser.ctx_terminate(&args);
    if !parse_args() { return 1; }
    print("Generate BL documentation...\n");
    err1 :: cleanup(args.out_dir);
    if !is_ok(err1) { print_err("%", err1); return err1.code; }
    err2 :: docs_dir(args.out_dir, SRC_API_DIR);
    if !is_ok(err2) { print_err("%", err2); return err2.code; }
    print("Output written in '%' folder.\n", args.out_dir);
    return 0;
}
