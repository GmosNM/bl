<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Biscuit Language (1.0.0)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../static/styles.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="icon" href="../static/favicon.png">
  <style>
  body {
    margin-left: 410px;
    margin-top: 50px;
  }
  </style>
</head>
<body>
<ul id="MENU">
  <li><a href="../index.html">Home</a></li>
  <li><a href="index.html">Installation</a></li>
  <li><a href="compiler.html">Compiler Usage</a></li>
  <li><a href="language.html">API Manual</a></li>
</ul>
<header id="title-block-header">
<h1 class="title">Biscuit Language (1.0.0)</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#builtin">Builtin</a>
<ul>
<li><a href="#current-running-platform">Current running platform</a></li>
<li><a href="#current-running-architecture">Current running architecture</a></li>
<li><a href="#current-running-environment">Current running environment</a></li>
<li><a href="#typekind">TypeKind</a></li>
<li><a href="#typeinfo">TypeInfo</a></li>
<li><a href="#typeinfoint">TypeInfoInt</a></li>
<li><a href="#typeinforeal">TypeInfoReal</a></li>
<li><a href="#typeinfofn">TypeInfoFn</a></li>
<li><a href="#typeinfofngroup">TypeInfoFnGroup</a></li>
<li><a href="#typeinfoptr">TypeInfoPtr</a></li>
<li><a href="#typeinfoarray">TypeInfoArray</a></li>
<li><a href="#typeinfostruct">TypeInfoStruct</a></li>
<li><a href="#typeinfoenum">TypeInfoEnum</a></li>
<li><a href="#typeinfovoid">TypeInfoVoid</a></li>
<li><a href="#typeinfonull">TypeInfoNull</a></li>
<li><a href="#typeinfostring">TypeInfoString</a></li>
<li><a href="#typeinfotype">TypeInfoType</a></li>
<li><a href="#typeinfobool">TypeInfoBool</a></li>
<li><a href="#typeinfostructmember">TypeInfoStructMember</a></li>
<li><a href="#typeinfoenumvariant">TypeInfoEnumVariant</a></li>
<li><a href="#typeinfofnarg">TypeInfoFnArg</a></li>
<li><a href="#any">Any</a></li>
<li><a href="#testcase">TestCase</a></li>
<li><a href="#codelocation">CodeLocation</a></li>
<li><a href="#printlogfn">PrintLogFn</a></li>
<li><a href="#abortfn">AbortFn</a></li>
<li><a href="#context">Context</a></li>
<li><a href="#context-1">_context</a></li>
<li><a href="#command_line_arguments">command_line_arguments</a></li>
</ul></li>
<li><a href="#build-system">Build system</a>
<ul>
<li><a href="#basics">Basics</a></li>
<li><a href="#targetkind">TargetKind</a></li>
<li><a href="#buildmode">BuildMode</a></li>
<li><a href="#debuginfo">DebugInfo</a></li>
<li><a href="#assertmode">AssertMode</a></li>
<li><a href="#add_executable">add_executable</a></li>
<li><a href="#add_library">add_library</a></li>
<li><a href="#add_unit">add_unit</a></li>
<li><a href="#compile">compile</a></li>
<li><a href="#compile_all">compile_all</a></li>
<li><a href="#add_lib_path">add_lib_path</a></li>
<li><a href="#link_library">link_library</a></li>
<li><a href="#append_linker_options">append_linker_options</a></li>
<li><a href="#set_output_dir">set_output_dir</a></li>
<li><a href="#get_output_dir">get_output_dir</a></li>
<li><a href="#moduleimportpolicy">ModuleImportPolicy</a></li>
<li><a href="#set_module_dir">set_module_dir</a></li>
<li><a href="#get_module_dir">get_module_dir</a></li>
<li><a href="#get_module_import_policy">get_module_import_policy</a></li>
</ul></li>
<li><a href="#dirent.bl">dirent.bl</a>
<ul>
<li><a href="#dir">_DIR</a></li>
<li><a href="#dirent_t">_dirent_t</a></li>
<li><a href="#dt_unknown">_DT_UNKNOWN</a></li>
<li><a href="#dt_fifo">_DT_FIFO</a></li>
<li><a href="#dt_chr">_DT_CHR</a></li>
<li><a href="#dt_dir">_DT_DIR</a></li>
<li><a href="#dt_blk">_DT_BLK</a></li>
<li><a href="#dt_reg">_DT_REG</a></li>
<li><a href="#dt_lnk">_DT_LNK</a></li>
<li><a href="#dt_sock">_DT_SOCK</a></li>
<li><a href="#dt_wht">_DT_WHT</a></li>
<li><a href="#opendir">_opendir</a></li>
<li><a href="#fdopendir">_fdopendir</a></li>
<li><a href="#closedir">_closedir</a></li>
<li><a href="#readdir">_readdir</a></li>
<li><a href="#rewinddir">_rewinddir</a></li>
</ul></li>
<li><a href="#errno.bl">errno.bl</a>
<ul>
<li><a href="#errno">_errno</a></li>
</ul></li>
<li><a href="#fcntl.bl">fcntl.bl</a>
<ul>
<li><a href="#o_rdonly">_O_RDONLY</a></li>
<li><a href="#o_wronly">_O_WRONLY</a></li>
<li><a href="#o_rdwr">_O_RDWR</a></li>
<li><a href="#o_creat">_O_CREAT</a></li>
<li><a href="#o_excl">_O_EXCL</a></li>
<li><a href="#o_append">_O_APPEND</a></li>
<li><a href="#o_trunc">_O_TRUNC</a></li>
<li><a href="#open">_open</a></li>
</ul></li>
<li><a href="#stat.bl">stat.bl</a>
<ul>
<li><a href="#stat_ver">_STAT_VER</a></li>
<li><a href="#s_irusr">_S_IRUSR</a></li>
<li><a href="#s_iwusr">_S_IWUSR</a></li>
<li><a href="#s_ixusr">_S_IXUSR</a></li>
<li><a href="#s_irwxu">_S_IRWXU</a></li>
<li><a href="#s_irgrp">_S_IRGRP</a></li>
<li><a href="#s_iwgrp">_S_IWGRP</a></li>
<li><a href="#s_ixgrp">_S_IXGRP</a></li>
<li><a href="#s_irwxg">_S_IRWXG</a></li>
<li><a href="#s_iroth">_S_IROTH</a></li>
<li><a href="#s_iwoth">_S_IWOTH</a></li>
<li><a href="#s_ixoth">_S_IXOTH</a></li>
<li><a href="#s_irwxo">_S_IRWXO</a></li>
<li><a href="#s_ifmt">__S_IFMT</a></li>
<li><a href="#s_ifdir">__S_IFDIR</a></li>
<li><a href="#s_ifchr">__S_IFCHR</a></li>
<li><a href="#s_ifblk">__S_IFBLK</a></li>
<li><a href="#s_ifreg">__S_IFREG</a></li>
<li><a href="#s_ififo">__S_IFIFO</a></li>
<li><a href="#s_iflnk">__S_IFLNK</a></li>
<li><a href="#s_ifsock">__S_IFSOCK</a></li>
<li><a href="#s_isdir">_S_ISDIR</a></li>
<li><a href="#s_isreg">_S_ISREG</a></li>
<li><a href="#stat_t">_stat_t</a></li>
<li><a href="#mkdir">_mkdir</a></li>
<li><a href="#stat">_stat</a></li>
<li><a href="#fstat">_fstat</a></li>
</ul></li>
<li><a href="#types.bl">types.bl</a>
<ul>
<li><a href="#dev_t">_dev_t</a></li>
<li><a href="#ino_t">_ino_t</a></li>
<li><a href="#nlink_t">_nlink_t</a></li>
<li><a href="#mode_t">_mode_t</a></li>
<li><a href="#uid_t">_uid_t</a></li>
<li><a href="#gid_t">_gid_t</a></li>
<li><a href="#off_t">_off_t</a></li>
<li><a href="#blksize_t">_blksize_t</a></li>
<li><a href="#blkcnt_t">_blkcnt_t</a></li>
<li><a href="#time_t">_time_t</a></li>
<li><a href="#syscall_ulong_t">_syscall_ulong_t</a></li>
</ul></li>
<li><a href="#dirent.bl-1">dirent.bl</a>
<ul>
<li><a href="#darwin_maxpathlen">_DARWIN_MAXPATHLEN</a></li>
<li><a href="#dir-1">_DIR</a></li>
<li><a href="#dirent_t-1">_dirent_t</a></li>
<li><a href="#dt_unknown-1">_DT_UNKNOWN</a></li>
<li><a href="#dt_fifo-1">_DT_FIFO</a></li>
<li><a href="#dt_chr-1">_DT_CHR</a></li>
<li><a href="#dt_dir-1">_DT_DIR</a></li>
<li><a href="#dt_blk-1">_DT_BLK</a></li>
<li><a href="#dt_reg-1">_DT_REG</a></li>
<li><a href="#dt_lnk-1">_DT_LNK</a></li>
<li><a href="#dt_sock-1">_DT_SOCK</a></li>
<li><a href="#dt_wht-1">_DT_WHT</a></li>
<li><a href="#opendir-1">_opendir</a></li>
<li><a href="#fdopendir-1">_fdopendir</a></li>
<li><a href="#closedir-1">_closedir</a></li>
<li><a href="#readdir-1">_readdir</a></li>
<li><a href="#rewinddir-1">_rewinddir</a></li>
</ul></li>
<li><a href="#errno.bl-1">errno.bl</a>
<ul>
<li><a href="#errno-1">_errno</a></li>
</ul></li>
<li><a href="#fcntl.bl-1">fcntl.bl</a>
<ul>
<li><a href="#o_rdonly-1">_O_RDONLY</a></li>
<li><a href="#o_wronly-1">_O_WRONLY</a></li>
<li><a href="#o_rdwr-1">_O_RDWR</a></li>
<li><a href="#o_creat-1">_O_CREAT</a></li>
<li><a href="#o_trunc-1">_O_TRUNC</a></li>
<li><a href="#o_excl-1">_O_EXCL</a></li>
<li><a href="#o_append-1">_O_APPEND</a></li>
<li><a href="#open-1">_open</a></li>
</ul></li>
<li><a href="#mach_time.bl">mach_time.bl</a>
<ul>
<li><a href="#machtimebaseinfo">_MachTimebaseInfo</a></li>
<li><a href="#mach_timebase_info">_mach_timebase_info</a></li>
<li><a href="#mach_absolute_time">_mach_absolute_time</a></li>
</ul></li>
<li><a href="#macosapi.bl">macosapi.bl</a>
<ul>
<li><a href="#cfallocatorref">_CFAllocatorRef</a></li>
<li><a href="#cfindex">_CFIndex</a></li>
<li><a href="#cfstringref">_CFStringRef</a></li>
<li><a href="#cfarrayref">_CFArrayRef</a></li>
<li><a href="#cfarraycallbacks">_CFArrayCallBacks</a></li>
<li><a href="#cftimeinterval">_CFTimeInterval</a></li>
<li><a href="#cftyperef">_CFTypeRef</a></li>
<li><a href="#cfrunloopref">_CFRunLoopRef</a></li>
<li><a href="#cfrunloopmode">_CFRunLoopMode</a></li>
<li><a href="#boolean">_Boolean</a></li>
<li><a href="#cfstringencoding">_CFStringEncoding</a></li>
<li><a href="#kfseventstreameventflagnone">_kFSEventStreamEventFlagNone</a></li>
<li><a href="#kfseventstreameventflagmustscansubdirs">_kFSEventStreamEventFlagMustScanSubDirs</a></li>
<li><a href="#kfseventstreameventflaguserdropped">_kFSEventStreamEventFlagUserDropped</a></li>
<li><a href="#kfseventstreameventflagkerneldropped">_kFSEventStreamEventFlagKernelDropped</a></li>
<li><a href="#kfseventstreameventflageventidswrapped">_kFSEventStreamEventFlagEventIdsWrapped</a></li>
<li><a href="#kfseventstreameventflaghistorydone">_kFSEventStreamEventFlagHistoryDone</a></li>
<li><a href="#kfseventstreameventflagrootchanged">_kFSEventStreamEventFlagRootChanged</a></li>
<li><a href="#kfseventstreameventflagmount">_kFSEventStreamEventFlagMount</a></li>
<li><a href="#kfseventstreameventflagunmount">_kFSEventStreamEventFlagUnmount</a></li>
<li><a href="#kfseventstreameventflagitemcreated">_kFSEventStreamEventFlagItemCreated</a></li>
<li><a href="#kfseventstreameventflagitemremoved">_kFSEventStreamEventFlagItemRemoved</a></li>
<li><a href="#kfseventstreameventflagiteminodemetamod">_kFSEventStreamEventFlagItemInodeMetaMod</a></li>
<li><a href="#kfseventstreameventflagitemrenamed">_kFSEventStreamEventFlagItemRenamed</a></li>
<li><a href="#kfseventstreameventflagitemmodified">_kFSEventStreamEventFlagItemModified</a></li>
<li><a href="#kfseventstreameventflagitemfinderinfomod">_kFSEventStreamEventFlagItemFinderInfoMod</a></li>
<li><a href="#kfseventstreameventflagitemchangeowner">_kFSEventStreamEventFlagItemChangeOwner</a></li>
<li><a href="#kfseventstreameventflagitemxattrmod">_kFSEventStreamEventFlagItemXattrMod</a></li>
<li><a href="#kfseventstreameventflagitemisfile">_kFSEventStreamEventFlagItemIsFile</a></li>
<li><a href="#kfseventstreameventflagitemisdir">_kFSEventStreamEventFlagItemIsDir</a></li>
<li><a href="#kfseventstreameventflagitemissymlink">_kFSEventStreamEventFlagItemIsSymlink</a></li>
<li><a href="#kfseventstreameventflagownevent">_kFSEventStreamEventFlagOwnEvent</a></li>
<li><a href="#kfseventstreameventflagitemishardlink">_kFSEventStreamEventFlagItemIsHardlink</a></li>
<li><a href="#kfseventstreameventflagitemislasthardlink">_kFSEventStreamEventFlagItemIsLastHardlink</a></li>
<li><a href="#kfseventstreameventflagitemcloned">_kFSEventStreamEventFlagItemCloned</a></li>
<li><a href="#kfseventstreameventidsincenow">_kFSEventStreamEventIdSinceNow</a></li>
<li><a href="#kfseventstreamcreateflagnone">_kFSEventStreamCreateFlagNone</a></li>
<li><a href="#kfseventstreamcreateflagusecftypes">_kFSEventStreamCreateFlagUseCFTypes</a></li>
<li><a href="#kfseventstreamcreateflagnodefer">_kFSEventStreamCreateFlagNoDefer</a></li>
<li><a href="#kfseventstreamcreateflagwatchroot">_kFSEventStreamCreateFlagWatchRoot</a></li>
<li><a href="#kfseventstreamcreateflagignoreself">_kFSEventStreamCreateFlagIgnoreSelf</a></li>
<li><a href="#kfseventstreamcreateflagfileevents">_kFSEventStreamCreateFlagFileEvents</a></li>
<li><a href="#kfseventstreamcreateflagmarkself">_kFSEventStreamCreateFlagMarkSelf</a></li>
<li><a href="#kfseventstreamcreateflaguseextendeddata">_kFSEventStreamCreateFlagUseExtendedData</a></li>
<li><a href="#fseventstreamref">_FSEventStreamRef</a></li>
<li><a href="#fseventstreameventid">_FSEventStreamEventId</a></li>
<li><a href="#fseventstreamcreateflags">_FSEventStreamCreateFlags</a></li>
<li><a href="#fseventstreameventflags">_FSEventStreamEventFlags</a></li>
<li><a href="#constfseventstreamref">_ConstFSEventStreamRef</a></li>
<li><a href="#cfallocatorretaincallback">_CFAllocatorRetainCallBack</a></li>
<li><a href="#cfallocatorreleasecallback">_CFAllocatorReleaseCallBack</a></li>
<li><a href="#cfallocatorcopydescriptioncallback">_CFAllocatorCopyDescriptionCallBack</a></li>
<li><a href="#cfarraycreate">_CFArrayCreate</a></li>
<li><a href="#cfrunloopgetcurrent">_CFRunLoopGetCurrent</a></li>
<li><a href="#cfrunloopcopycurrentmode">_CFRunLoopCopyCurrentMode</a></li>
<li><a href="#cfrelease">_CFRelease</a></li>
<li><a href="#cfstringcreatewithcstring">_CFStringCreateWithCString</a></li>
<li><a href="#fseventstreamcontext">_FSEventStreamContext</a></li>
<li><a href="#fseventstreamcallback">_FSEventStreamCallback</a></li>
<li><a href="#fseventstreamcreate">_FSEventStreamCreate</a></li>
<li><a href="#fseventstreamschedulewithrunloop">_FSEventStreamScheduleWithRunLoop</a></li>
<li><a href="#fseventstreamunschedulefromrunloop">_FSEventStreamUnscheduleFromRunLoop</a></li>
<li><a href="#fseventstreamstart">_FSEventStreamStart</a></li>
<li><a href="#fseventstreamflushsync">_FSEventStreamFlushSync</a></li>
<li><a href="#fseventstreamstop">_FSEventStreamStop</a></li>
<li><a href="#fseventstreaminvalidate">_FSEventStreamInvalidate</a></li>
<li><a href="#fseventstreamrelease">_FSEventStreamRelease</a></li>
<li><a href="#nsgetexecutablepath">_NSGetExecutablePath</a></li>
</ul></li>
<li><a href="#stat.bl-1">stat.bl</a>
<ul>
<li><a href="#s_irwxu-1">_S_IRWXU</a></li>
<li><a href="#s_irusr-1">_S_IRUSR</a></li>
<li><a href="#s_iwusr-1">_S_IWUSR</a></li>
<li><a href="#s_ixusr-1">_S_IXUSR</a></li>
<li><a href="#s_irwxg-1">_S_IRWXG</a></li>
<li><a href="#s_irgrp-1">_S_IRGRP</a></li>
<li><a href="#s_iwgrp-1">_S_IWGRP</a></li>
<li><a href="#s_ixgrp-1">_S_IXGRP</a></li>
<li><a href="#s_irwxo-1">_S_IRWXO</a></li>
<li><a href="#s_iroth-1">_S_IROTH</a></li>
<li><a href="#s_iwoth-1">_S_IWOTH</a></li>
<li><a href="#s_ixoth-1">_S_IXOTH</a></li>
<li><a href="#s_isuid">_S_ISUID</a></li>
<li><a href="#s_isgid">_S_ISGID</a></li>
<li><a href="#s_isvtx">_S_ISVTX</a></li>
<li><a href="#s_ifmt-1">__S_IFMT</a></li>
<li><a href="#s_ifdir-1">__S_IFDIR</a></li>
<li><a href="#s_ifchr-1">__S_IFCHR</a></li>
<li><a href="#s_ifblk-1">__S_IFBLK</a></li>
<li><a href="#s_ifreg-1">__S_IFREG</a></li>
<li><a href="#s_ififo-1">__S_IFIFO</a></li>
<li><a href="#s_iflnk-1">__S_IFLNK</a></li>
<li><a href="#s_ifsock-1">__S_IFSOCK</a></li>
<li><a href="#s_isdir-1">_S_ISDIR</a></li>
<li><a href="#s_isreg-1">_S_ISREG</a></li>
<li><a href="#stat_t-1">_stat_t</a></li>
<li><a href="#stat-1">_stat</a></li>
<li><a href="#fstat-1">_fstat</a></li>
<li><a href="#mkdir-1">_mkdir</a></li>
<li><a href="#fchmod">_fchmod</a></li>
</ul></li>
<li><a href="#error.bl">error.bl</a>
<ul>
<li><a href="#err_unknown">ERR_UNKNOWN</a></li>
<li><a href="#err_not_found">ERR_NOT_FOUND</a></li>
<li><a href="#err_already_exist">ERR_ALREADY_EXIST</a></li>
<li><a href="#err_access_denied">ERR_ACCESS_DENIED</a></li>
<li><a href="#err_invalid_handle">ERR_INVALID_HANDLE</a></li>
<li><a href="#err_directory">ERR_DIRECTORY</a></li>
<li><a href="#eperm">_EPERM</a></li>
<li><a href="#enoent">_ENOENT</a></li>
<li><a href="#esrch">_ESRCH</a></li>
<li><a href="#eintr">_EINTR</a></li>
<li><a href="#eio">_EIO</a></li>
<li><a href="#enxio">_ENXIO</a></li>
<li><a href="#e2big">_E2BIG</a></li>
<li><a href="#enoexec">_ENOEXEC</a></li>
<li><a href="#ebadf">_EBADF</a></li>
<li><a href="#echild">_ECHILD</a></li>
<li><a href="#eagain">_EAGAIN</a></li>
<li><a href="#enomem">_ENOMEM</a></li>
<li><a href="#eacces">_EACCES</a></li>
<li><a href="#efault">_EFAULT</a></li>
<li><a href="#enotblk">_ENOTBLK</a></li>
<li><a href="#ebusy">_EBUSY</a></li>
<li><a href="#eexist">_EEXIST</a></li>
<li><a href="#exdev">_EXDEV</a></li>
<li><a href="#enodev">_ENODEV</a></li>
<li><a href="#enotdir">_ENOTDIR</a></li>
<li><a href="#eisdir">_EISDIR</a></li>
<li><a href="#einval">_EINVAL</a></li>
<li><a href="#enfile">_ENFILE</a></li>
<li><a href="#emfile">_EMFILE</a></li>
<li><a href="#enotty">_ENOTTY</a></li>
<li><a href="#etxtbsy">_ETXTBSY</a></li>
<li><a href="#efbig">_EFBIG</a></li>
<li><a href="#enospc">_ENOSPC</a></li>
<li><a href="#espipe">_ESPIPE</a></li>
<li><a href="#erofs">_EROFS</a></li>
<li><a href="#emlink">_EMLINK</a></li>
<li><a href="#epipe">_EPIPE</a></li>
<li><a href="#edom">_EDOM</a></li>
<li><a href="#erange">_ERANGE</a></li>
<li><a href="#edeadlk">_EDEADLK</a></li>
<li><a href="#enametoolong">_ENAMETOOLONG</a></li>
<li><a href="#enolck">_ENOLCK</a></li>
<li><a href="#enosys">_ENOSYS</a></li>
<li><a href="#enotempty">_ENOTEMPTY</a></li>
<li><a href="#eloop">_ELOOP</a></li>
<li><a href="#ewouldblock">_EWOULDBLOCK</a></li>
<li><a href="#enomsg">_ENOMSG</a></li>
<li><a href="#eidrm">_EIDRM</a></li>
<li><a href="#echrng">_ECHRNG</a></li>
<li><a href="#el2nsync">_EL2NSYNC</a></li>
<li><a href="#el3hlt">_EL3HLT</a></li>
<li><a href="#el3rst">_EL3RST</a></li>
<li><a href="#elnrng">_ELNRNG</a></li>
<li><a href="#eunatch">_EUNATCH</a></li>
<li><a href="#enocsi">_ENOCSI</a></li>
<li><a href="#el2hlt">_EL2HLT</a></li>
<li><a href="#ebade">_EBADE</a></li>
<li><a href="#ebadr">_EBADR</a></li>
<li><a href="#exfull">_EXFULL</a></li>
<li><a href="#enoano">_ENOANO</a></li>
<li><a href="#ebadrqc">_EBADRQC</a></li>
<li><a href="#ebadslt">_EBADSLT</a></li>
<li><a href="#edeadlock">_EDEADLOCK</a></li>
<li><a href="#ebfont">_EBFONT</a></li>
<li><a href="#enostr">_ENOSTR</a></li>
<li><a href="#enodata">_ENODATA</a></li>
<li><a href="#etime">_ETIME</a></li>
<li><a href="#enosr">_ENOSR</a></li>
<li><a href="#enonet">_ENONET</a></li>
<li><a href="#enopkg">_ENOPKG</a></li>
<li><a href="#eremote">_EREMOTE</a></li>
<li><a href="#enolink">_ENOLINK</a></li>
<li><a href="#eadv">_EADV</a></li>
<li><a href="#esrmnt">_ESRMNT</a></li>
<li><a href="#ecomm">_ECOMM</a></li>
<li><a href="#eproto">_EPROTO</a></li>
<li><a href="#emultihop">_EMULTIHOP</a></li>
<li><a href="#edotdot">_EDOTDOT</a></li>
<li><a href="#ebadmsg">_EBADMSG</a></li>
<li><a href="#eoverflow">_EOVERFLOW</a></li>
<li><a href="#enotuniq">_ENOTUNIQ</a></li>
<li><a href="#ebadfd">_EBADFD</a></li>
<li><a href="#eremchg">_EREMCHG</a></li>
<li><a href="#elibacc">_ELIBACC</a></li>
<li><a href="#elibbad">_ELIBBAD</a></li>
<li><a href="#elibscn">_ELIBSCN</a></li>
<li><a href="#elibmax">_ELIBMAX</a></li>
<li><a href="#elibexec">_ELIBEXEC</a></li>
<li><a href="#eilseq">_EILSEQ</a></li>
<li><a href="#erestart">_ERESTART</a></li>
<li><a href="#estrpipe">_ESTRPIPE</a></li>
<li><a href="#eusers">_EUSERS</a></li>
<li><a href="#enotsock">_ENOTSOCK</a></li>
<li><a href="#edestaddrreq">_EDESTADDRREQ</a></li>
<li><a href="#emsgsize">_EMSGSIZE</a></li>
<li><a href="#eprototype">_EPROTOTYPE</a></li>
<li><a href="#enoprotoopt">_ENOPROTOOPT</a></li>
<li><a href="#eprotonosupport">_EPROTONOSUPPORT</a></li>
<li><a href="#esocktnosupport">_ESOCKTNOSUPPORT</a></li>
<li><a href="#eopnotsupp">_EOPNOTSUPP</a></li>
<li><a href="#epfnosupport">_EPFNOSUPPORT</a></li>
<li><a href="#eafnosupport">_EAFNOSUPPORT</a></li>
<li><a href="#eaddrinuse">_EADDRINUSE</a></li>
<li><a href="#eaddrnotavail">_EADDRNOTAVAIL</a></li>
<li><a href="#enetdown">_ENETDOWN</a></li>
<li><a href="#enetunreach">_ENETUNREACH</a></li>
<li><a href="#enetreset">_ENETRESET</a></li>
<li><a href="#econnaborted">_ECONNABORTED</a></li>
<li><a href="#econnreset">_ECONNRESET</a></li>
<li><a href="#enobufs">_ENOBUFS</a></li>
<li><a href="#eisconn">_EISCONN</a></li>
<li><a href="#enotconn">_ENOTCONN</a></li>
<li><a href="#eshutdown">_ESHUTDOWN</a></li>
<li><a href="#etoomanyrefs">_ETOOMANYREFS</a></li>
<li><a href="#etimedout">_ETIMEDOUT</a></li>
<li><a href="#econnrefused">_ECONNREFUSED</a></li>
<li><a href="#ehostdown">_EHOSTDOWN</a></li>
<li><a href="#ehostunreach">_EHOSTUNREACH</a></li>
<li><a href="#ealready">_EALREADY</a></li>
<li><a href="#einprogress">_EINPROGRESS</a></li>
<li><a href="#estale">_ESTALE</a></li>
<li><a href="#euclean">_EUCLEAN</a></li>
<li><a href="#enotnam">_ENOTNAM</a></li>
<li><a href="#enavail">_ENAVAIL</a></li>
<li><a href="#eisnam">_EISNAM</a></li>
<li><a href="#eremoteio">_EREMOTEIO</a></li>
<li><a href="#edquot">_EDQUOT</a></li>
<li><a href="#enomedium">_ENOMEDIUM</a></li>
<li><a href="#emediumtype">_EMEDIUMTYPE</a></li>
<li><a href="#ecanceled">_ECANCELED</a></li>
<li><a href="#enokey">_ENOKEY</a></li>
<li><a href="#ekeyexpired">_EKEYEXPIRED</a></li>
<li><a href="#ekeyrevoked">_EKEYREVOKED</a></li>
<li><a href="#ekeyrejected">_EKEYREJECTED</a></li>
<li><a href="#eownerdead">_EOWNERDEAD</a></li>
<li><a href="#enotrecoverable">_ENOTRECOVERABLE</a></li>
<li><a href="#erfkill">_ERFKILL</a></li>
<li><a href="#ehwpoison">_EHWPOISON</a></li>
</ul></li>
<li><a href="#libc.bl">libc.bl</a>
<ul>
<li><a href="#c_stdin">C_STDIN</a></li>
<li><a href="#c_stdout">C_STDOUT</a></li>
<li><a href="#c_stderr">C_STDERR</a></li>
<li><a href="#c_rand_max">C_RAND_MAX</a></li>
<li><a href="#c_getenv">c_getenv</a></li>
<li><a href="#c_putenv">c_putenv</a></li>
<li><a href="#c_realpath">c_realpath</a></li>
<li><a href="#c_exit">c_exit</a></li>
<li><a href="#c_system">c_system</a></li>
<li><a href="#c_malloc">c_malloc</a></li>
<li><a href="#c_free">c_free</a></li>
<li><a href="#c_strlen">c_strlen</a></li>
<li><a href="#c_strcmp">c_strcmp</a></li>
<li><a href="#c_wcslen">c_wcslen</a></li>
<li><a href="#c_strerror">c_strerror</a></li>
</ul></li>
<li><a href="#pthread.bl">pthread.bl</a>
<ul>
<li><a href="#pthread_mutex_t">_pthread_mutex_t</a></li>
<li><a href="#pthread_t">_pthread_t</a></li>
<li><a href="#pthread_attr_t">_pthread_attr_t</a></li>
<li><a href="#pthread_start_routine_t">_pthread_start_routine_t</a></li>
<li><a href="#pthread_create">_pthread_create</a></li>
<li><a href="#pthread_join">_pthread_join</a></li>
<li><a href="#pthread_exit">_pthread_exit</a></li>
<li><a href="#pthread_self">_pthread_self</a></li>
<li><a href="#pthread_mutex_lock">_pthread_mutex_lock</a></li>
<li><a href="#pthread_mutex_trylock">_pthread_mutex_trylock</a></li>
<li><a href="#pthread_mutex_unlock">_pthread_mutex_unlock</a></li>
<li><a href="#pthread_mutex_init">_pthread_mutex_init</a></li>
<li><a href="#pthread_mutex_destroy">_pthread_mutex_destroy</a></li>
</ul></li>
<li><a href="#signal.bl">signal.bl</a>
<ul>
<li><a href="#sighup">_SIGHUP</a></li>
<li><a href="#sigint">_SIGINT</a></li>
<li><a href="#sigquit">_SIGQUIT</a></li>
<li><a href="#sigill">_SIGILL</a></li>
<li><a href="#sigtrap">_SIGTRAP</a></li>
<li><a href="#sigabrt">_SIGABRT</a></li>
<li><a href="#sighandler">_Sighandler</a></li>
<li><a href="#raise">_raise</a></li>
<li><a href="#signal">_signal</a></li>
</ul></li>
<li><a href="#unistd.bl">unistd.bl</a>
<ul>
<li><a href="#getcwd">_getcwd</a></li>
<li><a href="#unlink">_unlink</a></li>
<li><a href="#read">_read</a></li>
<li><a href="#readlink">_readlink</a></li>
<li><a href="#close">_close</a></li>
<li><a href="#write">_write</a></li>
<li><a href="#usleep">_usleep</a></li>
<li><a href="#rmdir">_rmdir</a></li>
<li><a href="#chdir">_chdir</a></li>
</ul></li>
<li><a href="#io.bl">io.bl</a>
<ul>
<li><a href="#write-1">_write</a></li>
<li><a href="#read-1">_read</a></li>
</ul></li>
<li><a href="#libc.bl-1">libc.bl</a>
<ul>
<li><a href="#c_stdin-1">C_STDIN</a></li>
<li><a href="#c_stdout-1">C_STDOUT</a></li>
<li><a href="#c_stderr-1">C_STDERR</a></li>
<li><a href="#c_rand_max-1">C_RAND_MAX</a></li>
<li><a href="#c_getenv-1">c_getenv</a></li>
<li><a href="#c_putenv-1">c_putenv</a></li>
<li><a href="#c_realpath-1">c_realpath</a></li>
<li><a href="#c_exit-1">c_exit</a></li>
<li><a href="#c_system-1">c_system</a></li>
<li><a href="#c_malloc-1">c_malloc</a></li>
<li><a href="#c_free-1">c_free</a></li>
<li><a href="#c_strlen-1">c_strlen</a></li>
<li><a href="#c_strcmp-1">c_strcmp</a></li>
<li><a href="#c_wcslen-1">c_wcslen</a></li>
<li><a href="#c_strerror-1">c_strerror</a></li>
</ul></li>
<li><a href="#winapi.bl">winapi.bl</a>
<ul>
<li><a href="#err_unknown-1">ERR_UNKNOWN</a></li>
<li><a href="#err_not_found-1">ERR_NOT_FOUND</a></li>
<li><a href="#err_already_exist-1">ERR_ALREADY_EXIST</a></li>
<li><a href="#err_access_denied-1">ERR_ACCESS_DENIED</a></li>
<li><a href="#err_invalid_handle-1">ERR_INVALID_HANDLE</a></li>
<li><a href="#err_directory-1">ERR_DIRECTORY</a></li>
<li><a href="#true">TRUE</a></li>
<li><a href="#false">FALSE</a></li>
<li><a href="#max_path">MAX_PATH</a></li>
<li><a href="#invalid_handle_value">INVALID_HANDLE_VALUE</a></li>
<li><a href="#infinite">INFINITE</a></li>
<li><a href="#error_file_not_found">ERROR_FILE_NOT_FOUND</a></li>
<li><a href="#error_file_exists">ERROR_FILE_EXISTS</a></li>
<li><a href="#error_access_denied">ERROR_ACCESS_DENIED</a></li>
<li><a href="#error_invalid_handle">ERROR_INVALID_HANDLE</a></li>
<li><a href="#error_directory">ERROR_DIRECTORY</a></li>
<li><a href="#cp_utf8">CP_UTF8</a></li>
<li><a href="#wchar">WCHAR</a></li>
<li><a href="#lpwstr">LPWSTR</a></li>
<li><a href="#lpcwstr">LPCWSTR</a></li>
<li><a href="#lpcstr">LPCSTR</a></li>
<li><a href="#lpstr">LPSTR</a></li>
<li><a href="#lpctstr">LPCTSTR</a></li>
<li><a href="#hlocal">HLOCAL</a></li>
<li><a href="#uint">UINT</a></li>
<li><a href="#dword">DWORD</a></li>
<li><a href="#lpcch">LPCCH</a></li>
<li><a href="#lpcwch">LPCWCH</a></li>
<li><a href="#lpbool">LPBOOL</a></li>
<li><a href="#hmodule">HMODULE</a></li>
<li><a href="#bool">BOOL</a></li>
<li><a href="#pbool">PBOOL</a></li>
<li><a href="#farproc">FARPROC</a></li>
<li><a href="#lpvoid">LPVOID</a></li>
<li><a href="#lpoverlapped">LPOVERLAPPED</a></li>
<li><a href="#lpdword">LPDWORD</a></li>
<li><a href="#handle">HANDLE</a></li>
<li><a href="#ulong_ptr">ULONG_PTR</a></li>
<li><a href="#size_t">SIZE_T</a></li>
<li><a href="#pvoid">PVOID</a></li>
<li><a href="#char">CHAR</a></li>
<li><a href="#long_ptr">LONG_PTR</a></li>
<li><a href="#large_integer">LARGE_INTEGER</a></li>
<li><a href="#plarge_integer">PLARGE_INTEGER</a></li>
<li><a href="#hglobal">HGLOBAL</a></li>
<li><a href="#hwnd">HWND</a></li>
<li><a href="#long">LONG</a></li>
<li><a href="#plong">PLONG</a></li>
<li><a href="#word">WORD</a></li>
<li><a href="#generic_read">GENERIC_READ</a></li>
<li><a href="#generic_write">GENERIC_WRITE</a></li>
<li><a href="#file_begin">FILE_BEGIN</a></li>
<li><a href="#file_current">FILE_CURRENT</a></li>
<li><a href="#file_end">FILE_END</a></li>
<li><a href="#create_new">CREATE_NEW</a></li>
<li><a href="#create_always">CREATE_ALWAYS</a></li>
<li><a href="#open_existing">OPEN_EXISTING</a></li>
<li><a href="#open_always">OPEN_ALWAYS</a></li>
<li><a href="#truncate_existing">TRUNCATE_EXISTING</a></li>
<li><a href="#lpoverlapped_completion_routine">LPOVERLAPPED_COMPLETION_ROUTINE</a></li>
<li><a href="#file_add_file">FILE_ADD_FILE</a></li>
<li><a href="#file_add_subdirectory">FILE_ADD_SUBDIRECTORY</a></li>
<li><a href="#file_append_data">FILE_APPEND_DATA</a></li>
<li><a href="#file_attribute_archive">FILE_ATTRIBUTE_ARCHIVE</a></li>
<li><a href="#file_attribute_compressed">FILE_ATTRIBUTE_COMPRESSED</a></li>
<li><a href="#file_attribute_device">FILE_ATTRIBUTE_DEVICE</a></li>
<li><a href="#file_attribute_directory">FILE_ATTRIBUTE_DIRECTORY</a></li>
<li><a href="#file_attribute_encrypted">FILE_ATTRIBUTE_ENCRYPTED</a></li>
<li><a href="#file_attribute_hidden">FILE_ATTRIBUTE_HIDDEN</a></li>
<li><a href="#file_attribute_normal">FILE_ATTRIBUTE_NORMAL</a></li>
<li><a href="#file_attribute_not_content_indexed">FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</a></li>
<li><a href="#file_attribute_offline">FILE_ATTRIBUTE_OFFLINE</a></li>
<li><a href="#file_attribute_readonly">FILE_ATTRIBUTE_READONLY</a></li>
<li><a href="#file_attribute_reparse_point">FILE_ATTRIBUTE_REPARSE_POINT</a></li>
<li><a href="#file_attribute_sparse_file">FILE_ATTRIBUTE_SPARSE_FILE</a></li>
<li><a href="#file_attribute_system">FILE_ATTRIBUTE_SYSTEM</a></li>
<li><a href="#file_attribute_temporary">FILE_ATTRIBUTE_TEMPORARY</a></li>
<li><a href="#file_attribute_virtual">FILE_ATTRIBUTE_VIRTUAL</a></li>
<li><a href="#file_create_pipe_instance">FILE_CREATE_PIPE_INSTANCE</a></li>
<li><a href="#file_flag_backup_semantics">FILE_FLAG_BACKUP_SEMANTICS</a></li>
<li><a href="#file_flag_delete_on_close">FILE_FLAG_DELETE_ON_CLOSE</a></li>
<li><a href="#file_flag_first_pipe_instance">FILE_FLAG_FIRST_PIPE_INSTANCE</a></li>
<li><a href="#file_flag_no_buffering">FILE_FLAG_NO_BUFFERING</a></li>
<li><a href="#file_flag_open_no_recall">FILE_FLAG_OPEN_NO_RECALL</a></li>
<li><a href="#file_flag_open_reparse_point">FILE_FLAG_OPEN_REPARSE_POINT</a></li>
<li><a href="#file_flag_overlapped">FILE_FLAG_OVERLAPPED</a></li>
<li><a href="#file_flag_posix_semantics">FILE_FLAG_POSIX_SEMANTICS</a></li>
<li><a href="#file_flag_random_access">FILE_FLAG_RANDOM_ACCESS</a></li>
<li><a href="#file_flag_sequential_scan">FILE_FLAG_SEQUENTIAL_SCAN</a></li>
<li><a href="#file_flag_session_aware">FILE_FLAG_SESSION_AWARE</a></li>
<li><a href="#file_flag_write_through">FILE_FLAG_WRITE_THROUGH</a></li>
<li><a href="#file_list_directory">FILE_LIST_DIRECTORY</a></li>
<li><a href="#file_read_data">FILE_READ_DATA</a></li>
<li><a href="#file_share_delete">FILE_SHARE_DELETE</a></li>
<li><a href="#file_share_read">FILE_SHARE_READ</a></li>
<li><a href="#file_share_write">FILE_SHARE_WRITE</a></li>
<li><a href="#file_write_data">FILE_WRITE_DATA</a></li>
<li><a href="#ghnd">GHND</a></li>
<li><a href="#gmem_fixed">GMEM_FIXED</a></li>
<li><a href="#gmem_moveable">GMEM_MOVEABLE</a></li>
<li><a href="#gmem_zeroinit">GMEM_ZEROINIT</a></li>
<li><a href="#gptr">GPTR</a></li>
<li><a href="#cf_text">CF_TEXT</a></li>
<li><a href="#file_notify_change_file_name">FILE_NOTIFY_CHANGE_FILE_NAME</a></li>
<li><a href="#file_notify_change_dir_name">FILE_NOTIFY_CHANGE_DIR_NAME</a></li>
<li><a href="#file_notify_change_attributes">FILE_NOTIFY_CHANGE_ATTRIBUTES</a></li>
<li><a href="#file_notify_change_size">FILE_NOTIFY_CHANGE_SIZE</a></li>
<li><a href="#file_notify_change_last_write">FILE_NOTIFY_CHANGE_LAST_WRITE</a></li>
<li><a href="#file_notify_change_last_access">FILE_NOTIFY_CHANGE_LAST_ACCESS</a></li>
<li><a href="#file_notify_change_creation">FILE_NOTIFY_CHANGE_CREATION</a></li>
<li><a href="#file_notify_change_security">FILE_NOTIFY_CHANGE_SECURITY</a></li>
<li><a href="#file_notify_information">FILE_NOTIFY_INFORMATION</a></li>
<li><a href="#overlapped">OVERLAPPED</a></li>
<li><a href="#filetime">FILETIME</a></li>
<li><a href="#pfiletime">PFILETIME</a></li>
<li><a href="#lpfiletime">LPFILETIME</a></li>
<li><a href="#find_data">FIND_DATA</a></li>
<li><a href="#by_handle_file_information">BY_HANDLE_FILE_INFORMATION</a></li>
<li><a href="#lpby_handle_file_information">LPBY_HANDLE_FILE_INFORMATION</a></li>
<li><a href="#find_dataa">FIND_DATAA</a></li>
<li><a href="#p_find_dataa">P_FIND_DATAA</a></li>
<li><a href="#lp_find_dataa">LP_FIND_DATAA</a></li>
<li><a href="#invalid_handle">INVALID_HANDLE</a></li>
<li><a href="#invalid_file_attributes">INVALID_FILE_ATTRIBUTES</a></li>
<li><a href="#wait_timeout">WAIT_TIMEOUT</a></li>
<li><a href="#wait_failed">WAIT_FAILED</a></li>
<li><a href="#wait_object_0">WAIT_OBJECT_0</a></li>
<li><a href="#list_entry">LIST_ENTRY</a></li>
<li><a href="#rtl_critical_section_debug">RTL_CRITICAL_SECTION_DEBUG</a></li>
<li><a href="#prtl_critical_section_debug">PRTL_CRITICAL_SECTION_DEBUG</a></li>
<li><a href="#rtl_critical_section">RTL_CRITICAL_SECTION</a></li>
<li><a href="#lpcritical_section">LPCRITICAL_SECTION</a></li>
<li><a href="#format_message_ignore_inserts">FORMAT_MESSAGE_IGNORE_INSERTS</a></li>
<li><a href="#format_message_from_string">FORMAT_MESSAGE_FROM_STRING</a></li>
<li><a href="#format_message_from_hmodule">FORMAT_MESSAGE_FROM_HMODULE</a></li>
<li><a href="#format_message_from_system">FORMAT_MESSAGE_FROM_SYSTEM</a></li>
<li><a href="#format_message_argument_array">FORMAT_MESSAGE_ARGUMENT_ARRAY</a></li>
<li><a href="#format_message_max_width_mask">FORMAT_MESSAGE_MAX_WIDTH_MASK</a></li>
<li><a href="#findfirstfile">FindFirstFile</a></li>
<li><a href="#findclose">FindClose</a></li>
<li><a href="#findnextfile">FindNextFile</a></li>
<li><a href="#getfileattributesa">GetFileAttributesA</a></li>
<li><a href="#createfile">CreateFile</a></li>
<li><a href="#createdirectorya">CreateDirectoryA</a></li>
<li><a href="#readdirectorychanges">ReadDirectoryChanges</a></li>
<li><a href="#widechartomultibyte">WideCharToMultiByte</a></li>
<li><a href="#createevent">CreateEvent</a></li>
<li><a href="#setevent">SetEvent</a></li>
<li><a href="#findfirstchangenotification">FindFirstChangeNotification</a></li>
<li><a href="#findnextchangenotification">FindNextChangeNotification</a></li>
<li><a href="#findclosechangenotification">FindCloseChangeNotification</a></li>
<li><a href="#waitforsingleobject">WaitForSingleObject</a></li>
<li><a href="#waitformultipleobjects">WaitForMultipleObjects</a></li>
<li><a href="#getcommandlinew">GetCommandLineW</a></li>
<li><a href="#commandlinetoargvw">CommandLineToArgvW</a></li>
<li><a href="#localfree">LocalFree</a></li>
<li><a href="#sleep">Sleep</a></li>
<li><a href="#sleepex">SleepEx</a></li>
<li><a href="#getfullpathnamea">GetFullPathNameA</a></li>
<li><a href="#pathfileexistsa">PathFileExistsA</a></li>
<li><a href="#loadlibrarya">LoadLibraryA</a></li>
<li><a href="#freelibrary">FreeLibrary</a></li>
<li><a href="#getmodulehandlea">GetModuleHandleA</a></li>
<li><a href="#getprocaddress">GetProcAddress</a></li>
<li><a href="#debugbreak">DebugBreak</a></li>
<li><a href="#isdebuggerpresent">IsDebuggerPresent</a></li>
<li><a href="#checkremotedebuggerpresent">CheckRemoteDebuggerPresent</a></li>
<li><a href="#getmodulefilenamea">GetModuleFileNameA</a></li>
<li><a href="#security_attributes">SECURITY_ATTRIBUTES</a></li>
<li><a href="#psecurity_attributes">PSECURITY_ATTRIBUTES</a></li>
<li><a href="#lpsecurity_attributes">LPSECURITY_ATTRIBUTES</a></li>
<li><a href="#lpthread_start_routine">LPTHREAD_START_ROUTINE</a></li>
<li><a href="#createthread">CreateThread</a></li>
<li><a href="#getcurrentthread">GetCurrentThread</a></li>
<li><a href="#terminatethread">TerminateThread</a></li>
<li><a href="#getexitcodethread">GetExitCodeThread</a></li>
<li><a href="#createmutexa">CreateMutexA</a></li>
<li><a href="#releasemutex">ReleaseMutex</a></li>
<li><a href="#gettickcount">GetTickCount</a></li>
<li><a href="#queryperformancecounter">QueryPerformanceCounter</a></li>
<li><a href="#queryperformancefrequency">QueryPerformanceFrequency</a></li>
<li><a href="#globalalloc">GlobalAlloc</a></li>
<li><a href="#globalfree">GlobalFree</a></li>
<li><a href="#globallock">GlobalLock</a></li>
<li><a href="#globalunlock">GlobalUnlock</a></li>
<li><a href="#openclipboard">OpenClipboard</a></li>
<li><a href="#emptyclipboard">EmptyClipboard</a></li>
<li><a href="#setclipboarddata">SetClipboardData</a></li>
<li><a href="#getclipboarddata">GetClipboardData</a></li>
<li><a href="#closeclipboard">CloseClipboard</a></li>
<li><a href="#getlasterror">GetLastError</a></li>
<li><a href="#closehandle">CloseHandle</a></li>
<li><a href="#gettemppatha">GetTempPathA</a></li>
<li><a href="#deletefilea">DeleteFileA</a></li>
<li><a href="#removedirectorya">RemoveDirectoryA</a></li>
<li><a href="#getcurrentdirectorya">GetCurrentDirectoryA</a></li>
<li><a href="#setcurrentdirectorya">SetCurrentDirectoryA</a></li>
<li><a href="#getfilesizeex">GetFileSizeEx</a></li>
<li><a href="#readfile">ReadFile</a></li>
<li><a href="#writefile">WriteFile</a></li>
<li><a href="#copyfilea">CopyFileA</a></li>
<li><a href="#setendoffile">SetEndOfFile</a></li>
<li><a href="#setfilepointer">SetFilePointer</a></li>
<li><a href="#initializecriticalsection">InitializeCriticalSection</a></li>
<li><a href="#deletecriticalsection">DeleteCriticalSection</a></li>
<li><a href="#entercriticalsection">EnterCriticalSection</a></li>
<li><a href="#leavecriticalsection">LeaveCriticalSection</a></li>
<li><a href="#tryentercriticalsection">TryEnterCriticalSection</a></li>
<li><a href="#getfileinformationbyhandle">GetFileInformationByHandle</a></li>
<li><a href="#getoverlappedresult">GetOverlappedResult</a></li>
<li><a href="#resetevent">ResetEvent</a></li>
<li><a href="#formatmessagea">FormatMessageA</a></li>
</ul></li>
<li><a href="#command-line-argument-parser">Command Line Argument Parser</a>
<ul>
<li><a href="#ctx">Ctx</a></li>
<li><a href="#parser">Parser</a></li>
<li><a href="#handlerfn">HandlerFn</a></li>
<li><a href="#new">new</a></li>
<li><a href="#delete">delete</a></li>
<li><a href="#ctx_terminate">ctx_terminate</a></li>
<li><a href="#run">run</a></li>
<li><a href="#add">add</a></li>
<li><a href="#print_help">print_help</a></li>
</ul></li>
<li><a href="#array">Array</a>
<ul>
<li><a href="#array-1">_Array</a></li>
<li><a href="#array_init">array_init</a></li>
<li><a href="#array_terminate">array_terminate</a></li>
<li><a href="#array_push">array_push</a></li>
<li><a href="#array_reserve">array_reserve</a></li>
<li><a href="#array_erase">array_erase</a></li>
<li><a href="#array_clear">array_clear</a></li>
</ul></li>
<li><a href="#debug">Debug</a>
<ul>
<li><a href="#print_warn">print_warn</a></li>
<li><a href="#print_err">print_err</a></li>
<li><a href="#assert">assert</a></li>
<li><a href="#static_assert">__static_assert</a></li>
<li><a href="#panic">panic</a></li>
<li><a href="#printlogkind">PrintLogKind</a></li>
<li><a href="#print_log_default">__print_log_default</a></li>
<li><a href="#measure_elapsed_ms_begin">measure_elapsed_ms_begin</a></li>
<li><a href="#measure_elapsed_ms_end">measure_elapsed_ms_end</a></li>
</ul></li>
<li><a href="#debug-allocator">Debug Allocator</a>
<ul>
<li><a href="#init">init</a></li>
<li><a href="#terminate">terminate</a></li>
<li><a href="#break_on">break_on</a></li>
<li><a href="#allocated_bytes">allocated_bytes</a></li>
<li><a href="#print_memory_report">print_memory_report</a></li>
</ul></li>
<li><a href="#dynamic-library-tools">Dynamic Library Tools</a>
<ul>
<li><a href="#open-2">open</a></li>
<li><a href="#get_symbol">get_symbol</a></li>
<li><a href="#close-1">close</a></li>
</ul></li>
<li><a href="#error-handling">Error handling</a>
<ul>
<li><a href="#ok">OK</a></li>
<li><a href="#error">_Error</a></li>
<li><a href="#error-1">Error</a></li>
<li><a href="#is_ok">is_ok</a></li>
<li><a href="#is_error">is_error</a></li>
<li><a href="#ok-1">ok</a></li>
<li><a href="#error-2">error</a></li>
</ul></li>
<li><a href="#file-system">File System</a>
<ul>
<li><a href="#file_invalid">FILE_INVALID</a></li>
<li><a href="#openmode">OpenMode</a></li>
<li><a href="#copyopt">CopyOpt</a></li>
<li><a href="#infokind">InfoKind</a></li>
<li><a href="#info">Info</a></li>
<li><a href="#infolist">InfoList</a></li>
<li><a href="#exist">exist</a></li>
<li><a href="#open-3">open</a></li>
<li><a href="#close-2">close</a></li>
<li><a href="#get_uid">get_uid</a></li>
<li><a href="#remove">remove</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#dir_copy">dir_copy</a></li>
<li><a href="#size">size</a></li>
<li><a href="#read_string">read_string</a></li>
<li><a href="#read_slice">read_slice</a></li>
<li><a href="#read-2">read</a></li>
<li><a href="#write-2">write</a></li>
<li><a href="#write_string">write_string</a></li>
<li><a href="#write_fmt">write_fmt</a></li>
<li><a href="#write_slice">write_slice</a></li>
<li><a href="#dir_create">dir_create</a></li>
<li><a href="#dir_create_all">dir_create_all</a></li>
<li><a href="#dir_remove">dir_remove</a></li>
<li><a href="#dir_remove_all">dir_remove_all</a></li>
<li><a href="#is_directory">is_directory</a></li>
<li><a href="#dirscanfilterfn">DirScanFilterFn</a></li>
<li><a href="#dir_scan">dir_scan</a></li>
<li><a href="#info_list_delete">info_list_delete</a></li>
<li><a href="#validate_filename">validate_filename</a></li>
<li><a href="#get_cwd">get_cwd</a></li>
<li><a href="#set_cwd">set_cwd</a></li>
<li><a href="#get_home">get_home</a></li>
<li><a href="#get_tmp">get_tmp</a></li>
<li><a href="#normalize">normalize</a></li>
<li><a href="#remove_extension">remove_extension</a></li>
<li><a href="#get_extension">get_extension</a></li>
<li><a href="#get_directory">get_directory</a></li>
<li><a href="#v2_one">v2_one</a></li>
<li><a href="#v2_zero">v2_zero</a></li>
<li><a href="#v3">v3</a></li>
<li><a href="#v3_right">v3_right</a></li>
<li><a href="#v3_up">v3_up</a></li>
<li><a href="#v3_forward">v3_forward</a></li>
<li><a href="#v3_one">v3_one</a></li>
<li><a href="#v3_zero">v3_zero</a></li>
<li><a href="#v4">v4</a></li>
<li><a href="#v4_one">v4_one</a></li>
<li><a href="#v4_zero">v4_zero</a></li>
<li><a href="#color_white">color_white</a></li>
<li><a href="#color_black">color_black</a></li>
<li><a href="#color_red">color_red</a></li>
<li><a href="#color_green">color_green</a></li>
<li><a href="#color_blue">color_blue</a></li>
<li><a href="#color_yellow">color_yellow</a></li>
<li><a href="#iv2">iv2</a></li>
<li><a href="#iv3">iv3</a></li>
<li><a href="#mat4">mat4</a></li>
<li><a href="#quat">quat</a></li>
<li><a href="#quat_identity">quat_identity</a></li>
<li><a href="#v_sub">v_sub</a></li>
<li><a href="#v_add">v_add</a></li>
<li><a href="#v_mul">v_mul</a></li>
<li><a href="#v_div">v_div</a></li>
<li><a href="#v_length">v_length</a></li>
<li><a href="#v_sqr_lenght">v_sqr_lenght</a></li>
<li><a href="#v_dot">v_dot</a></li>
<li><a href="#v_normalize">v_normalize</a></li>
<li><a href="#v_compare">v_compare</a></li>
<li><a href="#v_negate">v_negate</a></li>
<li><a href="#v_cross">v_cross</a></li>
<li><a href="#v_round">v_round</a></li>
<li><a href="#v_floor">v_floor</a></li>
<li><a href="#v_ceil">v_ceil</a></li>
<li><a href="#mat4_init">mat4_init</a></li>
<li><a href="#mat4_identity">mat4_identity</a></li>
<li><a href="#mat4_zero">mat4_zero</a></li>
<li><a href="#mat4_perspective">mat4_perspective</a></li>
<li><a href="#mat4_ortho">mat4_ortho</a></li>
<li><a href="#mat4_look_at">mat4_look_at</a></li>
<li><a href="#mat4_mul">mat4_mul</a></li>
<li><a href="#mat4_inverse">mat4_inverse</a></li>
<li><a href="#mat4_scale_s">mat4_scale_s</a></li>
<li><a href="#mat4_mul_v4">mat4_mul_v4</a></li>
<li><a href="#mat4_translation">mat4_translation</a></li>
<li><a href="#mat4_scale">mat4_scale</a></li>
<li><a href="#mat4_get_scale">mat4_get_scale</a></li>
<li><a href="#mat4_get_translation">mat4_get_translation</a></li>
<li><a href="#mat4_get_quat">mat4_get_quat</a></li>
<li><a href="#quat_normalize">quat_normalize</a></li>
<li><a href="#quat_to_mat4">quat_to_mat4</a></li>
<li><a href="#quat_look">quat_look</a></li>
<li><a href="#quat_look_for">quat_look_for</a></li>
<li><a href="#quat_axis_angle">quat_axis_angle</a></li>
<li><a href="#quat_imag">quat_imag</a></li>
<li><a href="#quat_real">quat_real</a></li>
<li><a href="#quat_mul">quat_mul</a></li>
<li><a href="#quat_rotate_v3">quat_rotate_v3</a></li>
<li><a href="#quat_forward">quat_forward</a></li>
</ul></li>
<li><a href="#math">Math</a>
<ul>
<li><a href="#two_pi">TWO_PI</a></li>
<li><a href="#half_pi">HALF_PI</a></li>
<li><a href="#f32_epsilon">F32_EPSILON</a></li>
<li><a href="#f64_epsilon">F64_EPSILON</a></li>
<li><a href="#s8_min">S8_MIN</a></li>
<li><a href="#s8_max">S8_MAX</a></li>
<li><a href="#s16_min">S16_MIN</a></li>
<li><a href="#s16_max">S16_MAX</a></li>
<li><a href="#s32_min">S32_MIN</a></li>
<li><a href="#s32_max">S32_MAX</a></li>
<li><a href="#s64_min">S64_MIN</a></li>
<li><a href="#s64_max">S64_MAX</a></li>
<li><a href="#u8_min">U8_MIN</a></li>
<li><a href="#u8_max">U8_MAX</a></li>
<li><a href="#u16_min">U16_MIN</a></li>
<li><a href="#u16_max">U16_MAX</a></li>
<li><a href="#u32_min">U32_MIN</a></li>
<li><a href="#u32_max">U32_MAX</a></li>
<li><a href="#u64_min">U64_MIN</a></li>
<li><a href="#u64_max">U64_MAX</a></li>
<li><a href="#sin">sin</a></li>
<li><a href="#cos">cos</a></li>
<li><a href="#asin">asin</a></li>
<li><a href="#acos">acos</a></li>
<li><a href="#floor">floor</a></li>
<li><a href="#round">round</a></li>
<li><a href="#pow">pow</a></li>
<li><a href="#log">log</a></li>
<li><a href="#log2">log2</a></li>
<li><a href="#log10">log10</a></li>
<li><a href="#sqrt">sqrt</a></li>
<li><a href="#ceil">ceil</a></li>
<li><a href="#tan">tan</a></li>
<li><a href="#atan2">atan2</a></li>
<li><a href="#copysign">copysign</a></li>
<li><a href="#rand">rand</a></li>
<li><a href="#srand">srand</a></li>
<li><a href="#qsort">qsort</a></li>
<li><a href="#abs">abs</a></li>
<li><a href="#compare">compare</a></li>
<li><a href="#degtorad">degtorad</a></li>
<li><a href="#radtodeg">radtodeg</a></li>
<li><a href="#max">max</a></li>
<li><a href="#min">min</a></li>
<li><a href="#lerp">lerp</a></li>
<li><a href="#clamp">clamp</a></li>
</ul></li>
<li><a href="#memory">Memory</a>
<ul>
<li><a href="#memory-allocator">Memory allocator</a></li>
<li><a href="#calloc">calloc</a></li>
<li><a href="#free">free</a></li>
<li><a href="#memcpy">memcpy</a></li>
<li><a href="#memset">memset</a></li>
<li><a href="#init_default">init_default</a></li>
<li><a href="#swap">swap</a></li>
<li><a href="#is_aligned">is_aligned</a></li>
<li><a href="#align_ptr_up">align_ptr_up</a></li>
<li><a href="#slice_init">slice_init</a></li>
<li><a href="#slice_terminate">slice_terminate</a></li>
<li><a href="#slice_range">slice_range</a></li>
<li><a href="#allocop">AllocOp</a></li>
<li><a href="#allocator">Allocator</a></li>
<li><a href="#allocfn">AllocFn</a></li>
<li><a href="#allocate_memory">allocate_memory</a></li>
<li><a href="#free_memory">free_memory</a></li>
<li><a href="#release_memory">release_memory</a></li>
<li><a href="#default_allocator">default_allocator</a></li>
</ul></li>
<li><a href="#print">Print</a>
<ul>
<li><a href="#print-1">print</a></li>
<li><a href="#eprint">eprint</a></li>
<li><a href="#bprint">bprint</a></li>
<li><a href="#tprint">tprint</a></li>
<li><a href="#sprint">sprint</a></li>
<li><a href="#fmtreal">FmtReal</a></li>
<li><a href="#fmt_real">fmt_real</a></li>
<li><a href="#fmtintbase">FmtIntBase</a></li>
<li><a href="#fmtint">FmtInt</a></li>
<li><a href="#fmt_int">fmt_int</a></li>
<li><a href="#fmtchar">FmtChar</a></li>
<li><a href="#fmt_char">fmt_char</a></li>
<li><a href="#print_impl">_print_impl</a></li>
</ul></li>
<li><a href="#string">String</a>
<ul>
<li><a href="#delete-1">delete</a></li>
<li><a href="#reserve">reserve</a></li>
<li><a href="#get_allocated_bytes">get_allocated_bytes</a></li>
<li><a href="#clear">clear</a></li>
<li><a href="#append">append</a></li>
<li><a href="#append_str">_append_str</a></li>
<li><a href="#append_any">_append_any</a></li>
<li><a href="#concatenate">concatenate</a></li>
<li><a href="#clear_concat">clear_concat</a></li>
<li><a href="#compare-1">compare</a></li>
<li><a href="#compare2">compare2</a></li>
<li><a href="#to_f32">to_f32</a></li>
<li><a href="#to_s64">to_s64</a></li>
<li><a href="#split_by_last">split_by_last</a></li>
<li><a href="#split_at_index">split_at_index</a></li>
<li><a href="#split_by_first">split_by_first</a></li>
<li><a href="#insert">insert</a></li>
<li><a href="#erase">erase</a></li>
<li><a href="#split_by">split_by</a></li>
<li><a href="#count_of">count_of</a></li>
<li><a href="#to_lower">to_lower</a></li>
<li><a href="#to_upper">to_upper</a></li>
<li><a href="#replace_all">replace_all</a></li>
<li><a href="#hash">hash</a></li>
<li><a href="#is_null">is_null</a></li>
<li><a href="#is_empty">is_empty</a></li>
<li><a href="#empty">empty</a></li>
<li><a href="#is_null_or_empty">is_null_or_empty</a></li>
<li><a href="#sub">sub</a></li>
<li><a href="#is_zero_terminated">is_zero_terminated</a></li>
</ul></li>
<li><a href="#thread-synchronization">Thread synchronization</a>
<ul>
<li><a href="#init-1">init</a></li>
<li><a href="#terminate-1">terminate</a></li>
<li><a href="#lock">lock</a></li>
<li><a href="#try_lock">try_lock</a></li>
<li><a href="#unlock">unlock</a></li>
</ul></li>
<li><a href="#test">Test</a>
<ul>
<li><a href="#test_neq">test_neq</a></li>
<li><a href="#test_gt">test_gt</a></li>
<li><a href="#test_lt">test_lt</a></li>
<li><a href="#test_true">test_true</a></li>
<li><a href="#test_false">test_false</a></li>
<li><a href="#test_null">test_null</a></li>
<li><a href="#test_not_null">test_not_null</a></li>
<li><a href="#test_ok">test_ok</a></li>
<li><a href="#test_not_ok">test_not_ok</a></li>
<li><a href="#test_is_error">test_is_error</a></li>
<li><a href="#test_run">test_run</a></li>
</ul></li>
<li><a href="#thread">Thread</a>
<ul>
<li><a href="#handle-1">Handle</a></li>
<li><a href="#create">create</a></li>
<li><a href="#join">join</a></li>
<li><a href="#join_all">join_all</a></li>
<li><a href="#exit">exit</a></li>
<li><a href="#current">current</a></li>
</ul></li>
<li><a href="#temporary-allocator">Temporary Allocator</a>
<ul>
<li><a href="#temporary_reset">temporary_reset</a></li>
<li><a href="#temporary_release">temporary_release</a></li>
<li><a href="#temporary_allocated_bytes">temporary_allocated_bytes</a></li>
</ul></li>
<li><a href="#utils">Utils</a>
<ul>
<li><a href="#clr_flag">clr_flag</a></li>
<li><a href="#is_flag">is_flag</a></li>
<li><a href="#make_flags">make_flags</a></li>
<li><a href="#cstr_to_str">cstr_to_str</a></li>
<li><a href="#ptr_shift_bytes">ptr_shift_bytes</a></li>
<li><a href="#ptr_diff">ptr_diff</a></li>
<li><a href="#env_get">env_get</a></li>
<li><a href="#env_set">env_set</a></li>
<li><a href="#random_seed_time">random_seed_time</a></li>
<li><a href="#random_number">random_number</a></li>
<li><a href="#sort">sort</a></li>
<li><a href="#hash_combine">hash_combine</a></li>
</ul></li>
</ul>
</nav>
<h1 id="builtin">Builtin</h1>
<p>Compiler builtins are automatically loaded into every assembly.</p>
<h2 id="current-running-platform">Current running platform</h2>
<pre><code>Platform :: enum s32 {
    unknown;
    windows;
    darwin;
    linux;
}

PLATFORM :: &lt;SET_BY_COMPILER&gt;;</code></pre>
<h2 id="current-running-architecture">Current running architecture</h2>
<pre><code>Arch :: enum s32 {
    unknown;
    x86_64;
    aarch64;
    arm64;
}

ARCH :: &lt;SET_BY_COMPILER&gt;;</code></pre>
<h2 id="current-running-environment">Current running environment</h2>
<pre><code>Env :: enum s32 {
    unknown;
    msvc;
    gnu;
}

ENV :: &lt;SET_BY_COMPILER&gt;;</code></pre>
<h2 id="typekind">TypeKind</h2>
<pre><code>TypeKind :: enum {
    Type :: 1;
    Void :: 2;
    Int :: 3;
    Real :: 4;
    Fn :: 5;
    Ptr :: 6;
    Bool :: 7;
    Array :: 8;
    Struct :: 9;
    Enum :: 10;
    Null :: 11;
    String :: 12;
    FnGroup :: 16;
}</code></pre>
<p>TypeKind describes kind of BL type returned in <code>TypeInfo</code> structure. This value can be used for safe casting.</p>
<h3 id="variants">Variants</h3>
<p><strong>Type</strong> - Base type of all types in type system.</p>
<p><strong>Void</strong> - Void type. (Implicitly used for functions without return value)</p>
<p><strong>Int</strong> - Any integer type: <code>s8</code>, <code>s16</code>, <code>s32</code>, <code>s64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>.</p>
<p><strong>Real</strong> - Any real type: <code>f32</code>, <code>f64</code>.</p>
<p><strong>Fn</strong> - Function type.</p>
<p><strong>Ptr</strong> - Pointer type.</p>
<p><strong>Bool</strong> - Boolean type.</p>
<p><strong>Array</strong> - Array type.</p>
<p><strong>Struct</strong> - Structure type.</p>
<p><strong>Enum</strong> - Enumerator type.</p>
<p><strong>Null</strong> - Null-value type.</p>
<p><strong>String</strong> - String type.</p>
<p><strong>FnGroup</strong> - Function group type.</p>
<hr />
<h2 id="typeinfo">TypeInfo</h2>
<pre><code>TypeInfo :: struct {
    kind: TypeKind;
    size_bytes: usize;
}</code></pre>
<p>Base <code>TypeInfo</code> structure returned by <code>typeinfo</code> operator. This structure pointer can be casted to child type to get more descriptive information about the type.</p>
<h3 id="members">Members</h3>
<p><strong>kind</strong> - Type info kind.</p>
<p><strong>size_bytes</strong> - Size of type in bytes.</p>
<hr />
<h2 id="typeinfoint">TypeInfoInt</h2>
<pre><code>TypeInfoInt :: struct {
    bit_count: s32;
    is_signed: bool;
}</code></pre>
<p>Detailed information about integer types: <code>s8</code>, <code>s16</code>, <code>s32</code>, <code>s64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>.</p>
<h3 id="members-1">Members</h3>
<p><strong>bit_count</strong> - Size of type in bits.</p>
<p><strong>is_signed</strong> - True when type is signed integer type.</p>
<hr />
<h2 id="typeinforeal">TypeInfoReal</h2>
<pre><code>TypeInfoReal :: struct {
    bit_count: s32;
}</code></pre>
<p>Detailed information about real types: <code>f32</code>, <code>f64</code>.</p>
<h3 id="members-2">Members</h3>
<p><strong>bit_count</strong> - Size of type in bits.</p>
<hr />
<h2 id="typeinfofn">TypeInfoFn</h2>
<pre><code>TypeInfoFn :: struct {
    args: []TypeInfoFnArg;
    ret_type: *TypeInfo;
    is_vargs: bool;
}</code></pre>
<p>Detailed information about function types.</p>
<h3 id="members-3">Members</h3>
<p><strong>args</strong> - Slice of argument type infos.</p>
<p><strong>ret_type</strong> - Return type info.</p>
<p><strong>is_vargs</strong> - True when function has variable argument list.</p>
<hr />
<h2 id="typeinfofngroup">TypeInfoFnGroup</h2>
<pre><code>TypeInfoFnGroup :: struct {
    variants: []*TypeInfoFn;
}</code></pre>
<p>Detailed information about function group and contained possible overloads.</p>
<h3 id="members-4">Members</h3>
<p><strong>variants</strong> - Group content.</p>
<hr />
<h2 id="typeinfoptr">TypeInfoPtr</h2>
<pre><code>TypeInfoPtr :: struct {
    pointee_type: *TypeInfo;
}</code></pre>
<p>Detailed information about pointer types.</p>
<h3 id="members-5">Members</h3>
<p><strong>pointee_type</strong> - Underlaying pointed type info.</p>
<hr />
<h2 id="typeinfoarray">TypeInfoArray</h2>
<pre><code>TypeInfoArray :: struct {
    name: string;
    elem_type: *TypeInfo;
    len: s64;
}</code></pre>
<p>Detailed information about array types.</p>
<h3 id="members-6">Members</h3>
<p><strong>name</strong> - Array name.</p>
<p><strong>elem_type</strong> - Array element type info.</p>
<p><strong>len</strong> - Array element count.</p>
<hr />
<h2 id="typeinfostruct">TypeInfoStruct</h2>
<pre><code>TypeInfoStruct :: struct {
    name: string;
    members: []TypeInfoStructMember;
    is_slice: bool;
    is_union: bool;
    is_dynamic_array: bool;
}</code></pre>
<p>Detailed information about structure types.</p>
<h3 id="members-7">Members</h3>
<p><strong>name</strong> - Structure type name.</p>
<p><strong>members</strong> - Slice of structure member infos.</p>
<p><strong>is_slice</strong> - True when structure is slice.</p>
<p><strong>is_union</strong> - True when structure is union.</p>
<p><strong>is_dynamic_array</strong> - True when structure is dynamic array.</p>
<hr />
<h2 id="typeinfoenum">TypeInfoEnum</h2>
<pre><code>TypeInfoEnum :: struct {
    name: string;
    base_type: *TypeInfo;
    variants: []TypeInfoEnumVariant;
    is_flags: bool;
}</code></pre>
<p>Detailed information about enumerator types.</p>
<h3 id="members-8">Members</h3>
<p><strong>name</strong> - Enumerator type name.</p>
<p><strong>base_type</strong> - Base type info.</p>
<p><strong>variants</strong> - Slice of all enumerator variants.</p>
<p><strong>is_flags</strong> - True when enumerator was defined with #flags directive.</p>
<hr />
<h2 id="typeinfovoid">TypeInfoVoid</h2>
<pre><code>TypeInfoVoid :: struct {
}</code></pre>
<p>Placeholder for information about <code>void</code> type.</p>
<hr />
<h2 id="typeinfonull">TypeInfoNull</h2>
<pre><code>TypeInfoNull :: struct {
}</code></pre>
<p>Placeholder for information about <code>null</code> type.</p>
<hr />
<h2 id="typeinfostring">TypeInfoString</h2>
<pre><code>TypeInfoString :: struct {
}</code></pre>
<p>Placeholder for information about <code>string</code> type.</p>
<hr />
<h2 id="typeinfotype">TypeInfoType</h2>
<pre><code>TypeInfoType :: struct {
}</code></pre>
<p>Placeholder for information about <code>type</code> type.</p>
<hr />
<h2 id="typeinfobool">TypeInfoBool</h2>
<pre><code>TypeInfoBool :: struct {
}</code></pre>
<p>Placeholder for information about <code>bool</code> type.</p>
<hr />
<h2 id="typeinfostructmember">TypeInfoStructMember</h2>
<pre><code>TypeInfoStructMember :: struct {
    name: string;
    base_type: *TypeInfo;
    offset_bytes: s32;
    index: s32;
    tags: s32;
    is_base: bool;
}</code></pre>
<p>Detailed information about structure member.</p>
<h3 id="members-9">Members</h3>
<p><strong>name</strong> - Member type name.</p>
<p><strong>base_type</strong> - Member type info.</p>
<p><strong>offset_bytes</strong> - Byte-offset of member inside structure ABI.</p>
<p><strong>index</strong> - Order in structure.</p>
<p><strong>tags</strong> - User tags contains merge of all tag values assigned to member in structure declaration. Basically tags behave like a flags value, merge is done by binary <code>or</code> of all defined tag values. User tags can be defined by <code>#tags</code> hash directive written after member type in following way:</p>
<pre><code>Foo :: struct {
    i: s32 #tags TAG1;
    j: s32 #tags TAG1, TAG2;
};</code></pre>
<p>Where tags must be <code>compile-time</code> constant of <code>s32</code> type.</p>
<pre class="text"><code>TAG1 :: 0x1;
TAG2 :: 0x2;</code></pre>
<p><strong>is_base</strong> - True when member is inherrited base of the parent structure type.</p>
<hr />
<h2 id="typeinfoenumvariant">TypeInfoEnumVariant</h2>
<pre><code>TypeInfoEnumVariant :: struct {
    name: string;
    value: s64;
}</code></pre>
<p>Detailed information about enumerator variant.</p>
<h3 id="members-10">Members</h3>
<p><strong>name</strong> - Member type name.</p>
<p><strong>value</strong> - Variant value.</p>
<hr />
<h2 id="typeinfofnarg">TypeInfoFnArg</h2>
<pre><code>TypeInfoFnArg :: struct {
    name: string;
    base_type: *TypeInfo;
}</code></pre>
<p>Detailed information about function’s argument.</p>
<h3 id="members-11">Members</h3>
<p><strong>name</strong> - Member type name.</p>
<p><strong>base_type</strong> - Argument type info.</p>
<hr />
<h2 id="any">Any</h2>
<pre><code>Any :: struct {
    type_info: *TypeInfo;
    data: *u8;
}</code></pre>
<p>Any type is special builtin type used for passing value of “any” type as function argument.</p>
<h3 id="members-12">Members</h3>
<p><strong>type_info</strong> - Type info associated to data type.</p>
<p><strong>data</strong> - Data pointer. (not owner!)</p>
<hr />
<h2 id="testcase">TestCase</h2>
<pre><code>TestCase :: struct {
    func: *fn () ;
    name: string;
}</code></pre>
<p>Type of test case record found during compilation.</p>
<h3 id="members-13">Members</h3>
<p><strong>func</strong> - Pointer to test case function.</p>
<p><strong>name</strong> - Name of the test case.</p>
<hr />
<h2 id="codelocation">CodeLocation</h2>
<pre><code>CodeLocation :: struct {
    file: string;
    line: s32;
    hash: u32;
}</code></pre>
<p>Type of source code location used by <code>#call_location</code> directive.</p>
<h3 id="example">Example</h3>
<pre><code>foo :: fn (loc: *CodeLocation = #call_location) {
    print(&quot;%\n&quot;, @loc);
}

main :: fn () s32 {
    foo();
    return 0;
}</code></pre>
<h3 id="members-14">Members</h3>
<p><strong>file</strong> - Full path of the source file.</p>
<p><strong>line</strong> - Line in source file.</p>
<p><strong>hash</strong> - File and line string combination hash.</p>
<hr />
<h2 id="printlogfn">PrintLogFn</h2>
<pre><code>PrintLogFn :: *fn (kind: PrintLogKind, file: string, line: s32, format: string, args: ...) </code></pre>
<p>Type of print log function.</p>
<h3 id="arguments">Arguments</h3>
<ul>
<li><code>kind</code> Kind of report message.</li>
<li><code>format</code> Format string.</li>
<li><code>args</code> Additional arguments.</li>
<li><code>file</code> Call side filename.</li>
<li><code>line</code> Call side line in source file.</li>
</ul>
<hr />
<h2 id="abortfn">AbortFn</h2>
<pre><code>AbortFn :: *fn () </code></pre>
<hr />
<h2 id="context">Context</h2>
<pre><code>Context :: struct {
    print_log_fn: PrintLogFn;
    abort_fn: AbortFn;
    allocator: *Allocator;
}</code></pre>
<p>Default implicit context type. Implicit context is compiler internal global variable containing basic context for whole assembly. This variable is mutable and can be modified by user code.</p>
<h3 id="members-15">Members</h3>
<p><strong>print_log_fn</strong> - Pointer to log print function.</p>
<p><strong>abort_fn</strong> - Pointer to abort handler function.</p>
<p><strong>allocator</strong> - Default memory allocator used across the binary.</p>
<hr />
<h2 id="context-1">_context</h2>
<pre><code>_context := </code></pre>
<p>Default implicit context. Implicit context is compiler internal global variable containing basic context for whole assembly. This variable is mutable and can be modified by user code. For example we can replace default memory allocator with custom one, this will affect all allocations made later.</p>
<hr />
<h2 id="command_line_arguments">command_line_arguments</h2>
<pre><code>command_line_arguments : []string = </code></pre>
<p>Contains all arguments passed from command line. First argument is executable name.</p>
<hr />
<h1 id="build-system">Build system</h1>
<p><code>#load "build/build.bl"</code></p>
<p>Compiler integrated build pipeline. Build pipline can be used to manage whole project compilation process directly in BL. All you need is to create the build file called <code>build.bl</code> and specify the <code>build_entry</code> function inside. When <code>-b</code> flag is used without need of specifying any files, the compiler will lookup <code>build.bl</code> file in the current directory and execute it in compile time. All compilation steps, target input and output can be specified here. Example: :ref:<code>Build_System_Example</code>.</p>
<p>Example of minimal build.bl:</p>
<pre><code>build :: fn () #build_entry {
    // create new executable target
    exe :: add_executable(&quot;MyProgram&quot;);

    // add &#39;main.bl&#39; file into the target &#39;exe&#39;
    add_unit(exe, &quot;main.bl&quot;);

    // Start compilation
    compile(exe);
}</code></pre>
<p>Start build pipeline using our build.bl file:</p>
<pre><code>$ blc --build</code></pre>
<p>Compiler will automatically use build.bl file as build script and execute build function in compile time. SDK file build/build.bl containing compiler API for build pipeline manipulation is loaded implicitly.</p>
<p><strong>warning</strong>: Build API is available only in compile-time.</p>
<h2 id="basics">Basics</h2>
<h3 id="create-new-executable-target">Create new executable target</h3>
<p>Target is a single build target defined as consisting of build Units representing source files needed for compilation. It`s basically a target compiled into an executable or binary file. Use <a href="#add_executable">add_executable</a> function to specify your target. There are several options related to target, described later in this documentation.</p>
<pre><code>exe :: add_executable(&quot;MyProgram&quot;);</code></pre>
<h3 id="add-file-into-target">Add file into target</h3>
<p>Use <a href="#add_unit">add_unit</a> function to add source files into the target. There is no need to add all files you want to use, general <code>load</code> and <code>import</code> will do so automatically. Only <code>main</code> or entry files must be included.</p>
<pre><code>add_unit(exe, &quot;main.bl&quot;);</code></pre>
<h3 id="specify-output-directory">Specify output directory</h3>
<p>Output directory is a directory where all compiler-produced files will be written (i.e. native executables). Use <a href="#set_output_dir">set_output_dir</a> function to specify this directory, current directory is used by default.</p>
<pre><code>set_output_dir(exe, &quot;bin&quot;);</code></pre>
<h3 id="compile-target">Compile target</h3>
<pre><code>compile(exe);</code></pre>
<h3 id="command-line-argumets">Command line argumets</h3>
<p>All argumets passed after <code>-build</code> compiler flag are automatically forwarded into <code>command_line_arguments</code> global variable. ## Target</p>
<pre><code>Target :: struct {
    kind: TargetKind;
    build_mode: BuildMode;
    debug_info_kind: DebugInfo;
    register_split: bool;
    verify_llvm: bool;
    run_tests: bool;
    no_api: bool;
    copy_dependencies: bool;
    run: bool;
    print_tokens: bool;
    print_ast: bool;
    emit_llvm: bool;
    emit_asm: bool;
    emit_mir: bool;
    no_bin: bool;
    no_llvm: bool;
    no_analyze: bool;
    assert_mode: AssertMode;
    syntax_only: bool;
    vmdbg_enabled: bool;
    vmdbg_break_on: s32;
}</code></pre>
<p>Target is representation of whole program workspace, it’s a consist of Units, every unit represents one source file.</p>
<h3 id="members-16">Members</h3>
<p><strong>kind</strong> - See :ref:<code>TargetKind</code>.</p>
<p><strong>build_mode</strong> - Specify build mode of the target. See <a href="#buildmode">BuildMode</a></p>
<p><strong>debug_info_kind</strong> - Specify debug information format used for target in debug mode. See <a href="#debuginfo">DebugInfo</a>.</p>
<p><strong>register_split</strong> - Enable split of function arguments and return value into registers.</p>
<p><strong>verify_llvm</strong> - Verify LLVM module.</p>
<p><strong>run_tests</strong> - Execute compile time tests.</p>
<p><strong>no_api</strong> - Disable default API import.</p>
<p><strong>copy_dependencies</strong> - Copy all known dependencies into output folder.</p>
<p><strong>run</strong> - Execute main function in compile time.</p>
<p><strong>print_tokens</strong> - Print out lexer output.</p>
<p><strong>print_ast</strong> - Print out AST.</p>
<p><strong>emit_llvm</strong> - Emit LLVM IR code into file.</p>
<p><strong>emit_asm</strong> - Emit asm code into file.</p>
<p><strong>emit_mir</strong> - Emit MIR code into file.</p>
<p><strong>no_bin</strong> - Disable generation of native binary.</p>
<p><strong>no_llvm</strong> - Disable LLVM backend.</p>
<p><strong>no_analyze</strong> - Disable analyze pass of code generation.</p>
<p><strong>assert_mode</strong> - See :ref:<code>AssertMode</code>.</p>
<p><strong>syntax_only</strong> - Check only code syntax.</p>
<p><strong>vmdbg_enabled</strong> - Enable virtual machine debugger.</p>
<p><strong>vmdbg_break_on</strong> - Specify MIR instruction ID to break on if virtual machine debugger is attached.</p>
<hr />
<h2 id="targetkind">TargetKind</h2>
<pre><code>TargetKind :: enum {
    Executable :: 0;
    SharedLibrary :: 1;
}</code></pre>
<p>Specification of compiler output binary kind.</p>
<hr />
<h2 id="buildmode">BuildMode</h2>
<pre><code>BuildMode :: enum s32 {
    Debug :: 0;
    ReleaseFast :: 1;
    ReleaseSmall :: 2;
}</code></pre>
<p>Specify target build mode. Every <a href="#target">Target</a> can be compiled with various configuration options. The <code>BuildMode</code> can specify which set of options compiler should use.</p>
<h3 id="variants-1">Variants</h3>
<p><strong>Debug</strong> - Generates debug symbols and produce binary without any optimizations.</p>
<p><strong>ReleaseFast</strong> - Fast release mode; no debug symbols are produced, all possible optimizations are applied to produce binary as fast as possible. The <code>assert</code> is disabled unless <code>Target.assert_mode</code> is <code>AlwaysEnabled</code>.</p>
<p><strong>ReleaseSmall</strong> - Small release mode; no debug symbols are produced, optimizations are applied to produce binary reasonably fast and as small as possible. The <code>assert</code> is disabled unless <code>Target.assert_mode</code> is <code>AlwaysEnabled</code>.</p>
<hr />
<h2 id="debuginfo">DebugInfo</h2>
<pre><code>DebugInfo :: enum s32 {
    Dwarf :: 0;
    Codeview :: 1;
}</code></pre>
<p>Debug information format.</p>
<hr />
<h2 id="assertmode">AssertMode</h2>
<pre><code>AssertMode :: enum s32 {
    Default :: 0;
    AlwaysEnabled :: 1;
    AlwaysDisabled :: 2;
}</code></pre>
<p>Specification of <code>assert</code> mode used for <code>Target</code>.</p>
<h3 id="variants-2">Variants</h3>
<p><strong>Default</strong> - By default compiler emits all assertions in <a href="#buildmode">BuildMode</a>. Debug and skips all assertions in all optimized release modes.</p>
<p><strong>AlwaysEnabled</strong> - Force-enable assertion in all build modes.</p>
<p><strong>AlwaysDisabled</strong> - Force-disable assertion in all build modes.</p>
<hr />
<h2 id="add_executable">add_executable</h2>
<pre><code>add_executable :: fn (name: string) *Target</code></pre>
<p>Add new executable target into the current compilation queue. Target with specified name is compiled into binary or it can be just executed in compile-time without any output created. Assemblies are compiled after <code>build_entry</code> function execution in order they are added.</p>
<h3 id="example-1">Example</h3>
<pre><code>build :: fn () #build_entry {
    exe :: add_executable(&quot;MyProgram&quot;);
    add_unit(exe, &quot;src/main.bl&quot;);

    mode :: get_build_mode(exe);
    switch mode {
        BuildMode.Debug {
            set_output_dir(exe, &quot;build/debug&quot;);
        }

        BuildMode.ReleaseSmall,
        BuildMode.ReleaseFast {
            set_output_dir(exe, &quot;build/release&quot;);
        }
    }
    compile(exe);
}</code></pre>
<hr />
<h2 id="add_library">add_library</h2>
<pre><code>add_library :: fn (name: string) *Target</code></pre>
<p>Add new shared library target target into the current compilation queue.</p>
<hr />
<h2 id="add_unit">add_unit</h2>
<pre><code>add_unit :: fn (target: *Target, filepath: string) </code></pre>
<p>Add new source file into the <code>target</code>. Function does nothing when <code>filepath</code> is already present in the <code>target</code> assembly.</p>
<hr />
<h2 id="compile">compile</h2>
<pre><code>compile :: fn (target: *Target) Error</code></pre>
<p>Start compilation of the <code>target</code> assembly and return <code>ok</code> or <code>error</code> in case compilation failed.</p>
<hr />
<h2 id="compile_all">compile_all</h2>
<pre><code>compile_all :: fn () Error</code></pre>
<p>Compile all created targets one by one in order they were created. See also <a href="#compile">compile</a>.</p>
<hr />
<h2 id="add_lib_path">add_lib_path</h2>
<pre><code>add_lib_path :: fn (target: *Target, path: string) </code></pre>
<p>Add path for linker library lookup.</p>
<hr />
<h2 id="link_library">link_library</h2>
<pre><code>link_library :: fn (target: *Target, name: string) </code></pre>
<p>Add system library. Only name is required (without extension and prefix). Compiler will lookup for this library in working directory, system <code>PATH</code> and <code>LINKER_LIB_PATH</code> variable specified in <code>bl.conf</code> file. Linked library can be used also during compile-time execution, in such case all needed symbols are loaded in compile-time.</p>
<p>In general there is no need to link libraries manually, all needed dependencies should be handled by module import mechanism, however there is still an option do it manually.</p>
<p>Library name platform specific rules:</p>
<ul>
<li>On Linux name will be extended by ‘lib’ prefix and ‘.so’ extension.</li>
<li>On MacOS name will be extended by ‘lib’ prefix and ‘.dylib’ extension.</li>
<li>On Windows name will be extended only by ‘.dll’ extension.</li>
</ul>
<h3 id="example-2">Example</h3>
<pre><code>build :: fn () #build_entry {
    exe :: add_executable(&quot;MyGame&quot;);
    add_unit(exe, &quot;src/main.bl&quot;);

    switch PLATFORM {
        Platform.windows { target_windows(exe); }
        default          { panic(&quot;Unknown build target!&quot;); }
    }
    compile(exe);
}

target_windows :: fn (exe: *Target) {
    link_library(exe, &quot;freetype&quot;);
    link_library(exe, &quot;zlib&quot;);
    link_library(exe, &quot;png&quot;);
}</code></pre>
<hr />
<h2 id="append_linker_options">append_linker_options</h2>
<pre><code>append_linker_options :: fn (target: *Target, option: string) </code></pre>
<p>Appends raw string data directly to linker command. Passed option is added without any processing and compatibility validation.</p>
<hr />
<h2 id="set_output_dir">set_output_dir</h2>
<pre><code>set_output_dir :: fn (target: *Target, dir: string) </code></pre>
<p>Set build output directory. This is directory where all output files will be written. For example different output directory can be set for any build mode.</p>
<p>Directory path <code>dir</code>. This can contain non-existing directories separated by <code>/</code>, compiler will create all missing directories in passed path.</p>
<p>Specified directory will be used also for build temporary files.</p>
<hr />
<h2 id="get_output_dir">get_output_dir</h2>
<pre><code>get_output_dir :: fn (target: *Target) string</code></pre>
<p>Get output directory specified by <a href="#set_output_dir">set_output_dir</a> or empty string.</p>
<hr />
<h2 id="moduleimportpolicy">ModuleImportPolicy</h2>
<pre><code>ModuleImportPolicy :: enum s32 {
    System :: 0;
    Bundle :: 1;
    BundleLatest :: 2;
}</code></pre>
<p>Specify import module policy in <a href="#set_module_dir">set_module_dir</a> function call. Module dependencies of any target can be treated in different ways depending on use case and needs of programmer. Sometimes program stability and maintainability is more important than use of latest versions of modules. These flags can specify how local modules should be updated.</p>
<h3 id="variants-3">Variants</h3>
<p><strong>System</strong> - Use system modules but prefer local ones in module directory. This option disables any copying and version check. Local module directory can contain custom project related modules you don’t want to expose to the whole system.</p>
<p><strong>Bundle</strong> - Bundle only missing modules from system into the local module folder and ignore if there is newer version available. Individual module updates can be done by renaming old one and re-run compilation. Custom modules (not coming from main API folder are kept untouched.)</p>
<p><strong>BundleLatest</strong> - Bundle all missing modules from system into the local module folder and update old ones also. Custom modules (not coming from main API folder are kept untouched.) Compiler will create <code>.bak</code> backup directory for every module before any updates.</p>
<hr />
<h2 id="set_module_dir">set_module_dir</h2>
<pre><code>set_module_dir :: fn (target: *Target, dir: string, policy :: ) </code></pre>
<p>Sets module directory <code>dir</code> for <code>target</code>. All imported modules will be copied into this directory according to chosen <a href="#moduleimportpolicy">ModuleImportPolicy</a>. Module policy is set to <code>System</code> by default even if this function has not been called.</p>
<hr />
<h2 id="get_module_dir">get_module_dir</h2>
<pre><code>get_module_dir :: fn (target: *Target) string</code></pre>
<p>Get module directory specified by <a href="#set_module_dir">set_module_dir</a> or default one.</p>
<hr />
<h2 id="get_module_import_policy">get_module_import_policy</h2>
<pre><code>get_module_import_policy :: fn (target: *Target) ModuleImportPolicy</code></pre>
<p>Get module import policy specified by <a href="#set_module_dir">set_module_dir</a> or default one.</p>
<hr />
<h1 id="dirent.bl">dirent.bl</h1>
<h2 id="dir">_DIR</h2>
<pre><code>_DIR :: u8</code></pre>
<hr />
<h2 id="dirent_t">_dirent_t</h2>
<pre><code>_dirent_t :: struct {
    d_ino: c_ulong;
    d_off: c_long;
    d_reclen: c_ushort;
    d_type: c_uchar;
    d_name: ;
}</code></pre>
<hr />
<h2 id="dt_unknown">_DT_UNKNOWN</h2>
<pre><code>_DT_UNKNOWN :: 0</code></pre>
<hr />
<h2 id="dt_fifo">_DT_FIFO</h2>
<pre><code>_DT_FIFO :: 1</code></pre>
<hr />
<h2 id="dt_chr">_DT_CHR</h2>
<pre><code>_DT_CHR :: 2</code></pre>
<hr />
<h2 id="dt_dir">_DT_DIR</h2>
<pre><code>_DT_DIR :: 4</code></pre>
<hr />
<h2 id="dt_blk">_DT_BLK</h2>
<pre><code>_DT_BLK :: 6</code></pre>
<hr />
<h2 id="dt_reg">_DT_REG</h2>
<pre><code>_DT_REG :: 8</code></pre>
<hr />
<h2 id="dt_lnk">_DT_LNK</h2>
<pre><code>_DT_LNK :: 10</code></pre>
<hr />
<h2 id="dt_sock">_DT_SOCK</h2>
<pre><code>_DT_SOCK :: 12</code></pre>
<hr />
<h2 id="dt_wht">_DT_WHT</h2>
<pre><code>_DT_WHT :: 14</code></pre>
<hr />
<h2 id="opendir">_opendir</h2>
<pre><code>_opendir :: fn (name: *c_char) *_DIR #extern</code></pre>
<hr />
<h2 id="fdopendir">_fdopendir</h2>
<pre><code>_fdopendir :: fn (fd: c_int) *_DIR #extern</code></pre>
<hr />
<h2 id="closedir">_closedir</h2>
<pre><code>_closedir :: fn (dirp: *_DIR) c_int #extern</code></pre>
<hr />
<h2 id="readdir">_readdir</h2>
<pre><code>_readdir :: fn (dirp: *_DIR) *_dirent_t #extern</code></pre>
<hr />
<h2 id="rewinddir">_rewinddir</h2>
<pre><code>_rewinddir :: fn (dirp: *_DIR)  #extern</code></pre>
<hr />
<h1 id="errno.bl">errno.bl</h1>
<h2 id="errno">_errno</h2>
<pre><code>_errno :: fn () s32 #inline</code></pre>
<hr />
<h1 id="fcntl.bl">fcntl.bl</h1>
<h2 id="o_rdonly">_O_RDONLY</h2>
<pre><code>_O_RDONLY :: 0</code></pre>
<hr />
<h2 id="o_wronly">_O_WRONLY</h2>
<pre><code>_O_WRONLY :: 1</code></pre>
<hr />
<h2 id="o_rdwr">_O_RDWR</h2>
<pre><code>_O_RDWR :: 2</code></pre>
<hr />
<h2 id="o_creat">_O_CREAT</h2>
<pre><code>_O_CREAT :: 64</code></pre>
<hr />
<h2 id="o_excl">_O_EXCL</h2>
<pre><code>_O_EXCL :: 128</code></pre>
<hr />
<h2 id="o_append">_O_APPEND</h2>
<pre><code>_O_APPEND :: 1024</code></pre>
<hr />
<h2 id="o_trunc">_O_TRUNC</h2>
<pre><code>_O_TRUNC :: 512</code></pre>
<hr />
<h2 id="open">_open</h2>
<pre><code>_open :: fn (path: *c_char, oflag: c_int, mode: c_int) c_int #extern</code></pre>
<hr />
<h1 id="stat.bl">stat.bl</h1>
<h2 id="stat_ver">_STAT_VER</h2>
<pre><code>_STAT_VER :: 1</code></pre>
<hr />
<h2 id="s_irusr">_S_IRUSR</h2>
<pre><code>_S_IRUSR :: 256</code></pre>
<hr />
<h2 id="s_iwusr">_S_IWUSR</h2>
<pre><code>_S_IWUSR :: 128</code></pre>
<hr />
<h2 id="s_ixusr">_S_IXUSR</h2>
<pre><code>_S_IXUSR :: 64</code></pre>
<hr />
<h2 id="s_irwxu">_S_IRWXU</h2>
<pre><code>_S_IRWXU :: </code></pre>
<hr />
<h2 id="s_irgrp">_S_IRGRP</h2>
<pre><code>_S_IRGRP :: </code></pre>
<hr />
<h2 id="s_iwgrp">_S_IWGRP</h2>
<pre><code>_S_IWGRP :: </code></pre>
<hr />
<h2 id="s_ixgrp">_S_IXGRP</h2>
<pre><code>_S_IXGRP :: </code></pre>
<hr />
<h2 id="s_irwxg">_S_IRWXG</h2>
<pre><code>_S_IRWXG :: </code></pre>
<hr />
<h2 id="s_iroth">_S_IROTH</h2>
<pre><code>_S_IROTH :: </code></pre>
<hr />
<h2 id="s_iwoth">_S_IWOTH</h2>
<pre><code>_S_IWOTH :: </code></pre>
<hr />
<h2 id="s_ixoth">_S_IXOTH</h2>
<pre><code>_S_IXOTH :: </code></pre>
<hr />
<h2 id="s_irwxo">_S_IRWXO</h2>
<pre><code>_S_IRWXO :: </code></pre>
<hr />
<h2 id="s_ifmt">__S_IFMT</h2>
<pre><code>__S_IFMT : u32 : 61440</code></pre>
<hr />
<h2 id="s_ifdir">__S_IFDIR</h2>
<pre><code>__S_IFDIR : u32 : 16384</code></pre>
<hr />
<h2 id="s_ifchr">__S_IFCHR</h2>
<pre><code>__S_IFCHR : u32 : 8192</code></pre>
<hr />
<h2 id="s_ifblk">__S_IFBLK</h2>
<pre><code>__S_IFBLK : u32 : 24576</code></pre>
<hr />
<h2 id="s_ifreg">__S_IFREG</h2>
<pre><code>__S_IFREG : u32 : 32768</code></pre>
<hr />
<h2 id="s_ififo">__S_IFIFO</h2>
<pre><code>__S_IFIFO : u32 : 4096</code></pre>
<hr />
<h2 id="s_iflnk">__S_IFLNK</h2>
<pre><code>__S_IFLNK : u32 : 40960</code></pre>
<hr />
<h2 id="s_ifsock">__S_IFSOCK</h2>
<pre><code>__S_IFSOCK : u32 : 49152</code></pre>
<hr />
<h2 id="s_isdir">_S_ISDIR</h2>
<pre><code>_S_ISDIR :: fn (mode: u32) bool #inline</code></pre>
<hr />
<h2 id="s_isreg">_S_ISREG</h2>
<pre><code>_S_ISREG :: fn (mode: u32) bool #inline</code></pre>
<hr />
<h2 id="stat_t">_stat_t</h2>
<pre><code>_stat_t :: struct {
    st_dev: _dev_t;
    st_ino: _ino_t;
    st_nlink: _nlink_t;
    st_mode: _mode_t;
    st_uid: _uid_t;
    st_gid: _gid_t;
    _0: c_int;
    st_rdev: _dev_t;
    st_size: _off_t;
    st_blksize: _blksize_t;
    st_blocks: _blkcnt_t;
    st_atime: _time_t;
    st_atime_nsec: _syscall_ulong_t;
    st_mtime: _time_t;
    st_mtime_nsec: _syscall_ulong_t;
    st_ctime: _time_t;
    st_ctime_nsec: _syscall_ulong_t;
    _1: ;
}</code></pre>
<hr />
<h2 id="mkdir">_mkdir</h2>
<pre><code>_mkdir :: fn (path: *c_char, mode: c_int) c_int #extern</code></pre>
<hr />
<h2 id="stat">_stat</h2>
<pre><code>_stat :: fn (path: *c_char, buf: *_stat_t) c_int #inline</code></pre>
<hr />
<h2 id="fstat">_fstat</h2>
<pre><code>_fstat :: fn (fd: c_int, buf: *_stat_t) c_int #inline</code></pre>
<hr />
<h1 id="types.bl">types.bl</h1>
<h2 id="dev_t">_dev_t</h2>
<pre><code>_dev_t :: c_ulong</code></pre>
<hr />
<h2 id="ino_t">_ino_t</h2>
<pre><code>_ino_t :: c_ulong</code></pre>
<hr />
<h2 id="nlink_t">_nlink_t</h2>
<pre><code>_nlink_t :: c_ulong</code></pre>
<hr />
<h2 id="mode_t">_mode_t</h2>
<pre><code>_mode_t :: u32</code></pre>
<hr />
<h2 id="uid_t">_uid_t</h2>
<pre><code>_uid_t :: u32</code></pre>
<hr />
<h2 id="gid_t">_gid_t</h2>
<pre><code>_gid_t :: u32</code></pre>
<hr />
<h2 id="off_t">_off_t</h2>
<pre><code>_off_t :: c_long</code></pre>
<hr />
<h2 id="blksize_t">_blksize_t</h2>
<pre><code>_blksize_t :: c_long</code></pre>
<hr />
<h2 id="blkcnt_t">_blkcnt_t</h2>
<pre><code>_blkcnt_t :: c_long</code></pre>
<hr />
<h2 id="time_t">_time_t</h2>
<pre><code>_time_t :: c_long</code></pre>
<hr />
<h2 id="syscall_ulong_t">_syscall_ulong_t</h2>
<pre><code>_syscall_ulong_t :: c_ulong</code></pre>
<hr />
<h1 id="dirent.bl-1">dirent.bl</h1>
<h2 id="darwin_maxpathlen">_DARWIN_MAXPATHLEN</h2>
<pre><code>_DARWIN_MAXPATHLEN :: 1024</code></pre>
<hr />
<h2 id="dir-1">_DIR</h2>
<pre><code>_DIR :: u8</code></pre>
<hr />
<h2 id="dirent_t-1">_dirent_t</h2>
<pre><code>_dirent_t :: struct {
    d_ino: u64;
    d_seekoff: u64;
    d_reclen: u16;
    d_namlen: u16;
    d_type: u8;
    d_name: ;
}</code></pre>
<hr />
<h2 id="dt_unknown-1">_DT_UNKNOWN</h2>
<pre><code>_DT_UNKNOWN :: 0</code></pre>
<hr />
<h2 id="dt_fifo-1">_DT_FIFO</h2>
<pre><code>_DT_FIFO :: 1</code></pre>
<hr />
<h2 id="dt_chr-1">_DT_CHR</h2>
<pre><code>_DT_CHR :: 2</code></pre>
<hr />
<h2 id="dt_dir-1">_DT_DIR</h2>
<pre><code>_DT_DIR :: 4</code></pre>
<hr />
<h2 id="dt_blk-1">_DT_BLK</h2>
<pre><code>_DT_BLK :: 6</code></pre>
<hr />
<h2 id="dt_reg-1">_DT_REG</h2>
<pre><code>_DT_REG :: 8</code></pre>
<hr />
<h2 id="dt_lnk-1">_DT_LNK</h2>
<pre><code>_DT_LNK :: 10</code></pre>
<hr />
<h2 id="dt_sock-1">_DT_SOCK</h2>
<pre><code>_DT_SOCK :: 12</code></pre>
<hr />
<h2 id="dt_wht-1">_DT_WHT</h2>
<pre><code>_DT_WHT :: 14</code></pre>
<hr />
<h2 id="opendir-1">_opendir</h2>
<pre><code>_opendir :: fn (name: *c_char) *_DIR #extern</code></pre>
<hr />
<h2 id="fdopendir-1">_fdopendir</h2>
<pre><code>_fdopendir :: fn (fd: c_int) *_DIR #extern</code></pre>
<hr />
<h2 id="closedir-1">_closedir</h2>
<pre><code>_closedir :: fn (dirp: *_DIR) c_int #extern</code></pre>
<hr />
<h2 id="readdir-1">_readdir</h2>
<pre><code>_readdir :: fn (dirp: *_DIR) *_dirent_t #extern</code></pre>
<hr />
<h2 id="rewinddir-1">_rewinddir</h2>
<pre><code>_rewinddir :: fn (dirp: *_DIR)  #extern</code></pre>
<hr />
<h1 id="errno.bl-1">errno.bl</h1>
<h2 id="errno-1">_errno</h2>
<pre><code>_errno :: fn () s32 #inline</code></pre>
<hr />
<h1 id="fcntl.bl-1">fcntl.bl</h1>
<h2 id="o_rdonly-1">_O_RDONLY</h2>
<pre><code>_O_RDONLY :: 0</code></pre>
<hr />
<h2 id="o_wronly-1">_O_WRONLY</h2>
<pre><code>_O_WRONLY :: 1</code></pre>
<hr />
<h2 id="o_rdwr-1">_O_RDWR</h2>
<pre><code>_O_RDWR :: 2</code></pre>
<hr />
<h2 id="o_creat-1">_O_CREAT</h2>
<pre><code>_O_CREAT :: 512</code></pre>
<hr />
<h2 id="o_trunc-1">_O_TRUNC</h2>
<pre><code>_O_TRUNC :: 1024</code></pre>
<hr />
<h2 id="o_excl-1">_O_EXCL</h2>
<pre><code>_O_EXCL :: 2048</code></pre>
<hr />
<h2 id="o_append-1">_O_APPEND</h2>
<pre><code>_O_APPEND :: 8</code></pre>
<hr />
<h2 id="open-1">_open</h2>
<pre><code>_open :: fn (path: *c_char, oflag: c_int, mode: _mode_t) c_int #extern</code></pre>
<hr />
<h1 id="mach_time.bl">mach_time.bl</h1>
<h2 id="machtimebaseinfo">_MachTimebaseInfo</h2>
<pre><code>_MachTimebaseInfo :: struct {
    numer: c_uint;
    denom: c_uint;
}</code></pre>
<hr />
<h2 id="mach_timebase_info">_mach_timebase_info</h2>
<pre><code>_mach_timebase_info :: fn (info: *_MachTimebaseInfo) c_int #extern</code></pre>
<hr />
<h2 id="mach_absolute_time">_mach_absolute_time</h2>
<pre><code>_mach_absolute_time :: fn () u64 #extern</code></pre>
<hr />
<h1 id="macosapi.bl">macosapi.bl</h1>
<h2 id="cfallocatorref">_CFAllocatorRef</h2>
<pre><code>_CFAllocatorRef :: *u8</code></pre>
<hr />
<h2 id="cfindex">_CFIndex</h2>
<pre><code>_CFIndex :: s64</code></pre>
<hr />
<h2 id="cfstringref">_CFStringRef</h2>
<pre><code>_CFStringRef :: *u8</code></pre>
<hr />
<h2 id="cfarrayref">_CFArrayRef</h2>
<pre><code>_CFArrayRef :: *u8</code></pre>
<hr />
<h2 id="cfarraycallbacks">_CFArrayCallBacks</h2>
<pre><code>_CFArrayCallBacks :: u8</code></pre>
<hr />
<h2 id="cftimeinterval">_CFTimeInterval</h2>
<pre><code>_CFTimeInterval :: f64</code></pre>
<hr />
<h2 id="cftyperef">_CFTypeRef</h2>
<pre><code>_CFTypeRef :: *u8</code></pre>
<hr />
<h2 id="cfrunloopref">_CFRunLoopRef</h2>
<pre><code>_CFRunLoopRef :: *u8</code></pre>
<hr />
<h2 id="cfrunloopmode">_CFRunLoopMode</h2>
<pre><code>_CFRunLoopMode :: _CFStringRef</code></pre>
<hr />
<h2 id="boolean">_Boolean</h2>
<pre><code>_Boolean :: u8</code></pre>
<hr />
<h2 id="cfstringencoding">_CFStringEncoding</h2>
<pre><code>_CFStringEncoding :: enum u32 {
    MacRoman :: 0;
    WindowsLatin1 :: 1280;
    ISOLatin1 :: 513;
    NextStepLatin :: 2817;
    ASCII :: 1536;
    Unicode :: 256;
    UTF8 :: 134217984;
    NonLossyASCII :: 3071;
    UTF16 :: 256;
    UTF16BE :: 268435712;
    UTF16LE :: 335544576;
    UTF32 :: 201326848;
    UTF32BE :: 402653440;
    UTF32LE :: 469762304;
}</code></pre>
<hr />
<h2 id="kfseventstreameventflagnone">_kFSEventStreamEventFlagNone</h2>
<pre><code>_kFSEventStreamEventFlagNone : u32 : 0</code></pre>
<hr />
<h2 id="kfseventstreameventflagmustscansubdirs">_kFSEventStreamEventFlagMustScanSubDirs</h2>
<pre><code>_kFSEventStreamEventFlagMustScanSubDirs : u32 : 1</code></pre>
<hr />
<h2 id="kfseventstreameventflaguserdropped">_kFSEventStreamEventFlagUserDropped</h2>
<pre><code>_kFSEventStreamEventFlagUserDropped : u32 : 2</code></pre>
<hr />
<h2 id="kfseventstreameventflagkerneldropped">_kFSEventStreamEventFlagKernelDropped</h2>
<pre><code>_kFSEventStreamEventFlagKernelDropped : u32 : 4</code></pre>
<hr />
<h2 id="kfseventstreameventflageventidswrapped">_kFSEventStreamEventFlagEventIdsWrapped</h2>
<pre><code>_kFSEventStreamEventFlagEventIdsWrapped : u32 : 8</code></pre>
<hr />
<h2 id="kfseventstreameventflaghistorydone">_kFSEventStreamEventFlagHistoryDone</h2>
<pre><code>_kFSEventStreamEventFlagHistoryDone : u32 : 16</code></pre>
<hr />
<h2 id="kfseventstreameventflagrootchanged">_kFSEventStreamEventFlagRootChanged</h2>
<pre><code>_kFSEventStreamEventFlagRootChanged : u32 : 32</code></pre>
<hr />
<h2 id="kfseventstreameventflagmount">_kFSEventStreamEventFlagMount</h2>
<pre><code>_kFSEventStreamEventFlagMount : u32 : 64</code></pre>
<hr />
<h2 id="kfseventstreameventflagunmount">_kFSEventStreamEventFlagUnmount</h2>
<pre><code>_kFSEventStreamEventFlagUnmount : u32 : 128</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemcreated">_kFSEventStreamEventFlagItemCreated</h2>
<pre><code>_kFSEventStreamEventFlagItemCreated : u32 : 256</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemremoved">_kFSEventStreamEventFlagItemRemoved</h2>
<pre><code>_kFSEventStreamEventFlagItemRemoved : u32 : 512</code></pre>
<hr />
<h2 id="kfseventstreameventflagiteminodemetamod">_kFSEventStreamEventFlagItemInodeMetaMod</h2>
<pre><code>_kFSEventStreamEventFlagItemInodeMetaMod : u32 : 1024</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemrenamed">_kFSEventStreamEventFlagItemRenamed</h2>
<pre><code>_kFSEventStreamEventFlagItemRenamed : u32 : 2048</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemmodified">_kFSEventStreamEventFlagItemModified</h2>
<pre><code>_kFSEventStreamEventFlagItemModified : u32 : 4096</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemfinderinfomod">_kFSEventStreamEventFlagItemFinderInfoMod</h2>
<pre><code>_kFSEventStreamEventFlagItemFinderInfoMod : u32 : 8192</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemchangeowner">_kFSEventStreamEventFlagItemChangeOwner</h2>
<pre><code>_kFSEventStreamEventFlagItemChangeOwner : u32 : 16384</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemxattrmod">_kFSEventStreamEventFlagItemXattrMod</h2>
<pre><code>_kFSEventStreamEventFlagItemXattrMod : u32 : 32768</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemisfile">_kFSEventStreamEventFlagItemIsFile</h2>
<pre><code>_kFSEventStreamEventFlagItemIsFile : u32 : 65536</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemisdir">_kFSEventStreamEventFlagItemIsDir</h2>
<pre><code>_kFSEventStreamEventFlagItemIsDir : u32 : 131072</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemissymlink">_kFSEventStreamEventFlagItemIsSymlink</h2>
<pre><code>_kFSEventStreamEventFlagItemIsSymlink : u32 : 262144</code></pre>
<hr />
<h2 id="kfseventstreameventflagownevent">_kFSEventStreamEventFlagOwnEvent</h2>
<pre><code>_kFSEventStreamEventFlagOwnEvent : u32 : 524288</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemishardlink">_kFSEventStreamEventFlagItemIsHardlink</h2>
<pre><code>_kFSEventStreamEventFlagItemIsHardlink : u32 : 1048576</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemislasthardlink">_kFSEventStreamEventFlagItemIsLastHardlink</h2>
<pre><code>_kFSEventStreamEventFlagItemIsLastHardlink : u32 : 2097152</code></pre>
<hr />
<h2 id="kfseventstreameventflagitemcloned">_kFSEventStreamEventFlagItemCloned</h2>
<pre><code>_kFSEventStreamEventFlagItemCloned : u32 : 4194304</code></pre>
<hr />
<h2 id="kfseventstreameventidsincenow">_kFSEventStreamEventIdSinceNow</h2>
<pre><code>_kFSEventStreamEventIdSinceNow : _FSEventStreamEventId : 18446744073709551615</code></pre>
<hr />
<h2 id="kfseventstreamcreateflagnone">_kFSEventStreamCreateFlagNone</h2>
<pre><code>_kFSEventStreamCreateFlagNone : _FSEventStreamCreateFlags : 0</code></pre>
<hr />
<h2 id="kfseventstreamcreateflagusecftypes">_kFSEventStreamCreateFlagUseCFTypes</h2>
<pre><code>_kFSEventStreamCreateFlagUseCFTypes : _FSEventStreamCreateFlags : 1</code></pre>
<hr />
<h2 id="kfseventstreamcreateflagnodefer">_kFSEventStreamCreateFlagNoDefer</h2>
<pre><code>_kFSEventStreamCreateFlagNoDefer : _FSEventStreamCreateFlags : 2</code></pre>
<hr />
<h2 id="kfseventstreamcreateflagwatchroot">_kFSEventStreamCreateFlagWatchRoot</h2>
<pre><code>_kFSEventStreamCreateFlagWatchRoot : _FSEventStreamCreateFlags : 4</code></pre>
<hr />
<h2 id="kfseventstreamcreateflagignoreself">_kFSEventStreamCreateFlagIgnoreSelf</h2>
<pre><code>_kFSEventStreamCreateFlagIgnoreSelf : _FSEventStreamCreateFlags : 8</code></pre>
<hr />
<h2 id="kfseventstreamcreateflagfileevents">_kFSEventStreamCreateFlagFileEvents</h2>
<pre><code>_kFSEventStreamCreateFlagFileEvents : _FSEventStreamCreateFlags : 16</code></pre>
<hr />
<h2 id="kfseventstreamcreateflagmarkself">_kFSEventStreamCreateFlagMarkSelf</h2>
<pre><code>_kFSEventStreamCreateFlagMarkSelf : _FSEventStreamCreateFlags : 32</code></pre>
<hr />
<h2 id="kfseventstreamcreateflaguseextendeddata">_kFSEventStreamCreateFlagUseExtendedData</h2>
<pre><code>_kFSEventStreamCreateFlagUseExtendedData : _FSEventStreamCreateFlags : 64</code></pre>
<hr />
<h2 id="fseventstreamref">_FSEventStreamRef</h2>
<pre><code>_FSEventStreamRef :: *u8</code></pre>
<hr />
<h2 id="fseventstreameventid">_FSEventStreamEventId</h2>
<pre><code>_FSEventStreamEventId :: u64</code></pre>
<hr />
<h2 id="fseventstreamcreateflags">_FSEventStreamCreateFlags</h2>
<pre><code>_FSEventStreamCreateFlags :: u32</code></pre>
<hr />
<h2 id="fseventstreameventflags">_FSEventStreamEventFlags</h2>
<pre><code>_FSEventStreamEventFlags :: u32</code></pre>
<hr />
<h2 id="constfseventstreamref">_ConstFSEventStreamRef</h2>
<pre><code>_ConstFSEventStreamRef :: *u8</code></pre>
<hr />
<h2 id="cfallocatorretaincallback">_CFAllocatorRetainCallBack</h2>
<pre><code>_CFAllocatorRetainCallBack :: *fn (info: *u8) *u8</code></pre>
<hr />
<h2 id="cfallocatorreleasecallback">_CFAllocatorReleaseCallBack</h2>
<pre><code>_CFAllocatorReleaseCallBack :: *fn (info: *u8) </code></pre>
<hr />
<h2 id="cfallocatorcopydescriptioncallback">_CFAllocatorCopyDescriptionCallBack</h2>
<pre><code>_CFAllocatorCopyDescriptionCallBack :: *fn (info: *u8) _CFStringRef</code></pre>
<hr />
<h2 id="cfarraycreate">_CFArrayCreate</h2>
<pre><code>_CFArrayCreate :: fn (allocator: _CFAllocatorRef, values: **u8, numValues: _CFIndex, callBacks: *_CFArrayCallBacks) _CFArrayRef #extern</code></pre>
<hr />
<h2 id="cfrunloopgetcurrent">_CFRunLoopGetCurrent</h2>
<pre><code>_CFRunLoopGetCurrent :: fn () _CFRunLoopRef #extern</code></pre>
<hr />
<h2 id="cfrunloopcopycurrentmode">_CFRunLoopCopyCurrentMode</h2>
<pre><code>_CFRunLoopCopyCurrentMode :: fn (rl: _CFRunLoopRef) _CFRunLoopMode #extern</code></pre>
<hr />
<h2 id="cfrelease">_CFRelease</h2>
<pre><code>_CFRelease :: fn (cf: _CFTypeRef)  #extern</code></pre>
<hr />
<h2 id="cfstringcreatewithcstring">_CFStringCreateWithCString</h2>
<pre><code>_CFStringCreateWithCString :: fn (alloc: _CFAllocatorRef, cStr: *u8, encoding: _CFStringEncoding) _CFStringRef #extern</code></pre>
<hr />
<h2 id="fseventstreamcontext">_FSEventStreamContext</h2>
<pre><code>_FSEventStreamContext :: struct {
    version: _CFIndex;
    info: *u8;
    retain: _CFAllocatorRetainCallBack;
    release: _CFAllocatorReleaseCallBack;
    copyDescription: _CFAllocatorCopyDescriptionCallBack;
}</code></pre>
<hr />
<h2 id="fseventstreamcallback">_FSEventStreamCallback</h2>
<pre><code>_FSEventStreamCallback :: *fn (streamRef: _ConstFSEventStreamRef, clientCallBackInfo: *u8, numEvents: usize, eventPaths: *u8, eventFlags: *_FSEventStreamEventFlags, eventIds: *_FSEventStreamEventId) </code></pre>
<hr />
<h2 id="fseventstreamcreate">_FSEventStreamCreate</h2>
<pre><code>_FSEventStreamCreate :: fn (allocator: _CFAllocatorRef, callback: _FSEventStreamCallback, context: *_FSEventStreamContext, pathsToWatch: _CFArrayRef, sinceWhen: _FSEventStreamEventId, latency: _CFTimeInterval, flags: _FSEventStreamCreateFlags) _FSEventStreamRef #extern</code></pre>
<hr />
<h2 id="fseventstreamschedulewithrunloop">_FSEventStreamScheduleWithRunLoop</h2>
<pre><code>_FSEventStreamScheduleWithRunLoop :: fn (streamRef: _FSEventStreamRef, runLoop: _CFRunLoopRef, runLoopMode: _CFStringRef)  #extern</code></pre>
<hr />
<h2 id="fseventstreamunschedulefromrunloop">_FSEventStreamUnscheduleFromRunLoop</h2>
<pre><code>_FSEventStreamUnscheduleFromRunLoop :: fn (streamRef: _FSEventStreamRef, runLoop: _CFRunLoopRef, runLoopMode: _CFStringRef)  #extern</code></pre>
<hr />
<h2 id="fseventstreamstart">_FSEventStreamStart</h2>
<pre><code>_FSEventStreamStart :: fn (streamRef: _FSEventStreamRef) _Boolean #extern</code></pre>
<hr />
<h2 id="fseventstreamflushsync">_FSEventStreamFlushSync</h2>
<pre><code>_FSEventStreamFlushSync :: fn (streamRef: _FSEventStreamRef)  #extern</code></pre>
<hr />
<h2 id="fseventstreamstop">_FSEventStreamStop</h2>
<pre><code>_FSEventStreamStop :: fn (streamRef: _FSEventStreamRef)  #extern</code></pre>
<hr />
<h2 id="fseventstreaminvalidate">_FSEventStreamInvalidate</h2>
<pre><code>_FSEventStreamInvalidate :: fn (streamRef: _FSEventStreamRef)  #extern</code></pre>
<hr />
<h2 id="fseventstreamrelease">_FSEventStreamRelease</h2>
<pre><code>_FSEventStreamRelease :: fn (streamRef: _FSEventStreamRef)  #extern</code></pre>
<hr />
<h2 id="nsgetexecutablepath">_NSGetExecutablePath</h2>
<pre><code>_NSGetExecutablePath :: fn (buf: *c_char, bufsize: *c_uint) c_int #extern</code></pre>
<hr />
<h1 id="stat.bl-1">stat.bl</h1>
<h2 id="s_irwxu-1">_S_IRWXU</h2>
<pre><code>_S_IRWXU : _mode_t : 448</code></pre>
<hr />
<h2 id="s_irusr-1">_S_IRUSR</h2>
<pre><code>_S_IRUSR : _mode_t : 256</code></pre>
<hr />
<h2 id="s_iwusr-1">_S_IWUSR</h2>
<pre><code>_S_IWUSR : _mode_t : 128</code></pre>
<hr />
<h2 id="s_ixusr-1">_S_IXUSR</h2>
<pre><code>_S_IXUSR : _mode_t : 64</code></pre>
<hr />
<h2 id="s_irwxg-1">_S_IRWXG</h2>
<pre><code>_S_IRWXG : _mode_t : 56</code></pre>
<hr />
<h2 id="s_irgrp-1">_S_IRGRP</h2>
<pre><code>_S_IRGRP : _mode_t : 32</code></pre>
<hr />
<h2 id="s_iwgrp-1">_S_IWGRP</h2>
<pre><code>_S_IWGRP : _mode_t : 16</code></pre>
<hr />
<h2 id="s_ixgrp-1">_S_IXGRP</h2>
<pre><code>_S_IXGRP : _mode_t : 8</code></pre>
<hr />
<h2 id="s_irwxo-1">_S_IRWXO</h2>
<pre><code>_S_IRWXO : _mode_t : 7</code></pre>
<hr />
<h2 id="s_iroth-1">_S_IROTH</h2>
<pre><code>_S_IROTH : _mode_t : 4</code></pre>
<hr />
<h2 id="s_iwoth-1">_S_IWOTH</h2>
<pre><code>_S_IWOTH : _mode_t : 2</code></pre>
<hr />
<h2 id="s_ixoth-1">_S_IXOTH</h2>
<pre><code>_S_IXOTH : _mode_t : 1</code></pre>
<hr />
<h2 id="s_isuid">_S_ISUID</h2>
<pre><code>_S_ISUID : _mode_t : 2048</code></pre>
<hr />
<h2 id="s_isgid">_S_ISGID</h2>
<pre><code>_S_ISGID : _mode_t : 1024</code></pre>
<hr />
<h2 id="s_isvtx">_S_ISVTX</h2>
<pre><code>_S_ISVTX : _mode_t : 512</code></pre>
<hr />
<h2 id="s_ifmt-1">__S_IFMT</h2>
<pre><code>__S_IFMT : u32 : 61440</code></pre>
<hr />
<h2 id="s_ifdir-1">__S_IFDIR</h2>
<pre><code>__S_IFDIR : u32 : 16384</code></pre>
<hr />
<h2 id="s_ifchr-1">__S_IFCHR</h2>
<pre><code>__S_IFCHR : u32 : 8192</code></pre>
<hr />
<h2 id="s_ifblk-1">__S_IFBLK</h2>
<pre><code>__S_IFBLK : u32 : 24576</code></pre>
<hr />
<h2 id="s_ifreg-1">__S_IFREG</h2>
<pre><code>__S_IFREG : u32 : 32768</code></pre>
<hr />
<h2 id="s_ififo-1">__S_IFIFO</h2>
<pre><code>__S_IFIFO : u32 : 4096</code></pre>
<hr />
<h2 id="s_iflnk-1">__S_IFLNK</h2>
<pre><code>__S_IFLNK : u32 : 40960</code></pre>
<hr />
<h2 id="s_ifsock-1">__S_IFSOCK</h2>
<pre><code>__S_IFSOCK : u32 : 49152</code></pre>
<hr />
<h2 id="s_isdir-1">_S_ISDIR</h2>
<pre><code>_S_ISDIR :: fn (mode: u32) bool #inline</code></pre>
<hr />
<h2 id="s_isreg-1">_S_ISREG</h2>
<pre><code>_S_ISREG :: fn (mode: u32) bool #inline</code></pre>
<hr />
<h2 id="stat_t-1">_stat_t</h2>
<pre><code>_stat_t :: struct {
    st_dev: _dev_t;
    st_mode: _mode_t;
    st_nlink: _nlink_t;
    st_ino: _ino64_t;
    st_uid: _uid_t;
    st_gid: _gid_t;
    st_rdev: _dev_t;
    st_atimespec: _timespec;
    st_mtimespec: _timespec;
    st_ctimespec: _timespec;
    st_birthtimespec: _timespec;
    st_size: _off_t;
    st_blocks: _blkcnt_t;
    st_blksize: _blksize_t;
    st_flags: u32;
    st_gen: u32;
    st_lspare: s32;
    st_qspare: ;
}</code></pre>
<hr />
<h2 id="stat-1">_stat</h2>
<pre><code>_stat :: fn (path: *c_char, buf: *_stat_t) c_int #extern</code></pre>
<hr />
<h2 id="fstat-1">_fstat</h2>
<pre><code>_fstat :: fn (fd: c_int, stat: *_stat_t) c_int #extern</code></pre>
<hr />
<h2 id="mkdir-1">_mkdir</h2>
<pre><code>_mkdir :: fn (path: *c_char, mode: _mode_t) c_int #extern</code></pre>
<hr />
<h2 id="fchmod">_fchmod</h2>
<pre><code>_fchmod :: fn (fd: c_int, mode: _mode_t) c_int #extern</code></pre>
<hr />
<h1 id="error.bl">error.bl</h1>
<h2 id="err_unknown">ERR_UNKNOWN</h2>
<pre><code>ERR_UNKNOWN :: </code></pre>
<hr />
<h2 id="err_not_found">ERR_NOT_FOUND</h2>
<pre><code>ERR_NOT_FOUND :: _ENOENT</code></pre>
<hr />
<h2 id="err_already_exist">ERR_ALREADY_EXIST</h2>
<pre><code>ERR_ALREADY_EXIST :: _EEXIST</code></pre>
<hr />
<h2 id="err_access_denied">ERR_ACCESS_DENIED</h2>
<pre><code>ERR_ACCESS_DENIED :: _EACCES</code></pre>
<hr />
<h2 id="err_invalid_handle">ERR_INVALID_HANDLE</h2>
<pre><code>ERR_INVALID_HANDLE :: _EBADF</code></pre>
<hr />
<h2 id="err_directory">ERR_DIRECTORY</h2>
<pre><code>ERR_DIRECTORY :: _EISDIR</code></pre>
<hr />
<h2 id="eperm">_EPERM</h2>
<pre><code>_EPERM :: 1</code></pre>
<hr />
<h2 id="enoent">_ENOENT</h2>
<pre><code>_ENOENT :: 2</code></pre>
<hr />
<h2 id="esrch">_ESRCH</h2>
<pre><code>_ESRCH :: 3</code></pre>
<hr />
<h2 id="eintr">_EINTR</h2>
<pre><code>_EINTR :: 4</code></pre>
<hr />
<h2 id="eio">_EIO</h2>
<pre><code>_EIO :: 5</code></pre>
<hr />
<h2 id="enxio">_ENXIO</h2>
<pre><code>_ENXIO :: 6</code></pre>
<hr />
<h2 id="e2big">_E2BIG</h2>
<pre><code>_E2BIG :: 7</code></pre>
<hr />
<h2 id="enoexec">_ENOEXEC</h2>
<pre><code>_ENOEXEC :: 8</code></pre>
<hr />
<h2 id="ebadf">_EBADF</h2>
<pre><code>_EBADF :: 9</code></pre>
<hr />
<h2 id="echild">_ECHILD</h2>
<pre><code>_ECHILD :: 10</code></pre>
<hr />
<h2 id="eagain">_EAGAIN</h2>
<pre><code>_EAGAIN :: 11</code></pre>
<hr />
<h2 id="enomem">_ENOMEM</h2>
<pre><code>_ENOMEM :: 12</code></pre>
<hr />
<h2 id="eacces">_EACCES</h2>
<pre><code>_EACCES :: 13</code></pre>
<hr />
<h2 id="efault">_EFAULT</h2>
<pre><code>_EFAULT :: 14</code></pre>
<hr />
<h2 id="enotblk">_ENOTBLK</h2>
<pre><code>_ENOTBLK :: 15</code></pre>
<hr />
<h2 id="ebusy">_EBUSY</h2>
<pre><code>_EBUSY :: 16</code></pre>
<hr />
<h2 id="eexist">_EEXIST</h2>
<pre><code>_EEXIST :: 17</code></pre>
<hr />
<h2 id="exdev">_EXDEV</h2>
<pre><code>_EXDEV :: 18</code></pre>
<hr />
<h2 id="enodev">_ENODEV</h2>
<pre><code>_ENODEV :: 19</code></pre>
<hr />
<h2 id="enotdir">_ENOTDIR</h2>
<pre><code>_ENOTDIR :: 20</code></pre>
<hr />
<h2 id="eisdir">_EISDIR</h2>
<pre><code>_EISDIR :: 21</code></pre>
<hr />
<h2 id="einval">_EINVAL</h2>
<pre><code>_EINVAL :: 22</code></pre>
<hr />
<h2 id="enfile">_ENFILE</h2>
<pre><code>_ENFILE :: 23</code></pre>
<hr />
<h2 id="emfile">_EMFILE</h2>
<pre><code>_EMFILE :: 24</code></pre>
<hr />
<h2 id="enotty">_ENOTTY</h2>
<pre><code>_ENOTTY :: 25</code></pre>
<hr />
<h2 id="etxtbsy">_ETXTBSY</h2>
<pre><code>_ETXTBSY :: 26</code></pre>
<hr />
<h2 id="efbig">_EFBIG</h2>
<pre><code>_EFBIG :: 27</code></pre>
<hr />
<h2 id="enospc">_ENOSPC</h2>
<pre><code>_ENOSPC :: 28</code></pre>
<hr />
<h2 id="espipe">_ESPIPE</h2>
<pre><code>_ESPIPE :: 29</code></pre>
<hr />
<h2 id="erofs">_EROFS</h2>
<pre><code>_EROFS :: 30</code></pre>
<hr />
<h2 id="emlink">_EMLINK</h2>
<pre><code>_EMLINK :: 31</code></pre>
<hr />
<h2 id="epipe">_EPIPE</h2>
<pre><code>_EPIPE :: 32</code></pre>
<hr />
<h2 id="edom">_EDOM</h2>
<pre><code>_EDOM :: 33</code></pre>
<hr />
<h2 id="erange">_ERANGE</h2>
<pre><code>_ERANGE :: 34</code></pre>
<hr />
<h2 id="edeadlk">_EDEADLK</h2>
<pre><code>_EDEADLK :: 35</code></pre>
<hr />
<h2 id="enametoolong">_ENAMETOOLONG</h2>
<pre><code>_ENAMETOOLONG :: 36</code></pre>
<hr />
<h2 id="enolck">_ENOLCK</h2>
<pre><code>_ENOLCK :: 37</code></pre>
<hr />
<h2 id="enosys">_ENOSYS</h2>
<pre><code>_ENOSYS :: 38</code></pre>
<hr />
<h2 id="enotempty">_ENOTEMPTY</h2>
<pre><code>_ENOTEMPTY :: 39</code></pre>
<hr />
<h2 id="eloop">_ELOOP</h2>
<pre><code>_ELOOP :: 40</code></pre>
<hr />
<h2 id="ewouldblock">_EWOULDBLOCK</h2>
<pre><code>_EWOULDBLOCK :: _EAGAIN</code></pre>
<hr />
<h2 id="enomsg">_ENOMSG</h2>
<pre><code>_ENOMSG :: 42</code></pre>
<hr />
<h2 id="eidrm">_EIDRM</h2>
<pre><code>_EIDRM :: 43</code></pre>
<hr />
<h2 id="echrng">_ECHRNG</h2>
<pre><code>_ECHRNG :: 44</code></pre>
<hr />
<h2 id="el2nsync">_EL2NSYNC</h2>
<pre><code>_EL2NSYNC :: 45</code></pre>
<hr />
<h2 id="el3hlt">_EL3HLT</h2>
<pre><code>_EL3HLT :: 46</code></pre>
<hr />
<h2 id="el3rst">_EL3RST</h2>
<pre><code>_EL3RST :: 47</code></pre>
<hr />
<h2 id="elnrng">_ELNRNG</h2>
<pre><code>_ELNRNG :: 48</code></pre>
<hr />
<h2 id="eunatch">_EUNATCH</h2>
<pre><code>_EUNATCH :: 49</code></pre>
<hr />
<h2 id="enocsi">_ENOCSI</h2>
<pre><code>_ENOCSI :: 50</code></pre>
<hr />
<h2 id="el2hlt">_EL2HLT</h2>
<pre><code>_EL2HLT :: 51</code></pre>
<hr />
<h2 id="ebade">_EBADE</h2>
<pre><code>_EBADE :: 52</code></pre>
<hr />
<h2 id="ebadr">_EBADR</h2>
<pre><code>_EBADR :: 53</code></pre>
<hr />
<h2 id="exfull">_EXFULL</h2>
<pre><code>_EXFULL :: 54</code></pre>
<hr />
<h2 id="enoano">_ENOANO</h2>
<pre><code>_ENOANO :: 55</code></pre>
<hr />
<h2 id="ebadrqc">_EBADRQC</h2>
<pre><code>_EBADRQC :: 56</code></pre>
<hr />
<h2 id="ebadslt">_EBADSLT</h2>
<pre><code>_EBADSLT :: 57</code></pre>
<hr />
<h2 id="edeadlock">_EDEADLOCK</h2>
<pre><code>_EDEADLOCK :: _EDEADLK</code></pre>
<hr />
<h2 id="ebfont">_EBFONT</h2>
<pre><code>_EBFONT :: 59</code></pre>
<hr />
<h2 id="enostr">_ENOSTR</h2>
<pre><code>_ENOSTR :: 60</code></pre>
<hr />
<h2 id="enodata">_ENODATA</h2>
<pre><code>_ENODATA :: 61</code></pre>
<hr />
<h2 id="etime">_ETIME</h2>
<pre><code>_ETIME :: 62</code></pre>
<hr />
<h2 id="enosr">_ENOSR</h2>
<pre><code>_ENOSR :: 63</code></pre>
<hr />
<h2 id="enonet">_ENONET</h2>
<pre><code>_ENONET :: 64</code></pre>
<hr />
<h2 id="enopkg">_ENOPKG</h2>
<pre><code>_ENOPKG :: 65</code></pre>
<hr />
<h2 id="eremote">_EREMOTE</h2>
<pre><code>_EREMOTE :: 66</code></pre>
<hr />
<h2 id="enolink">_ENOLINK</h2>
<pre><code>_ENOLINK :: 67</code></pre>
<hr />
<h2 id="eadv">_EADV</h2>
<pre><code>_EADV :: 68</code></pre>
<hr />
<h2 id="esrmnt">_ESRMNT</h2>
<pre><code>_ESRMNT :: 69</code></pre>
<hr />
<h2 id="ecomm">_ECOMM</h2>
<pre><code>_ECOMM :: 70</code></pre>
<hr />
<h2 id="eproto">_EPROTO</h2>
<pre><code>_EPROTO :: 71</code></pre>
<hr />
<h2 id="emultihop">_EMULTIHOP</h2>
<pre><code>_EMULTIHOP :: 72</code></pre>
<hr />
<h2 id="edotdot">_EDOTDOT</h2>
<pre><code>_EDOTDOT :: 73</code></pre>
<hr />
<h2 id="ebadmsg">_EBADMSG</h2>
<pre><code>_EBADMSG :: 74</code></pre>
<hr />
<h2 id="eoverflow">_EOVERFLOW</h2>
<pre><code>_EOVERFLOW :: 75</code></pre>
<hr />
<h2 id="enotuniq">_ENOTUNIQ</h2>
<pre><code>_ENOTUNIQ :: 76</code></pre>
<hr />
<h2 id="ebadfd">_EBADFD</h2>
<pre><code>_EBADFD :: 77</code></pre>
<hr />
<h2 id="eremchg">_EREMCHG</h2>
<pre><code>_EREMCHG :: 78</code></pre>
<hr />
<h2 id="elibacc">_ELIBACC</h2>
<pre><code>_ELIBACC :: 79</code></pre>
<hr />
<h2 id="elibbad">_ELIBBAD</h2>
<pre><code>_ELIBBAD :: 80</code></pre>
<hr />
<h2 id="elibscn">_ELIBSCN</h2>
<pre><code>_ELIBSCN :: 81</code></pre>
<hr />
<h2 id="elibmax">_ELIBMAX</h2>
<pre><code>_ELIBMAX :: 82</code></pre>
<hr />
<h2 id="elibexec">_ELIBEXEC</h2>
<pre><code>_ELIBEXEC :: 83</code></pre>
<hr />
<h2 id="eilseq">_EILSEQ</h2>
<pre><code>_EILSEQ :: 84</code></pre>
<hr />
<h2 id="erestart">_ERESTART</h2>
<pre><code>_ERESTART :: 85</code></pre>
<hr />
<h2 id="estrpipe">_ESTRPIPE</h2>
<pre><code>_ESTRPIPE :: 86</code></pre>
<hr />
<h2 id="eusers">_EUSERS</h2>
<pre><code>_EUSERS :: 87</code></pre>
<hr />
<h2 id="enotsock">_ENOTSOCK</h2>
<pre><code>_ENOTSOCK :: 88</code></pre>
<hr />
<h2 id="edestaddrreq">_EDESTADDRREQ</h2>
<pre><code>_EDESTADDRREQ :: 89</code></pre>
<hr />
<h2 id="emsgsize">_EMSGSIZE</h2>
<pre><code>_EMSGSIZE :: 90</code></pre>
<hr />
<h2 id="eprototype">_EPROTOTYPE</h2>
<pre><code>_EPROTOTYPE :: 91</code></pre>
<hr />
<h2 id="enoprotoopt">_ENOPROTOOPT</h2>
<pre><code>_ENOPROTOOPT :: 92</code></pre>
<hr />
<h2 id="eprotonosupport">_EPROTONOSUPPORT</h2>
<pre><code>_EPROTONOSUPPORT :: 93</code></pre>
<hr />
<h2 id="esocktnosupport">_ESOCKTNOSUPPORT</h2>
<pre><code>_ESOCKTNOSUPPORT :: 94</code></pre>
<hr />
<h2 id="eopnotsupp">_EOPNOTSUPP</h2>
<pre><code>_EOPNOTSUPP :: 95</code></pre>
<hr />
<h2 id="epfnosupport">_EPFNOSUPPORT</h2>
<pre><code>_EPFNOSUPPORT :: 96</code></pre>
<hr />
<h2 id="eafnosupport">_EAFNOSUPPORT</h2>
<pre><code>_EAFNOSUPPORT :: 97</code></pre>
<hr />
<h2 id="eaddrinuse">_EADDRINUSE</h2>
<pre><code>_EADDRINUSE :: 98</code></pre>
<hr />
<h2 id="eaddrnotavail">_EADDRNOTAVAIL</h2>
<pre><code>_EADDRNOTAVAIL :: 99</code></pre>
<hr />
<h2 id="enetdown">_ENETDOWN</h2>
<pre><code>_ENETDOWN :: 100</code></pre>
<hr />
<h2 id="enetunreach">_ENETUNREACH</h2>
<pre><code>_ENETUNREACH :: 101</code></pre>
<hr />
<h2 id="enetreset">_ENETRESET</h2>
<pre><code>_ENETRESET :: 102</code></pre>
<hr />
<h2 id="econnaborted">_ECONNABORTED</h2>
<pre><code>_ECONNABORTED :: 103</code></pre>
<hr />
<h2 id="econnreset">_ECONNRESET</h2>
<pre><code>_ECONNRESET :: 104</code></pre>
<hr />
<h2 id="enobufs">_ENOBUFS</h2>
<pre><code>_ENOBUFS :: 105</code></pre>
<hr />
<h2 id="eisconn">_EISCONN</h2>
<pre><code>_EISCONN :: 106</code></pre>
<hr />
<h2 id="enotconn">_ENOTCONN</h2>
<pre><code>_ENOTCONN :: 107</code></pre>
<hr />
<h2 id="eshutdown">_ESHUTDOWN</h2>
<pre><code>_ESHUTDOWN :: 108</code></pre>
<hr />
<h2 id="etoomanyrefs">_ETOOMANYREFS</h2>
<pre><code>_ETOOMANYREFS :: 109</code></pre>
<hr />
<h2 id="etimedout">_ETIMEDOUT</h2>
<pre><code>_ETIMEDOUT :: 110</code></pre>
<hr />
<h2 id="econnrefused">_ECONNREFUSED</h2>
<pre><code>_ECONNREFUSED :: 111</code></pre>
<hr />
<h2 id="ehostdown">_EHOSTDOWN</h2>
<pre><code>_EHOSTDOWN :: 112</code></pre>
<hr />
<h2 id="ehostunreach">_EHOSTUNREACH</h2>
<pre><code>_EHOSTUNREACH :: 113</code></pre>
<hr />
<h2 id="ealready">_EALREADY</h2>
<pre><code>_EALREADY :: 114</code></pre>
<hr />
<h2 id="einprogress">_EINPROGRESS</h2>
<pre><code>_EINPROGRESS :: 115</code></pre>
<hr />
<h2 id="estale">_ESTALE</h2>
<pre><code>_ESTALE :: 116</code></pre>
<hr />
<h2 id="euclean">_EUCLEAN</h2>
<pre><code>_EUCLEAN :: 117</code></pre>
<hr />
<h2 id="enotnam">_ENOTNAM</h2>
<pre><code>_ENOTNAM :: 118</code></pre>
<hr />
<h2 id="enavail">_ENAVAIL</h2>
<pre><code>_ENAVAIL :: 119</code></pre>
<hr />
<h2 id="eisnam">_EISNAM</h2>
<pre><code>_EISNAM :: 120</code></pre>
<hr />
<h2 id="eremoteio">_EREMOTEIO</h2>
<pre><code>_EREMOTEIO :: 121</code></pre>
<hr />
<h2 id="edquot">_EDQUOT</h2>
<pre><code>_EDQUOT :: 122</code></pre>
<hr />
<h2 id="enomedium">_ENOMEDIUM</h2>
<pre><code>_ENOMEDIUM :: 123</code></pre>
<hr />
<h2 id="emediumtype">_EMEDIUMTYPE</h2>
<pre><code>_EMEDIUMTYPE :: 124</code></pre>
<hr />
<h2 id="ecanceled">_ECANCELED</h2>
<pre><code>_ECANCELED :: 125</code></pre>
<hr />
<h2 id="enokey">_ENOKEY</h2>
<pre><code>_ENOKEY :: 126</code></pre>
<hr />
<h2 id="ekeyexpired">_EKEYEXPIRED</h2>
<pre><code>_EKEYEXPIRED :: 127</code></pre>
<hr />
<h2 id="ekeyrevoked">_EKEYREVOKED</h2>
<pre><code>_EKEYREVOKED :: 128</code></pre>
<hr />
<h2 id="ekeyrejected">_EKEYREJECTED</h2>
<pre><code>_EKEYREJECTED :: 129</code></pre>
<hr />
<h2 id="eownerdead">_EOWNERDEAD</h2>
<pre><code>_EOWNERDEAD :: 130</code></pre>
<hr />
<h2 id="enotrecoverable">_ENOTRECOVERABLE</h2>
<pre><code>_ENOTRECOVERABLE :: 131</code></pre>
<hr />
<h2 id="erfkill">_ERFKILL</h2>
<pre><code>_ERFKILL :: 132</code></pre>
<hr />
<h2 id="ehwpoison">_EHWPOISON</h2>
<pre><code>_EHWPOISON :: 133</code></pre>
<hr />
<h1 id="libc.bl">libc.bl</h1>
<h2 id="c_stdin">C_STDIN</h2>
<pre><code>C_STDIN :: 0</code></pre>
<hr />
<h2 id="c_stdout">C_STDOUT</h2>
<pre><code>C_STDOUT :: 1</code></pre>
<hr />
<h2 id="c_stderr">C_STDERR</h2>
<pre><code>C_STDERR :: 2</code></pre>
<hr />
<h2 id="c_rand_max">C_RAND_MAX</h2>
<pre><code>C_RAND_MAX :: 2147483647</code></pre>
<hr />
<h2 id="c_getenv">c_getenv</h2>
<pre><code>c_getenv :: fn (name: *c_char) *c_char #extern</code></pre>
<hr />
<h2 id="c_putenv">c_putenv</h2>
<pre><code>c_putenv :: fn (var: *c_char) c_int #extern</code></pre>
<hr />
<h2 id="c_realpath">c_realpath</h2>
<pre><code>c_realpath :: fn (path: *c_char, resolved_path: *c_char) *c_char #extern</code></pre>
<hr />
<h2 id="c_exit">c_exit</h2>
<pre><code>c_exit :: fn (v: c_int)  #extern</code></pre>
<hr />
<h2 id="c_system">c_system</h2>
<pre><code>c_system :: fn (command: *c_char) c_int #extern</code></pre>
<hr />
<h2 id="c_malloc">c_malloc</h2>
<pre><code>c_malloc :: fn (size: c_size_t) c_void_ptr #extern</code></pre>
<hr />
<h2 id="c_free">c_free</h2>
<pre><code>c_free :: fn (ptr: c_void_ptr)  #extern</code></pre>
<hr />
<h2 id="c_strlen">c_strlen</h2>
<pre><code>c_strlen :: fn (str: *c_char) c_size_t #extern</code></pre>
<hr />
<h2 id="c_strcmp">c_strcmp</h2>
<pre><code>c_strcmp :: fn (first: *c_char, second: *c_char) c_int #extern</code></pre>
<hr />
<h2 id="c_wcslen">c_wcslen</h2>
<pre><code>c_wcslen :: fn (str: *u16) usize #extern</code></pre>
<hr />
<h2 id="c_strerror">c_strerror</h2>
<pre><code>c_strerror :: fn (errnum: c_int) *c_char #extern</code></pre>
<hr />
<h1 id="pthread.bl">pthread.bl</h1>
<h2 id="pthread_mutex_t">_pthread_mutex_t</h2>
<pre><code>_pthread_mutex_t :: struct {
    __sig: c_long;
    __opaque: ;
}</code></pre>
<hr />
<h2 id="pthread_t">_pthread_t</h2>
<pre><code>_pthread_t :: *u8</code></pre>
<hr />
<h2 id="pthread_attr_t">_pthread_attr_t</h2>
<pre><code>_pthread_attr_t :: *u8</code></pre>
<hr />
<h2 id="pthread_start_routine_t">_pthread_start_routine_t</h2>
<pre><code>_pthread_start_routine_t :: *fn (args: c_void_ptr) c_void_ptr</code></pre>
<hr />
<h2 id="pthread_create">_pthread_create</h2>
<pre><code>_pthread_create :: fn (thread: *_pthread_t, attr: _pthread_attr_t, start_routine: _pthread_start_routine_t, args: c_void_ptr) c_int #extern</code></pre>
<hr />
<h2 id="pthread_join">_pthread_join</h2>
<pre><code>_pthread_join :: fn (thread: _pthread_t, retval: *c_void_ptr) c_int #extern</code></pre>
<hr />
<h2 id="pthread_exit">_pthread_exit</h2>
<pre><code>_pthread_exit :: fn (retval: c_void_ptr)  #extern</code></pre>
<hr />
<h2 id="pthread_self">_pthread_self</h2>
<pre><code>_pthread_self :: fn () _pthread_t #extern</code></pre>
<hr />
<h2 id="pthread_mutex_lock">_pthread_mutex_lock</h2>
<pre><code>_pthread_mutex_lock :: fn (mutex: *_pthread_mutex_t) c_int #extern</code></pre>
<hr />
<h2 id="pthread_mutex_trylock">_pthread_mutex_trylock</h2>
<pre><code>_pthread_mutex_trylock :: fn (mutex: *_pthread_mutex_t) c_int #extern</code></pre>
<hr />
<h2 id="pthread_mutex_unlock">_pthread_mutex_unlock</h2>
<pre><code>_pthread_mutex_unlock :: fn (mutex: *_pthread_mutex_t) c_int #extern</code></pre>
<hr />
<h2 id="pthread_mutex_init">_pthread_mutex_init</h2>
<pre><code>_pthread_mutex_init :: fn (mutex: *_pthread_mutex_t, attr: c_void_ptr) c_int #extern</code></pre>
<hr />
<h2 id="pthread_mutex_destroy">_pthread_mutex_destroy</h2>
<pre><code>_pthread_mutex_destroy :: fn (mutex: *_pthread_mutex_t) c_int #extern</code></pre>
<hr />
<h1 id="signal.bl">signal.bl</h1>
<h2 id="sighup">_SIGHUP</h2>
<pre><code>_SIGHUP :: 1</code></pre>
<hr />
<h2 id="sigint">_SIGINT</h2>
<pre><code>_SIGINT :: 2</code></pre>
<hr />
<h2 id="sigquit">_SIGQUIT</h2>
<pre><code>_SIGQUIT :: 3</code></pre>
<hr />
<h2 id="sigill">_SIGILL</h2>
<pre><code>_SIGILL :: 4</code></pre>
<hr />
<h2 id="sigtrap">_SIGTRAP</h2>
<pre><code>_SIGTRAP :: 5</code></pre>
<hr />
<h2 id="sigabrt">_SIGABRT</h2>
<pre><code>_SIGABRT :: 6</code></pre>
<hr />
<h2 id="sighandler">_Sighandler</h2>
<pre><code>_Sighandler :: *fn (v: c_int) </code></pre>
<hr />
<h2 id="raise">_raise</h2>
<pre><code>_raise :: fn (sig: c_int) c_int #extern</code></pre>
<hr />
<h2 id="signal">_signal</h2>
<pre><code>_signal :: fn (signum: c_int, handler: _Sighandler) _Sighandler #extern</code></pre>
<hr />
<h1 id="unistd.bl">unistd.bl</h1>
<h2 id="getcwd">_getcwd</h2>
<pre><code>_getcwd :: fn (buf: *c_char, size: c_size_t) *c_char #extern</code></pre>
<hr />
<h2 id="unlink">_unlink</h2>
<pre><code>_unlink :: fn (pathname: *c_char) c_int #extern</code></pre>
<hr />
<h2 id="read">_read</h2>
<pre><code>_read :: fn (fd: c_int, buf: *c_char, count: c_size_t) c_ssize_t #extern</code></pre>
<hr />
<h2 id="readlink">_readlink</h2>
<pre><code>_readlink :: fn (pathname: *c_char, buf: *c_char, bufsiz: c_size_t) c_ssize_t #extern</code></pre>
<hr />
<h2 id="close">_close</h2>
<pre><code>_close :: fn (fd: c_int) c_int #extern</code></pre>
<hr />
<h2 id="write">_write</h2>
<pre><code>_write :: fn (fd: c_int, buf: *c_char, count: c_size_t) c_ssize_t #extern</code></pre>
<hr />
<h2 id="usleep">_usleep</h2>
<pre><code>_usleep :: fn (us: c_uint) c_int #extern</code></pre>
<hr />
<h2 id="rmdir">_rmdir</h2>
<pre><code>_rmdir :: fn (path: *c_char) c_int #extern</code></pre>
<hr />
<h2 id="chdir">_chdir</h2>
<pre><code>_chdir :: fn (path: *c_char) c_int #extern</code></pre>
<hr />
<h1 id="io.bl">io.bl</h1>
<h2 id="write-1">_write</h2>
<pre><code>_write :: fn (fd: c_int, buf: *c_char, count: c_size_t) c_ssize_t #extern</code></pre>
<hr />
<h2 id="read-1">_read</h2>
<pre><code>_read :: fn (fd: c_int, buf: *c_char, count: c_size_t) c_ssize_t #extern</code></pre>
<hr />
<h1 id="libc.bl-1">libc.bl</h1>
<h2 id="c_stdin-1">C_STDIN</h2>
<pre><code>C_STDIN :: 0</code></pre>
<hr />
<h2 id="c_stdout-1">C_STDOUT</h2>
<pre><code>C_STDOUT :: 1</code></pre>
<hr />
<h2 id="c_stderr-1">C_STDERR</h2>
<pre><code>C_STDERR :: 2</code></pre>
<hr />
<h2 id="c_rand_max-1">C_RAND_MAX</h2>
<pre><code>C_RAND_MAX :: 2147483647</code></pre>
<hr />
<h2 id="c_getenv-1">c_getenv</h2>
<pre><code>c_getenv :: fn (name: *c_char) *c_char #extern</code></pre>
<hr />
<h2 id="c_putenv-1">c_putenv</h2>
<pre><code>c_putenv :: fn (var: *c_char) c_int #extern</code></pre>
<hr />
<h2 id="c_realpath-1">c_realpath</h2>
<pre><code>c_realpath :: fn (path: *c_char, resolved_path: *c_char) *c_char #extern</code></pre>
<hr />
<h2 id="c_exit-1">c_exit</h2>
<pre><code>c_exit :: fn (v: c_int)  #extern</code></pre>
<hr />
<h2 id="c_system-1">c_system</h2>
<pre><code>c_system :: fn (command: *c_char) c_int #extern</code></pre>
<hr />
<h2 id="c_malloc-1">c_malloc</h2>
<pre><code>c_malloc :: fn (size: c_size_t) c_void_ptr #extern</code></pre>
<hr />
<h2 id="c_free-1">c_free</h2>
<pre><code>c_free :: fn (ptr: c_void_ptr)  #extern</code></pre>
<hr />
<h2 id="c_strlen-1">c_strlen</h2>
<pre><code>c_strlen :: fn (str: *c_char) c_size_t #extern</code></pre>
<hr />
<h2 id="c_strcmp-1">c_strcmp</h2>
<pre><code>c_strcmp :: fn (first: *c_char, second: *c_char) c_int #extern</code></pre>
<hr />
<h2 id="c_wcslen-1">c_wcslen</h2>
<pre><code>c_wcslen :: fn (str: *u16) usize #extern</code></pre>
<hr />
<h2 id="c_strerror-1">c_strerror</h2>
<pre><code>c_strerror :: fn (errnum: c_int) *c_char #extern</code></pre>
<hr />
<h1 id="winapi.bl">winapi.bl</h1>
<h2 id="err_unknown-1">ERR_UNKNOWN</h2>
<pre><code>ERR_UNKNOWN :: </code></pre>
<hr />
<h2 id="err_not_found-1">ERR_NOT_FOUND</h2>
<pre><code>ERR_NOT_FOUND :: Win32.ERROR_FILE_NOT_FOUND</code></pre>
<hr />
<h2 id="err_already_exist-1">ERR_ALREADY_EXIST</h2>
<pre><code>ERR_ALREADY_EXIST :: Win32.ERROR_FILE_EXISTS</code></pre>
<hr />
<h2 id="err_access_denied-1">ERR_ACCESS_DENIED</h2>
<pre><code>ERR_ACCESS_DENIED :: Win32.ERROR_ACCESS_DENIED</code></pre>
<hr />
<h2 id="err_invalid_handle-1">ERR_INVALID_HANDLE</h2>
<pre><code>ERR_INVALID_HANDLE :: Win32.ERROR_INVALID_HANDLE</code></pre>
<hr />
<h2 id="err_directory-1">ERR_DIRECTORY</h2>
<pre><code>ERR_DIRECTORY :: Win32.ERROR_DIRECTORY</code></pre>
<hr />
<h2 id="true">TRUE</h2>
<pre><code>TRUE :: 1</code></pre>
<hr />
<h2 id="false">FALSE</h2>
<pre><code>FALSE :: 0</code></pre>
<hr />
<h2 id="max_path">MAX_PATH</h2>
<pre><code>MAX_PATH :: 260</code></pre>
<hr />
<h2 id="invalid_handle_value">INVALID_HANDLE_VALUE</h2>
<pre><code>INVALID_HANDLE_VALUE :: </code></pre>
<hr />
<h2 id="infinite">INFINITE</h2>
<pre><code>INFINITE : u32 : 4294967295</code></pre>
<hr />
<h2 id="error_file_not_found">ERROR_FILE_NOT_FOUND</h2>
<pre><code>ERROR_FILE_NOT_FOUND :: 2</code></pre>
<hr />
<h2 id="error_file_exists">ERROR_FILE_EXISTS</h2>
<pre><code>ERROR_FILE_EXISTS :: 80</code></pre>
<hr />
<h2 id="error_access_denied">ERROR_ACCESS_DENIED</h2>
<pre><code>ERROR_ACCESS_DENIED :: 5</code></pre>
<hr />
<h2 id="error_invalid_handle">ERROR_INVALID_HANDLE</h2>
<pre><code>ERROR_INVALID_HANDLE :: 6</code></pre>
<hr />
<h2 id="error_directory">ERROR_DIRECTORY</h2>
<pre><code>ERROR_DIRECTORY :: 267</code></pre>
<hr />
<h2 id="cp_utf8">CP_UTF8</h2>
<pre><code>CP_UTF8 : u32 : 65001</code></pre>
<hr />
<h2 id="wchar">WCHAR</h2>
<pre><code>WCHAR :: *c_ushort</code></pre>
<hr />
<h2 id="lpwstr">LPWSTR</h2>
<pre><code>LPWSTR :: *c_ushort</code></pre>
<hr />
<h2 id="lpcwstr">LPCWSTR</h2>
<pre><code>LPCWSTR :: *c_ushort</code></pre>
<hr />
<h2 id="lpcstr">LPCSTR</h2>
<pre><code>LPCSTR :: *c_ushort</code></pre>
<hr />
<h2 id="lpstr">LPSTR</h2>
<pre><code>LPSTR :: *c_uchar</code></pre>
<hr />
<h2 id="lpctstr">LPCTSTR</h2>
<pre><code>LPCTSTR :: *c_uchar</code></pre>
<hr />
<h2 id="hlocal">HLOCAL</h2>
<pre><code>HLOCAL :: *c_uchar</code></pre>
<hr />
<h2 id="uint">UINT</h2>
<pre><code>UINT :: c_uint</code></pre>
<hr />
<h2 id="dword">DWORD</h2>
<pre><code>DWORD :: c_uint</code></pre>
<hr />
<h2 id="lpcch">LPCCH</h2>
<pre><code>LPCCH :: c_uchar</code></pre>
<hr />
<h2 id="lpcwch">LPCWCH</h2>
<pre><code>LPCWCH :: c_ushort</code></pre>
<hr />
<h2 id="lpbool">LPBOOL</h2>
<pre><code>LPBOOL :: c_int</code></pre>
<hr />
<h2 id="hmodule">HMODULE</h2>
<pre><code>HMODULE :: *c_uchar</code></pre>
<hr />
<h2 id="bool">BOOL</h2>
<pre><code>BOOL :: c_int</code></pre>
<hr />
<h2 id="pbool">PBOOL</h2>
<pre><code>PBOOL :: *BOOL</code></pre>
<hr />
<h2 id="farproc">FARPROC</h2>
<pre><code>FARPROC :: *c_uchar</code></pre>
<hr />
<h2 id="lpvoid">LPVOID</h2>
<pre><code>LPVOID :: *c_uchar</code></pre>
<hr />
<h2 id="lpoverlapped">LPOVERLAPPED</h2>
<pre><code>LPOVERLAPPED :: *OVERLAPPED</code></pre>
<hr />
<h2 id="lpdword">LPDWORD</h2>
<pre><code>LPDWORD :: *DWORD</code></pre>
<hr />
<h2 id="handle">HANDLE</h2>
<pre><code>HANDLE :: *c_uchar</code></pre>
<hr />
<h2 id="ulong_ptr">ULONG_PTR</h2>
<pre><code>ULONG_PTR :: *c_ulong</code></pre>
<hr />
<h2 id="size_t">SIZE_T</h2>
<pre><code>SIZE_T :: c_ulong</code></pre>
<hr />
<h2 id="pvoid">PVOID</h2>
<pre><code>PVOID :: *c_uchar</code></pre>
<hr />
<h2 id="char">CHAR</h2>
<pre><code>CHAR :: c_uchar</code></pre>
<hr />
<h2 id="long_ptr">LONG_PTR</h2>
<pre><code>LONG_PTR :: *c_long</code></pre>
<hr />
<h2 id="large_integer">LARGE_INTEGER</h2>
<pre><code>LARGE_INTEGER :: c_longlong</code></pre>
<hr />
<h2 id="plarge_integer">PLARGE_INTEGER</h2>
<pre><code>PLARGE_INTEGER :: *LARGE_INTEGER</code></pre>
<hr />
<h2 id="hglobal">HGLOBAL</h2>
<pre><code>HGLOBAL :: c_void_ptr</code></pre>
<hr />
<h2 id="hwnd">HWND</h2>
<pre><code>HWND :: c_void_ptr</code></pre>
<hr />
<h2 id="long">LONG</h2>
<pre><code>LONG :: c_long</code></pre>
<hr />
<h2 id="plong">PLONG</h2>
<pre><code>PLONG :: *LONG</code></pre>
<hr />
<h2 id="word">WORD</h2>
<pre><code>WORD :: c_ushort</code></pre>
<hr />
<h2 id="generic_read">GENERIC_READ</h2>
<pre><code>GENERIC_READ : u32 : 2147483648</code></pre>
<hr />
<h2 id="generic_write">GENERIC_WRITE</h2>
<pre><code>GENERIC_WRITE : u32 : 1073741824</code></pre>
<hr />
<h2 id="file_begin">FILE_BEGIN</h2>
<pre><code>FILE_BEGIN : u32 : 0</code></pre>
<hr />
<h2 id="file_current">FILE_CURRENT</h2>
<pre><code>FILE_CURRENT : u32 : 1</code></pre>
<hr />
<h2 id="file_end">FILE_END</h2>
<pre><code>FILE_END : u32 : 2</code></pre>
<hr />
<h2 id="create_new">CREATE_NEW</h2>
<pre><code>CREATE_NEW : u32 : 1</code></pre>
<hr />
<h2 id="create_always">CREATE_ALWAYS</h2>
<pre><code>CREATE_ALWAYS : u32 : 2</code></pre>
<hr />
<h2 id="open_existing">OPEN_EXISTING</h2>
<pre><code>OPEN_EXISTING : u32 : 3</code></pre>
<hr />
<h2 id="open_always">OPEN_ALWAYS</h2>
<pre><code>OPEN_ALWAYS : u32 : 4</code></pre>
<hr />
<h2 id="truncate_existing">TRUNCATE_EXISTING</h2>
<pre><code>TRUNCATE_EXISTING : u32 : 5</code></pre>
<hr />
<h2 id="lpoverlapped_completion_routine">LPOVERLAPPED_COMPLETION_ROUTINE</h2>
<pre><code>LPOVERLAPPED_COMPLETION_ROUTINE :: *fn (dwErrorCode: DWORD, dwNumberOfBytesTransfered: DWORD, lpOverlapped: LPOVERLAPPED) </code></pre>
<hr />
<h2 id="file_add_file">FILE_ADD_FILE</h2>
<pre><code>FILE_ADD_FILE : u32 : 2</code></pre>
<hr />
<h2 id="file_add_subdirectory">FILE_ADD_SUBDIRECTORY</h2>
<pre><code>FILE_ADD_SUBDIRECTORY : u32 : 4</code></pre>
<hr />
<h2 id="file_append_data">FILE_APPEND_DATA</h2>
<pre><code>FILE_APPEND_DATA : u32 : 4</code></pre>
<hr />
<h2 id="file_attribute_archive">FILE_ATTRIBUTE_ARCHIVE</h2>
<pre><code>FILE_ATTRIBUTE_ARCHIVE : u32 : 32</code></pre>
<hr />
<h2 id="file_attribute_compressed">FILE_ATTRIBUTE_COMPRESSED</h2>
<pre><code>FILE_ATTRIBUTE_COMPRESSED : u32 : 2048</code></pre>
<hr />
<h2 id="file_attribute_device">FILE_ATTRIBUTE_DEVICE</h2>
<pre><code>FILE_ATTRIBUTE_DEVICE : u32 : 64</code></pre>
<hr />
<h2 id="file_attribute_directory">FILE_ATTRIBUTE_DIRECTORY</h2>
<pre><code>FILE_ATTRIBUTE_DIRECTORY : u32 : 16</code></pre>
<hr />
<h2 id="file_attribute_encrypted">FILE_ATTRIBUTE_ENCRYPTED</h2>
<pre><code>FILE_ATTRIBUTE_ENCRYPTED : u32 : 16384</code></pre>
<hr />
<h2 id="file_attribute_hidden">FILE_ATTRIBUTE_HIDDEN</h2>
<pre><code>FILE_ATTRIBUTE_HIDDEN : u32 : 2</code></pre>
<hr />
<h2 id="file_attribute_normal">FILE_ATTRIBUTE_NORMAL</h2>
<pre><code>FILE_ATTRIBUTE_NORMAL : u32 : 128</code></pre>
<hr />
<h2 id="file_attribute_not_content_indexed">FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</h2>
<pre><code>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED : u32 : 8192</code></pre>
<hr />
<h2 id="file_attribute_offline">FILE_ATTRIBUTE_OFFLINE</h2>
<pre><code>FILE_ATTRIBUTE_OFFLINE : u32 : 4096</code></pre>
<hr />
<h2 id="file_attribute_readonly">FILE_ATTRIBUTE_READONLY</h2>
<pre><code>FILE_ATTRIBUTE_READONLY : u32 : 1</code></pre>
<hr />
<h2 id="file_attribute_reparse_point">FILE_ATTRIBUTE_REPARSE_POINT</h2>
<pre><code>FILE_ATTRIBUTE_REPARSE_POINT : u32 : 1024</code></pre>
<hr />
<h2 id="file_attribute_sparse_file">FILE_ATTRIBUTE_SPARSE_FILE</h2>
<pre><code>FILE_ATTRIBUTE_SPARSE_FILE : u32 : 512</code></pre>
<hr />
<h2 id="file_attribute_system">FILE_ATTRIBUTE_SYSTEM</h2>
<pre><code>FILE_ATTRIBUTE_SYSTEM : u32 : 4</code></pre>
<hr />
<h2 id="file_attribute_temporary">FILE_ATTRIBUTE_TEMPORARY</h2>
<pre><code>FILE_ATTRIBUTE_TEMPORARY : u32 : 256</code></pre>
<hr />
<h2 id="file_attribute_virtual">FILE_ATTRIBUTE_VIRTUAL</h2>
<pre><code>FILE_ATTRIBUTE_VIRTUAL : u32 : 65536</code></pre>
<hr />
<h2 id="file_create_pipe_instance">FILE_CREATE_PIPE_INSTANCE</h2>
<pre><code>FILE_CREATE_PIPE_INSTANCE : u32 : 4</code></pre>
<hr />
<h2 id="file_flag_backup_semantics">FILE_FLAG_BACKUP_SEMANTICS</h2>
<pre><code>FILE_FLAG_BACKUP_SEMANTICS : u32 : 33554432</code></pre>
<hr />
<h2 id="file_flag_delete_on_close">FILE_FLAG_DELETE_ON_CLOSE</h2>
<pre><code>FILE_FLAG_DELETE_ON_CLOSE : u32 : 67108864</code></pre>
<hr />
<h2 id="file_flag_first_pipe_instance">FILE_FLAG_FIRST_PIPE_INSTANCE</h2>
<pre><code>FILE_FLAG_FIRST_PIPE_INSTANCE : u32 : 524288</code></pre>
<hr />
<h2 id="file_flag_no_buffering">FILE_FLAG_NO_BUFFERING</h2>
<pre><code>FILE_FLAG_NO_BUFFERING : u32 : 536870912</code></pre>
<hr />
<h2 id="file_flag_open_no_recall">FILE_FLAG_OPEN_NO_RECALL</h2>
<pre><code>FILE_FLAG_OPEN_NO_RECALL : u32 : 1048576</code></pre>
<hr />
<h2 id="file_flag_open_reparse_point">FILE_FLAG_OPEN_REPARSE_POINT</h2>
<pre><code>FILE_FLAG_OPEN_REPARSE_POINT : u32 : 2097152</code></pre>
<hr />
<h2 id="file_flag_overlapped">FILE_FLAG_OVERLAPPED</h2>
<pre><code>FILE_FLAG_OVERLAPPED : u32 : 1073741824</code></pre>
<hr />
<h2 id="file_flag_posix_semantics">FILE_FLAG_POSIX_SEMANTICS</h2>
<pre><code>FILE_FLAG_POSIX_SEMANTICS : u32 : 16777216</code></pre>
<hr />
<h2 id="file_flag_random_access">FILE_FLAG_RANDOM_ACCESS</h2>
<pre><code>FILE_FLAG_RANDOM_ACCESS : u32 : 268435456</code></pre>
<hr />
<h2 id="file_flag_sequential_scan">FILE_FLAG_SEQUENTIAL_SCAN</h2>
<pre><code>FILE_FLAG_SEQUENTIAL_SCAN : u32 : 134217728</code></pre>
<hr />
<h2 id="file_flag_session_aware">FILE_FLAG_SESSION_AWARE</h2>
<pre><code>FILE_FLAG_SESSION_AWARE : u32 : 8388608</code></pre>
<hr />
<h2 id="file_flag_write_through">FILE_FLAG_WRITE_THROUGH</h2>
<pre><code>FILE_FLAG_WRITE_THROUGH : u32 : 2147483648</code></pre>
<hr />
<h2 id="file_list_directory">FILE_LIST_DIRECTORY</h2>
<pre><code>FILE_LIST_DIRECTORY : u32 : 1</code></pre>
<hr />
<h2 id="file_read_data">FILE_READ_DATA</h2>
<pre><code>FILE_READ_DATA : u32 : 1</code></pre>
<hr />
<h2 id="file_share_delete">FILE_SHARE_DELETE</h2>
<pre><code>FILE_SHARE_DELETE : u32 : 4</code></pre>
<hr />
<h2 id="file_share_read">FILE_SHARE_READ</h2>
<pre><code>FILE_SHARE_READ : u32 : 1</code></pre>
<hr />
<h2 id="file_share_write">FILE_SHARE_WRITE</h2>
<pre><code>FILE_SHARE_WRITE : u32 : 2</code></pre>
<hr />
<h2 id="file_write_data">FILE_WRITE_DATA</h2>
<pre><code>FILE_WRITE_DATA : u32 : 2</code></pre>
<hr />
<h2 id="ghnd">GHND</h2>
<pre><code>GHND : u32 : 66</code></pre>
<hr />
<h2 id="gmem_fixed">GMEM_FIXED</h2>
<pre><code>GMEM_FIXED : u32 : 0</code></pre>
<hr />
<h2 id="gmem_moveable">GMEM_MOVEABLE</h2>
<pre><code>GMEM_MOVEABLE : u32 : 2</code></pre>
<hr />
<h2 id="gmem_zeroinit">GMEM_ZEROINIT</h2>
<pre><code>GMEM_ZEROINIT : u32 : 64</code></pre>
<hr />
<h2 id="gptr">GPTR</h2>
<pre><code>GPTR : u32 : 64</code></pre>
<hr />
<h2 id="cf_text">CF_TEXT</h2>
<pre><code>CF_TEXT : u32 : 1</code></pre>
<hr />
<h2 id="file_notify_change_file_name">FILE_NOTIFY_CHANGE_FILE_NAME</h2>
<pre><code>FILE_NOTIFY_CHANGE_FILE_NAME : u32 : 1</code></pre>
<hr />
<h2 id="file_notify_change_dir_name">FILE_NOTIFY_CHANGE_DIR_NAME</h2>
<pre><code>FILE_NOTIFY_CHANGE_DIR_NAME : u32 : 2</code></pre>
<hr />
<h2 id="file_notify_change_attributes">FILE_NOTIFY_CHANGE_ATTRIBUTES</h2>
<pre><code>FILE_NOTIFY_CHANGE_ATTRIBUTES : u32 : 4</code></pre>
<hr />
<h2 id="file_notify_change_size">FILE_NOTIFY_CHANGE_SIZE</h2>
<pre><code>FILE_NOTIFY_CHANGE_SIZE : u32 : 8</code></pre>
<hr />
<h2 id="file_notify_change_last_write">FILE_NOTIFY_CHANGE_LAST_WRITE</h2>
<pre><code>FILE_NOTIFY_CHANGE_LAST_WRITE : u32 : 16</code></pre>
<hr />
<h2 id="file_notify_change_last_access">FILE_NOTIFY_CHANGE_LAST_ACCESS</h2>
<pre><code>FILE_NOTIFY_CHANGE_LAST_ACCESS : u32 : 32</code></pre>
<hr />
<h2 id="file_notify_change_creation">FILE_NOTIFY_CHANGE_CREATION</h2>
<pre><code>FILE_NOTIFY_CHANGE_CREATION : u32 : 64</code></pre>
<hr />
<h2 id="file_notify_change_security">FILE_NOTIFY_CHANGE_SECURITY</h2>
<pre><code>FILE_NOTIFY_CHANGE_SECURITY : u32 : 256</code></pre>
<hr />
<h2 id="file_notify_information">FILE_NOTIFY_INFORMATION</h2>
<pre><code>FILE_NOTIFY_INFORMATION :: struct {
    NextEntryOffset: DWORD;
    Action: DWORD;
    FileNameLength: DWORD;
    FileName: ;
}</code></pre>
<hr />
<h2 id="overlapped">OVERLAPPED</h2>
<pre><code>OVERLAPPED :: struct {
    Internal: ULONG_PTR;
    InternalHigh: ULONG_PTR;
    Pointer: PVOID;
    hEvent: HANDLE;
}</code></pre>
<hr />
<h2 id="filetime">FILETIME</h2>
<pre><code>FILETIME :: struct {
    dwLowDateTime: DWORD;
    dwHighDateTime: DWORD;
}</code></pre>
<hr />
<h2 id="pfiletime">PFILETIME</h2>
<pre><code>PFILETIME :: FILETIME</code></pre>
<hr />
<h2 id="lpfiletime">LPFILETIME</h2>
<pre><code>LPFILETIME :: *FILETIME</code></pre>
<hr />
<h2 id="find_data">FIND_DATA</h2>
<pre><code>FIND_DATA :: struct {
    dwFileAttributes: DWORD;
    ftCreationTime: FILETIME;
    ftLastAccessTime: FILETIME;
    ftLastWriteTime: FILETIME;
    nFileSizeHigh: DWORD;
    nFileSizeLow: DWORD;
    dwReserved0: DWORD;
    dwReserved1: DWORD;
    cFileName: ;
    cAlternateFileName: ;
}</code></pre>
<hr />
<h2 id="by_handle_file_information">BY_HANDLE_FILE_INFORMATION</h2>
<pre><code>BY_HANDLE_FILE_INFORMATION :: struct {
    dwFileAttributes: DWORD;
    ftCreationTime: FILETIME;
    ftLastAccessTime: FILETIME;
    ftLastWriteTime: FILETIME;
    dwVolumeSerialNumber: DWORD;
    nFileSizeHigh: DWORD;
    nFileSizeLow: DWORD;
    nNumberOfLinks: DWORD;
    nFileIndexHigh: DWORD;
    nFileIndexLow: DWORD;
}</code></pre>
<hr />
<h2 id="lpby_handle_file_information">LPBY_HANDLE_FILE_INFORMATION</h2>
<pre><code>LPBY_HANDLE_FILE_INFORMATION :: *BY_HANDLE_FILE_INFORMATION</code></pre>
<hr />
<h2 id="find_dataa">FIND_DATAA</h2>
<pre><code>FIND_DATAA :: FIND_DATA</code></pre>
<hr />
<h2 id="p_find_dataa">P_FIND_DATAA</h2>
<pre><code>P_FIND_DATAA :: *FIND_DATA</code></pre>
<hr />
<h2 id="lp_find_dataa">LP_FIND_DATAA</h2>
<pre><code>LP_FIND_DATAA :: *FIND_DATA</code></pre>
<hr />
<h2 id="invalid_handle">INVALID_HANDLE</h2>
<pre><code>INVALID_HANDLE :: </code></pre>
<hr />
<h2 id="invalid_file_attributes">INVALID_FILE_ATTRIBUTES</h2>
<pre><code>INVALID_FILE_ATTRIBUTES :: </code></pre>
<hr />
<h2 id="wait_timeout">WAIT_TIMEOUT</h2>
<pre><code>WAIT_TIMEOUT :: 258</code></pre>
<hr />
<h2 id="wait_failed">WAIT_FAILED</h2>
<pre><code>WAIT_FAILED : DWORD : 4294967295</code></pre>
<hr />
<h2 id="wait_object_0">WAIT_OBJECT_0</h2>
<pre><code>WAIT_OBJECT_0 :: 0</code></pre>
<hr />
<h2 id="list_entry">LIST_ENTRY</h2>
<pre><code>LIST_ENTRY :: struct {
    Flink: *LIST_ENTRY;
    Blink: *LIST_ENTRY;
}</code></pre>
<hr />
<h2 id="rtl_critical_section_debug">RTL_CRITICAL_SECTION_DEBUG</h2>
<pre><code>RTL_CRITICAL_SECTION_DEBUG :: struct {
    Type: WORD;
    CreatorBackTraceIndex: WORD;
    CriticalSection: *RTL_CRITICAL_SECTION;
    ProcessLocksList: LIST_ENTRY;
    EntryCount: DWORD;
    ContentionCount: DWORD;
    Flags: DWORD;
    CreatorBackTraceIndexHigh: WORD;
    SpareWORD: WORD;
}</code></pre>
<hr />
<h2 id="prtl_critical_section_debug">PRTL_CRITICAL_SECTION_DEBUG</h2>
<pre><code>PRTL_CRITICAL_SECTION_DEBUG :: *RTL_CRITICAL_SECTION_DEBUG</code></pre>
<hr />
<h2 id="rtl_critical_section">RTL_CRITICAL_SECTION</h2>
<pre><code>RTL_CRITICAL_SECTION :: struct {
    DebugInfo: PRTL_CRITICAL_SECTION_DEBUG;
    LockCount: LONG;
    RecursionCount: LONG;
    OwningThread: HANDLE;
    LockSemaphore: HANDLE;
    SpinCount: ULONG_PTR;
}</code></pre>
<hr />
<h2 id="lpcritical_section">LPCRITICAL_SECTION</h2>
<pre><code>LPCRITICAL_SECTION :: *RTL_CRITICAL_SECTION</code></pre>
<hr />
<h2 id="format_message_ignore_inserts">FORMAT_MESSAGE_IGNORE_INSERTS</h2>
<pre><code>FORMAT_MESSAGE_IGNORE_INSERTS : u32 : 512</code></pre>
<hr />
<h2 id="format_message_from_string">FORMAT_MESSAGE_FROM_STRING</h2>
<pre><code>FORMAT_MESSAGE_FROM_STRING : u32 : 1024</code></pre>
<hr />
<h2 id="format_message_from_hmodule">FORMAT_MESSAGE_FROM_HMODULE</h2>
<pre><code>FORMAT_MESSAGE_FROM_HMODULE : u32 : 2048</code></pre>
<hr />
<h2 id="format_message_from_system">FORMAT_MESSAGE_FROM_SYSTEM</h2>
<pre><code>FORMAT_MESSAGE_FROM_SYSTEM : u32 : 4096</code></pre>
<hr />
<h2 id="format_message_argument_array">FORMAT_MESSAGE_ARGUMENT_ARRAY</h2>
<pre><code>FORMAT_MESSAGE_ARGUMENT_ARRAY : u32 : 8192</code></pre>
<hr />
<h2 id="format_message_max_width_mask">FORMAT_MESSAGE_MAX_WIDTH_MASK</h2>
<pre><code>FORMAT_MESSAGE_MAX_WIDTH_MASK : u32 : 255</code></pre>
<hr />
<h2 id="findfirstfile">FindFirstFile</h2>
<pre><code>FindFirstFile :: fn (lpFileName: LPCSTR, lpFindFileData: LP_FIND_DATAA) HANDLE #extern</code></pre>
<hr />
<h2 id="findclose">FindClose</h2>
<pre><code>FindClose :: fn (hFindFile: HANDLE) BOOL #extern</code></pre>
<hr />
<h2 id="findnextfile">FindNextFile</h2>
<pre><code>FindNextFile :: fn (hFindFile: HANDLE, lpFindFileData: LP_FIND_DATAA) BOOL #extern</code></pre>
<hr />
<h2 id="getfileattributesa">GetFileAttributesA</h2>
<pre><code>GetFileAttributesA :: fn (lpFileName: LPCSTR) DWORD #extern</code></pre>
<hr />
<h2 id="createfile">CreateFile</h2>
<pre><code>CreateFile :: fn (lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE) *u8 #extern</code></pre>
<hr />
<h2 id="createdirectorya">CreateDirectoryA</h2>
<pre><code>CreateDirectoryA :: fn (lpPathName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) BOOL #extern</code></pre>
<hr />
<h2 id="readdirectorychanges">ReadDirectoryChanges</h2>
<pre><code>ReadDirectoryChanges :: fn (hDirectory: HANDLE, lpBuffer: LPVOID, nBufferLength: DWORD, bWatchSubtree: BOOL, dwNotifyFilter: DWORD, lpBytesReturned: LPDWORD, lpOverlapped: LPOVERLAPPED, lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE) s32 #extern</code></pre>
<hr />
<h2 id="widechartomultibyte">WideCharToMultiByte</h2>
<pre><code>WideCharToMultiByte :: fn (CodePage: UINT, dwFlags: *DWORD, lpWideCharStr: *LPCWCH, cchWideChar: s32, lpMultiByteStr: LPSTR, cbMultiByte: s32, lpDefaultChar: *LPCCH, lpUsedDefaultChar: *LPBOOL) s32 #extern</code></pre>
<hr />
<h2 id="createevent">CreateEvent</h2>
<pre><code>CreateEvent :: fn (lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, bInitialState: BOOL, lpName: LPCSTR) HANDLE #extern</code></pre>
<hr />
<h2 id="setevent">SetEvent</h2>
<pre><code>SetEvent :: fn (hEvent: HANDLE) BOOL #extern</code></pre>
<hr />
<h2 id="findfirstchangenotification">FindFirstChangeNotification</h2>
<pre><code>FindFirstChangeNotification :: fn (lpPathName: LPCSTR, bWatchSubtree: BOOL, dwNotifyFilter: DWORD) HANDLE #extern</code></pre>
<hr />
<h2 id="findnextchangenotification">FindNextChangeNotification</h2>
<pre><code>FindNextChangeNotification :: fn (hChangeHandle: HANDLE) BOOL #extern</code></pre>
<hr />
<h2 id="findclosechangenotification">FindCloseChangeNotification</h2>
<pre><code>FindCloseChangeNotification :: fn (hChangeHandle: HANDLE) BOOL #extern</code></pre>
<hr />
<h2 id="waitforsingleobject">WaitForSingleObject</h2>
<pre><code>WaitForSingleObject :: fn (hHandle: HANDLE, dwMilliseconds: DWORD) DWORD #extern</code></pre>
<hr />
<h2 id="waitformultipleobjects">WaitForMultipleObjects</h2>
<pre><code>WaitForMultipleObjects :: fn (nCount: DWORD, lpHandles: *HANDLE, bWaitAll: BOOL, dwMilliseconds: DWORD) DWORD #extern</code></pre>
<hr />
<h2 id="getcommandlinew">GetCommandLineW</h2>
<pre><code>GetCommandLineW :: fn () LPWSTR #extern</code></pre>
<hr />
<h2 id="commandlinetoargvw">CommandLineToArgvW</h2>
<pre><code>CommandLineToArgvW :: fn (lpCmdLine: LPCWSTR, pNumArgs: *s32) *LPWSTR #extern</code></pre>
<hr />
<h2 id="localfree">LocalFree</h2>
<pre><code>LocalFree :: fn (hMem: HLOCAL) HLOCAL #extern</code></pre>
<hr />
<h2 id="sleep">Sleep</h2>
<pre><code>Sleep :: fn (dwMilliseconds: DWORD)  #extern</code></pre>
<hr />
<h2 id="sleepex">SleepEx</h2>
<pre><code>SleepEx :: fn (dwMilliseconds: DWORD, bAlertable: BOOL) DWORD #extern</code></pre>
<hr />
<h2 id="getfullpathnamea">GetFullPathNameA</h2>
<pre><code>GetFullPathNameA :: fn (lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: *LPSTR) DWORD #extern</code></pre>
<hr />
<h2 id="pathfileexistsa">PathFileExistsA</h2>
<pre><code>PathFileExistsA :: fn (pszPath: LPCSTR) BOOL #extern</code></pre>
<hr />
<h2 id="loadlibrarya">LoadLibraryA</h2>
<pre><code>LoadLibraryA :: fn (lpLibFileName: LPCSTR) HMODULE #extern</code></pre>
<hr />
<h2 id="freelibrary">FreeLibrary</h2>
<pre><code>FreeLibrary :: fn (hLibModule: HMODULE) BOOL #extern</code></pre>
<hr />
<h2 id="getmodulehandlea">GetModuleHandleA</h2>
<pre><code>GetModuleHandleA :: fn (lpModuleName: LPCSTR) HMODULE #extern</code></pre>
<hr />
<h2 id="getprocaddress">GetProcAddress</h2>
<pre><code>GetProcAddress :: fn (hModule: HMODULE, lpProcName: LPCSTR) FARPROC #extern</code></pre>
<hr />
<h2 id="debugbreak">DebugBreak</h2>
<pre><code>DebugBreak :: fn ()  #extern</code></pre>
<hr />
<h2 id="isdebuggerpresent">IsDebuggerPresent</h2>
<pre><code>IsDebuggerPresent :: fn () BOOL #extern</code></pre>
<hr />
<h2 id="checkremotedebuggerpresent">CheckRemoteDebuggerPresent</h2>
<pre><code>CheckRemoteDebuggerPresent :: fn (hProcess: HANDLE, pbDebuggerPresent: PBOOL) BOOL #extern</code></pre>
<hr />
<h2 id="getmodulefilenamea">GetModuleFileNameA</h2>
<pre><code>GetModuleFileNameA :: fn (hModule: HMODULE, lpFilename: LPSTR, nSize: DWORD) DWORD #extern</code></pre>
<hr />
<h2 id="security_attributes">SECURITY_ATTRIBUTES</h2>
<pre><code>SECURITY_ATTRIBUTES :: struct {
    nLength: DWORD;
    lpSecurityDescriptor: LPVOID;
    bInheritHandle: BOOL;
}</code></pre>
<hr />
<h2 id="psecurity_attributes">PSECURITY_ATTRIBUTES</h2>
<pre><code>PSECURITY_ATTRIBUTES :: *SECURITY_ATTRIBUTES</code></pre>
<hr />
<h2 id="lpsecurity_attributes">LPSECURITY_ATTRIBUTES</h2>
<pre><code>LPSECURITY_ATTRIBUTES :: *SECURITY_ATTRIBUTES</code></pre>
<hr />
<h2 id="lpthread_start_routine">LPTHREAD_START_ROUTINE</h2>
<pre><code>LPTHREAD_START_ROUTINE :: *fn (args: LPVOID) DWORD</code></pre>
<hr />
<h2 id="createthread">CreateThread</h2>
<pre><code>CreateThread :: fn (lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T, lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD, lpThreadId: LPDWORD) HANDLE #extern</code></pre>
<hr />
<h2 id="getcurrentthread">GetCurrentThread</h2>
<pre><code>GetCurrentThread :: fn () HANDLE #extern</code></pre>
<hr />
<h2 id="terminatethread">TerminateThread</h2>
<pre><code>TerminateThread :: fn (handle: HANDLE, exit_code: DWORD) BOOL #extern</code></pre>
<hr />
<h2 id="getexitcodethread">GetExitCodeThread</h2>
<pre><code>GetExitCodeThread :: fn (hThread: HANDLE, lpExitCode: LPDWORD) BOOL #extern</code></pre>
<hr />
<h2 id="createmutexa">CreateMutexA</h2>
<pre><code>CreateMutexA :: fn (lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: BOOL, lpName: LPCSTR) HANDLE #extern</code></pre>
<hr />
<h2 id="releasemutex">ReleaseMutex</h2>
<pre><code>ReleaseMutex :: fn (hMutex: HANDLE) BOOL #extern</code></pre>
<hr />
<h2 id="gettickcount">GetTickCount</h2>
<pre><code>GetTickCount :: fn () DWORD #extern</code></pre>
<hr />
<h2 id="queryperformancecounter">QueryPerformanceCounter</h2>
<pre><code>QueryPerformanceCounter :: fn (lpPerformanceCount: *LARGE_INTEGER) BOOL #extern</code></pre>
<hr />
<h2 id="queryperformancefrequency">QueryPerformanceFrequency</h2>
<pre><code>QueryPerformanceFrequency :: fn (lpPerformanceCount: *LARGE_INTEGER) BOOL #extern</code></pre>
<hr />
<h2 id="globalalloc">GlobalAlloc</h2>
<pre><code>GlobalAlloc :: fn (uFlags: UINT, dwBytes: SIZE_T) HGLOBAL #extern</code></pre>
<hr />
<h2 id="globalfree">GlobalFree</h2>
<pre><code>GlobalFree :: fn (hMem: HGLOBAL) HGLOBAL #extern</code></pre>
<hr />
<h2 id="globallock">GlobalLock</h2>
<pre><code>GlobalLock :: fn (hMem: HGLOBAL) LPVOID #extern</code></pre>
<hr />
<h2 id="globalunlock">GlobalUnlock</h2>
<pre><code>GlobalUnlock :: fn (hMem: HGLOBAL) BOOL #extern</code></pre>
<hr />
<h2 id="openclipboard">OpenClipboard</h2>
<pre><code>OpenClipboard :: fn (hWndNewOwner: HWND) BOOL #extern</code></pre>
<hr />
<h2 id="emptyclipboard">EmptyClipboard</h2>
<pre><code>EmptyClipboard :: fn () BOOL #extern</code></pre>
<hr />
<h2 id="setclipboarddata">SetClipboardData</h2>
<pre><code>SetClipboardData :: fn (uFormat: UINT, hMem: HANDLE) HANDLE #extern</code></pre>
<hr />
<h2 id="getclipboarddata">GetClipboardData</h2>
<pre><code>GetClipboardData :: fn (uFormat: UINT) HANDLE #extern</code></pre>
<hr />
<h2 id="closeclipboard">CloseClipboard</h2>
<pre><code>CloseClipboard :: fn () BOOL #extern</code></pre>
<hr />
<h2 id="getlasterror">GetLastError</h2>
<pre><code>GetLastError :: fn () DWORD #extern</code></pre>
<hr />
<h2 id="closehandle">CloseHandle</h2>
<pre><code>CloseHandle :: fn (hObject: HANDLE) BOOL #extern</code></pre>
<hr />
<h2 id="gettemppatha">GetTempPathA</h2>
<pre><code>GetTempPathA :: fn (nBufferLength: DWORD, lpBuffer: LPSTR) DWORD #extern</code></pre>
<hr />
<h2 id="deletefilea">DeleteFileA</h2>
<pre><code>DeleteFileA :: fn (lpFileName: LPCSTR) BOOL #extern</code></pre>
<hr />
<h2 id="removedirectorya">RemoveDirectoryA</h2>
<pre><code>RemoveDirectoryA :: fn (lpPathName: LPCSTR) BOOL #extern</code></pre>
<hr />
<h2 id="getcurrentdirectorya">GetCurrentDirectoryA</h2>
<pre><code>GetCurrentDirectoryA :: fn (nBufferLength: DWORD, lpBuffer: LPSTR) DWORD #extern</code></pre>
<hr />
<h2 id="setcurrentdirectorya">SetCurrentDirectoryA</h2>
<pre><code>SetCurrentDirectoryA :: fn (lpPathName: LPSTR) BOOL #extern</code></pre>
<hr />
<h2 id="getfilesizeex">GetFileSizeEx</h2>
<pre><code>GetFileSizeEx :: fn (hFile: HANDLE, lpFileSize: PLARGE_INTEGER) BOOL #extern</code></pre>
<hr />
<h2 id="readfile">ReadFile</h2>
<pre><code>ReadFile :: fn (hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: LPDWORD, lpOverlapped: LPOVERLAPPED) BOOL #extern</code></pre>
<hr />
<h2 id="writefile">WriteFile</h2>
<pre><code>WriteFile :: fn (hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToWrite: DWORD, lpNumberOfBytesWritten: LPDWORD, lpOverlapped: LPOVERLAPPED) BOOL #extern</code></pre>
<hr />
<h2 id="copyfilea">CopyFileA</h2>
<pre><code>CopyFileA :: fn (lpExistingFileName: LPCTSTR, lpNewFileName: LPCTSTR, bFailIfExists: BOOL) BOOL #extern</code></pre>
<hr />
<h2 id="setendoffile">SetEndOfFile</h2>
<pre><code>SetEndOfFile :: fn (hFile: HANDLE) BOOL #extern</code></pre>
<hr />
<h2 id="setfilepointer">SetFilePointer</h2>
<pre><code>SetFilePointer :: fn (hFile: HANDLE, lDistanceToMove: LONG, lpDistanceToMoveHigh: PLONG, dwMoveMethod: DWORD) DWORD #extern</code></pre>
<hr />
<h2 id="initializecriticalsection">InitializeCriticalSection</h2>
<pre><code>InitializeCriticalSection :: fn (lpCriticalSection: LPCRITICAL_SECTION)  #extern</code></pre>
<hr />
<h2 id="deletecriticalsection">DeleteCriticalSection</h2>
<pre><code>DeleteCriticalSection :: fn (lpCriticalSection: LPCRITICAL_SECTION)  #extern</code></pre>
<hr />
<h2 id="entercriticalsection">EnterCriticalSection</h2>
<pre><code>EnterCriticalSection :: fn (lpCriticalSection: LPCRITICAL_SECTION)  #extern</code></pre>
<hr />
<h2 id="leavecriticalsection">LeaveCriticalSection</h2>
<pre><code>LeaveCriticalSection :: fn (lpCriticalSection: LPCRITICAL_SECTION)  #extern</code></pre>
<hr />
<h2 id="tryentercriticalsection">TryEnterCriticalSection</h2>
<pre><code>TryEnterCriticalSection :: fn (lpCriticalSection: LPCRITICAL_SECTION) BOOL #extern</code></pre>
<hr />
<h2 id="getfileinformationbyhandle">GetFileInformationByHandle</h2>
<pre><code>GetFileInformationByHandle :: fn (hFile: HANDLE, lpFileInformation: LPBY_HANDLE_FILE_INFORMATION) BOOL #extern</code></pre>
<hr />
<h2 id="getoverlappedresult">GetOverlappedResult</h2>
<pre><code>GetOverlappedResult :: fn (hFile: HANDLE, lpOverlapped: LPOVERLAPPED, lpNumberOfBytesTransferred: LPDWORD, bWait: BOOL) BOOL #extern</code></pre>
<hr />
<h2 id="resetevent">ResetEvent</h2>
<pre><code>ResetEvent :: fn (hEvent: HANDLE) BOOL #extern</code></pre>
<hr />
<h2 id="formatmessagea">FormatMessageA</h2>
<pre><code>FormatMessageA :: fn (dwFlags: DWORD, lpSource: LPVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPSTR, nSize: DWORD, Arguments: *u8) DWORD #extern</code></pre>
<hr />
<h1 id="command-line-argument-parser">Command Line Argument Parser</h1>
<p><code>#import "std/arg_parser"</code></p>
<p>Generic command line argument parsing tool.</p>
<h3 id="example-3">Example</h3>
<pre><code>#import &quot;std/arg_parser&quot;

// Command line arguments context.
Args :: struct #base ArgParser.Ctx {
    my_flag: bool;
    my_name: string;
}

g_args: Args;

main :: fn () s32 {
    parser :: ArgParser.new();
    defer ArgParser.delete(parser);
    // After this all positional arguments stored inside the argument parser
    // context are invalid.
    defer ArgParser.ctx_terminate(&amp;g_args);

    // Add new argument.
    ArgParser.add(
        parser, 
        &quot;-f&quot;, // Short name (must start with -)
        &quot;--flag&quot;, // Long name (must start with -)
        &quot;Specify my flag.&quot;, // Help text.
        &amp;fn (parser: ArgParser.Parser, args: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.my_flag = true;
            return 1, ok(); // Return number of parsed arguments and state.
        });

    ArgParser.add(
        parser,
        &quot;-n&quot;,
        &quot;--name&quot;,
        &quot;Specify my name.&quot;,
        &amp;fn (parser: ArgParser.Parser, args: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            if (args.len &lt; 2) {
                return 0, error(&quot;Expected name!&quot;);
            }
            a.my_name = args[1];
            return 2, ok();
        });

    // Start parsing.
    state :: ArgParser.run(parser, command_line_arguments, &amp;g_args, 1);
    if !is_ok(state) {
        print_err(&quot;%&quot;, state);
        ArgParser.print_help(parser);
        return 1;
    }

    print(&quot;%\n&quot;, g_args);
    return 0;
}</code></pre>
<h2 id="ctx">Ctx</h2>
<pre><code>Ctx :: struct {
    positional: [..]string;
    help: bool;
}</code></pre>
<p>Arguments context base type.</p>
<h3 id="members-17">Members</h3>
<p><strong>positional</strong> - Contains other positional arguments not considered as options (i.e. input files).</p>
<p><strong>help</strong> - True when help was invoked implicitly.</p>
<hr />
<h2 id="parser">Parser</h2>
<pre><code>Parser :: *u8</code></pre>
<p>Argument parser opaque handle.</p>
<hr />
<h2 id="handlerfn">HandlerFn</h2>
<pre><code>HandlerFn :: *fn (parser: Parser, args: []string, ctx: *Ctx) (_0: s32, _1: Error
)</code></pre>
<p>Argument parser callback function type. In context of <a href="#argparseradd">add</a> this callback function provides current <code>parser</code>, rest of the input argument slice starting from currently captured argument name and custom argument context <code>ctx</code>. Expected return of such function is count of parsed arguments from <code>args</code> input (at least one for successfully parsed argument with no additional input) and status.</p>
<p>See also: <a href="#argparseradd">add</a></p>
<p><strong>todo</strong>: Is reference to parent parser needed here?</p>
<hr />
<h2 id="new">new</h2>
<pre><code>new :: fn (help_text :: ) Parser</code></pre>
<p>Create new instance of parser with possibility to set custom help text. Use <a href="#argparserdelete">delete</a> to release parser instance.</p>
<hr />
<h2 id="delete">delete</h2>
<pre><code>delete :: fn (_parser: Parser) </code></pre>
<p>Delete parser instance.</p>
<hr />
<h2 id="ctx_terminate">ctx_terminate</h2>
<pre><code>ctx_terminate :: fn (ctx: *Ctx) </code></pre>
<p>Release ‘positional’ arguments array inside the context data.</p>
<hr />
<h2 id="run">run</h2>
<pre><code>run :: fn (_parser: Parser, args: []string, ctx: *Ctx, start :: 0) Error</code></pre>
<p>Perform parsing on input <code>args</code> slice and provide <code>ctx</code> as context to the argument parsing callbacks. <code>start</code> specify first element of <code>args</code> slice considered to be an argument. See also: (command_line_arguments)[#argparsercommand_line_arguments] (<strong>note</strong>: first element contains name of the executable)</p>
<hr />
<h2 id="add">add</h2>
<pre><code>add :: fn (_parser: Parser, short: string, long: string, help: string, handler: HandlerFn) </code></pre>
<p>Add new argument specified by <code>short</code> and <code>long</code> name to be recognised by parser. The argument description can be specified as <code>help</code>. <code>handler</code> function is called every time parser hits this argument (<code>short</code> or <code>long</code> name match). Argument name must be unique name starting with <code>-</code>. Help command (as <code>-h</code> or <code>--help</code>) is added by default.</p>
<h3 id="example-4">Example</h3>
<pre><code>ArgParser.add(parser,
    &quot;-d&quot;, // short name.
    &quot;--debug&quot;, // long name.
    &quot;Enable debug mode.&quot;, // Help text.
    &amp;fn (parser: ArgParser.Parser, args: []string, ctx: *ArgParser.Ctx) (s32, Error) {
        a: *MyArgs = auto ctx;
        a.is_debug = true;
        return 1, ok(); // One argument parsed (&#39;-d&#39; or &#39;--debug&#39;) 
    });</code></pre>
<hr />
<h2 id="print_help">print_help</h2>
<pre><code>print_help :: fn (_parser: Parser) </code></pre>
<p>Print help for all registered commands.</p>
<hr />
<h1 id="array">Array</h1>
<p><code>#import "std/array"</code></p>
<p>Compiler builtin dynamic array is automatically growing memory storage allocated on heap. The array allocated memory block groves over time when we push new values to the array. It’s guaranteed that all pushed elements are stored in single continuous block of memory. When there is no space reminding in currently allocated block, new one is allocated and all already pushed data are copied from old block to the new one.</p>
<h3 id="example-5">Example</h3>
<pre><code>main :: fn () s32 {
    arr: [..]s32; // dynamic array
    loop i := 0; i &lt; 10; i += 1 {
        array_push(&amp;arr, i);
    }
    print(&quot;arr = %\n&quot;, arr);
    return 0;
}</code></pre>
<h2 id="array-1">_Array</h2>
<pre><code>_Array :: struct {
    len: s64;
    ptr: *u8;
    allocated: usize;
    allocator: *Allocator;
}</code></pre>
<hr />
<h2 id="array_init">array_init</h2>
<pre><code>array_init :: fn (_arr: *[..]?T, allocator : *Allocator: )  #inline</code></pre>
<p>Sets dynamic array to default state. If array contains already allocated memory <code>array_terminate</code> must be called first. Custom <code>allocator</code> can be specified.</p>
<p>It’s usually enough to rely on default implicit initialization in case we don’t need specify custom allocator.</p>
<hr />
<h2 id="array_terminate">array_terminate</h2>
<pre><code>array_terminate :: fn (_arr: *[..]?T)  #inline</code></pre>
<p>Release memory allocated by dynamic array. This function is supposed to be called when dynamic array is no longer needed. Passed dynamic array is set to default state also.</p>
<hr />
<h2 id="array_push">array_push</h2>
<pre><code>array_push :: fn (arr: *[..]?T, v: T) </code></pre>
<p>Append new value at the dynamic array end. New heap allocation is done here only in cases when there is not enough memory allocated to store all values.</p>
<hr />
<h2 id="array_reserve">array_reserve</h2>
<pre><code>array_reserve :: fn (_arr: *[..]?T, n: s64)  #inline</code></pre>
<p>Reserve heap memory for <code>n</code> elements in array.</p>
<hr />
<h2 id="array_erase">array_erase</h2>
<pre><code>array_erase :: fn (_arr: *[..]?T, i: s64) </code></pre>
<p>Erase element on index <code>i</code>. Call to this function can cause reorderingof an dynamic array. Allocated memory is kept even if we erase entire dynamic array. Function invoke panic in case of index overflow.</p>
<hr />
<h2 id="array_clear">array_clear</h2>
<pre><code>array_clear :: fn (_arr: *[..]?T)  #inline</code></pre>
<p>Erase all elements in dynamic array but keep allocated memory.</p>
<hr />
<h1 id="debug">Debug</h1>
<p><code>#load "std/debug.bl"</code></p>
<p>Set of common debugging tools. <span class="citation" data-cites="Incomplete">@Incomplete</span>: documentation of <code>debugbreak</code> builtin. ## print_log</p>
<pre><code>print_log :: fn (format: string, args: ...)  #inline</code></pre>
<p>Print debug log using <code>_context.print_log_fn</code> function. See also :ref:<code>print</code>.</p>
<hr />
<h2 id="print_warn">print_warn</h2>
<pre><code>print_warn :: fn (format: string, args: ...)  #inline</code></pre>
<p>Print debug warning using <code>_context.print_log_fn</code> function.</p>
<hr />
<h2 id="print_err">print_err</h2>
<pre><code>print_err :: fn { print_err_e; print_err_msg; }</code></pre>
<p>Print debug error using _context.print_log_fn function.</p>
<hr />
<h2 id="assert">assert</h2>
<pre><code>assert :: fn (cond: bool, loc :: ) </code></pre>
<p>Interrupt execution when <code>cond</code> is false. Assert use <code>_context.print_log_fn</code> to print out error message containing assert location in source code.</p>
<p><strong>important</strong>: All calls to the assert function are removed from release builds by default.</p>
<p><strong>warning</strong>: There is no argument validation in case the assert call is removed from compilation.</p>
<hr />
<h2 id="static_assert">__static_assert</h2>
<pre><code>__static_assert :: fn (expr: bool) </code></pre>
<p>Compiler internal static assert handler, this is supposed to be used via #assert directive, not directly.</p>
<hr />
<h2 id="panic">panic</h2>
<pre><code>panic :: fn { panic_empty; panic_error; panic_msg; }</code></pre>
<p>Abort execution and eventually print panic message if there is one specified. First passed argument in ‘args’ will act like format string and can be eventually followed by any additional values required.</p>
<h3 id="example-6">Example</h3>
<pre><code>panic(); // abort without any messages
panic(error); // abort with :ref:`Error`.
panic(&quot;oops!&quot;); // abort with message prited out.
panic(&quot;Failed with error: %&quot;, errn); // first argument passed acts like formating string</code></pre>
<hr />
<h2 id="printlogkind">PrintLogKind</h2>
<pre><code>PrintLogKind :: enum u8 {
    Message;
    Warning;
    Error;
    Assert;
    Panic;
}</code></pre>
<p>Kinds of log messages.</p>
<h3 id="variants-4">Variants</h3>
<p><strong>Message</strong> - Ordinary debug log message.</p>
<p><strong>Warning</strong> - Warning log message.</p>
<p><strong>Error</strong> - Error log message.</p>
<p><strong>Assert</strong> - Assert log message.</p>
<p><strong>Panic</strong> - Panic log message.</p>
<hr />
<h2 id="print_log_default">__print_log_default</h2>
<pre><code>__print_log_default :: fn (kind: PrintLogKind, file: string, line: s32, format: string, args: ...) </code></pre>
<hr />
<h2 id="measure_elapsed_ms_begin">measure_elapsed_ms_begin</h2>
<pre><code>measure_elapsed_ms_begin :: fn ()  #inline</code></pre>
<p>Start measure elapsed milliseconds in the current scope. This function call will push the current time into the thread-local queue. Measurement must be ended by :ref:<code>measure_elapsed_ms_end</code> call.</p>
<h3 id="example-7">Example</h3>
<pre><code>measure_elapsed_ms_begin();
defer measure_elapsed_ms_end(&quot;Name&quot;);</code></pre>
<p><strong>warning</strong>: Every <code>measure_elapsed_ms_begin</code> must have corresponding <a href="#measure_elapsed_ms_end">measure_elapsed_ms_end</a> call.</p>
<hr />
<h2 id="measure_elapsed_ms_end">measure_elapsed_ms_end</h2>
<pre><code>measure_elapsed_ms_end :: fn (name :: ) f64 #inline</code></pre>
<p>Pop the last start time from the runtime measurement queue and log the result time difference when the name is specified. Function return time difference between the current time and last start time.</p>
<hr />
<h1 id="debug-allocator">Debug Allocator</h1>
<p><code>#import "std/debug_allocator"</code></p>
<p>Debug allocator can be used to analyze memory usage of program and eventually analyze possible memory leaks. By <a href="#init">init</a> call the global <code>context</code> allocator is replaced by debug allocator, every following allocations are recorded and analyzed in runtime since then. Call <a href="#terminate">terminate</a> to swap default context allocator back to previous one.</p>
<h3 id="example-8">Example</h3>
<pre><code>#import &quot;std/debug_allocator&quot;

main :: fn () s32 {
    DebugAllocator.init();
    defer DebugAllocator.terminate();

    // leaking allocation
    alloc(64);
    return 0;
}</code></pre>
<pre class="text"><code>$ ./out.exe
******************* MEMORY REPORT ******************
* Allocated 64 Bytes.
* Count of allocations 1.
****************************************************
Dump memory leaks begin:
    [1] - test.bl:10 (64 bytes)
Dump memory leaks end.</code></pre>
<p><strong>note</strong>: Debug allocator is thread safe. Init and terminate must be called from main thread. ## debug_allocator</p>
<pre><code>debug_allocator :: </code></pre>
<hr />
<h2 id="init">init</h2>
<pre><code>init :: fn () </code></pre>
<p>Initialize Debug Allocator. This function internally swap current global context allocator to debug one. Deinitialization must be done by <a href="#terminate">terminate</a> call.</p>
<hr />
<h2 id="terminate">terminate</h2>
<pre><code>terminate :: fn (print_report :: ) </code></pre>
<p>Terminate Debug Allocator. Prints current memory report when <a href="#print_report">print_report</a> is <code>true</code>.</p>
<hr />
<h2 id="break_on">break_on</h2>
<pre><code>break_on :: fn (serial: u64)  #inline</code></pre>
<p>Invoke <a href="#debug_break">debug_break</a> before allocation with defined serial ID. <strong>note</strong>: See also <a href="#print_memory_report">print_memory_report</a></p>
<hr />
<h2 id="allocated_bytes">allocated_bytes</h2>
<pre><code>allocated_bytes :: fn () usize #inline</code></pre>
<p>Return currently allocated memory in bytes.</p>
<hr />
<h2 id="print_memory_report">print_memory_report</h2>
<pre><code>print_memory_report :: fn (dump_leaks :: ) </code></pre>
<p>Print memory report. First block contains currently allocated bytes and current count of allocations. Optional memory leak dump block (enabled by <code>dump_leaks</code> argument) contains:</p>
<pre class="text"><code>[allocation serial ID] - &lt;file&gt;:&lt;line&gt; (allocation size in bytes) </code></pre>
<pre class="text"><code>$ ./out.exe
******************* MEMORY REPORT ******************
* Allocated 64 Bytes.
* Count of allocations 1.
****************************************************
Dump memory leaks begin:
    [1] - test.bl:10 (64 bytes)
Dump memory leaks end.</code></pre>
<p><strong>note</strong>: Printed report contains all remaining (not freed) allocations in time when function was called. Memory leaks can contain false-positives when function is called before execution end.</p>
<p><strong>hint</strong>: Allocation serail ID can be used by <a href="#break_on">break_on</a> to interrupt execution before memory is allocated and eventually localize allocation in debbuger.</p>
<hr />
<h1 id="dynamic-library-tools">Dynamic Library Tools</h1>
<p><code>#import "std/dlib"</code></p>
<p>Dynamic library tools for runtime library loading and symbol resolving. ## Library</p>
<pre><code>Library :: _DlibImpl.Library</code></pre>
<p>Platform specific library handle.</p>
<hr />
<h2 id="open-2">open</h2>
<pre><code>open :: fn (lib_name :: ) (_0: Library, _1: Error
) #inline</code></pre>
<p>Dynamically loads library specified by <code>lib_name</code> and return it’s handle or null with error. When <code>lib_name</code> is empty, current binary will be loaded. Use <a href="#close">close</a> call to close library when it’s not needed anymore.</p>
<hr />
<h2 id="get_symbol">get_symbol</h2>
<pre><code>get_symbol :: fn (lib: Library, sym_name: string) (_0: *u8, _1: Error
) #inline</code></pre>
<p>Resolve named symbol in library and return pointer to it.</p>
<hr />
<h2 id="close-1">close</h2>
<pre><code>close :: fn (lib: Library)  #inline</code></pre>
<p>Close library opened by <a href="#open">open</a> call.</p>
<hr />
<h1 id="error-handling">Error handling</h1>
<p><code>#load "std/error.bl"</code></p>
<pre><code>_Error :: struct {
    msg: string;
    code: s32;
}

Error :: *_Error;</code></pre>
<p>Universal error state representation used across the API.</p>
<h3 id="example-9">Example</h3>
<pre><code>div :: fn (a: s32, b: s32) (s32, Error) {
    if b == 0 {
        // Return error with message.
        return 0, error(&quot;Divide by zero &#39;%/%&#39;!&quot;, a, b);
    }
    // Return result and OK state.
    return a / b, ok();
}

main :: fn () s32 {
    loop i := -5; i &lt;= 5; i += 1 {
        result, error :: div(10, i);
        if is_ok(error) {
            print(&quot;Result is %.\n&quot;, result);
        } else {
            print(&quot;Error: %.\n&quot;, error);
        }
    }
    return 0;
}</code></pre>
<h2 id="ok">OK</h2>
<pre><code>OK :: 0</code></pre>
<hr />
<h2 id="error">_Error</h2>
<pre><code>_Error :: struct {
    msg: string;
    code: s32;
}</code></pre>
<hr />
<h2 id="error-1">Error</h2>
<pre><code>Error :: *_Error</code></pre>
<hr />
<h2 id="is_ok">is_ok</h2>
<pre><code>is_ok :: fn (err: Error) bool #inline</code></pre>
<p>Check whether <code>err</code> is no-error valid state. Returns <code>false</code> when <code>err</code> is <code>null</code>.</p>
<hr />
<h2 id="is_error">is_error</h2>
<pre><code>is_error :: fn (err: Error, code: s32) bool #inline</code></pre>
<p>Check whether <code>err</code> is representing error <code>code</code>. Returns <code>false</code> when <code>err</code> is <code>null</code>.</p>
<hr />
<h2 id="ok-1">ok</h2>
<pre><code>ok :: fn () Error #inline</code></pre>
<p>Creates no-error :ref:<code>Error</code>.</p>
<hr />
<h2 id="error-2">error</h2>
<pre><code>error :: fn { error1; error2; error3; }</code></pre>
<p>Overloaded function setting up error state. Error state is global variable holding :ref:<code>Error</code> instance, <code>error</code> function sets desired values and return pointer to this global. That means the <code>Error</code> must be handled immediately after it’s returned from failing function since every <code>Error</code> state points to the same memory.</p>
<p>Error creating does not require any HEAP memory alocations.</p>
<pre><code>fn (code: s32) Error #inline</code></pre>
<p>Sets error code.</p>
<hr />
<pre><code>fn (format: string, args: ...) Error #inline</code></pre>
<p>Sets error state with <code>ERR_UNKNOWN</code> code and formatted message.</p>
<hr />
<pre><code>fn (code: s32, format: string, args: ...) Error</code></pre>
<p>Sets error state with <code>code</code> and formatted message.</p>
<hr />
<h1 id="file-system">File System</h1>
<p><code>#import "std/fs"</code></p>
<p>File system module for manipulation with files and directories. This module provides an abstraction over operating system APIs such as creating files and directories, reading and writing, and scanning the filesystem. ## File</p>
<pre><code>File :: _FsImpl.File</code></pre>
<p>File handle type.</p>
<hr />
<h2 id="file_invalid">FILE_INVALID</h2>
<pre><code>FILE_INVALID :: _FsImpl.FILE_INVALID</code></pre>
<p>Invalid file handle. This can be used for file handle validation.</p>
<hr />
<h2 id="openmode">OpenMode</h2>
<pre><code>OpenMode :: enum {
    Read;
    Write;
    Append;
    Create;
}</code></pre>
<p>Specify operation with opened file.</p>
<h3 id="variants-5">Variants</h3>
<p><strong>Read</strong> - Open file for reading.</p>
<p><strong>Write</strong> - Open file for writing and truncate its content.</p>
<p><strong>Append</strong> - Open file for appending (keeps current content).</p>
<p><strong>Create</strong> - Create file if it does not exist.</p>
<hr />
<h2 id="copyopt">CopyOpt</h2>
<pre><code>CopyOpt :: struct {
    recursive: bool;
    override: bool;
    skip_existing: bool;
}</code></pre>
<p>Specify behavior of <a href="#dircopy">dir_copy</a>.</p>
<h3 id="members-18">Members</h3>
<p><strong>recursive</strong> - Copy all directories and sub-directories.</p>
<p><strong>override</strong> - Override existing entries.</p>
<p><strong>skip_existing</strong> - Skip already existing entries.</p>
<hr />
<h2 id="infokind">InfoKind</h2>
<pre><code>InfoKind :: enum {
    File;
    Directory;
}</code></pre>
<p>Specify kind of file system entry.</p>
<hr />
<h2 id="info">Info</h2>
<pre><code>Info :: struct {
    kind: InfoKind;
    name: string;
}</code></pre>
<p>Helper container to hold information about file system entry.</p>
<hr />
<h2 id="infolist">InfoList</h2>
<pre><code>InfoList :: []Info</code></pre>
<hr />
<h2 id="exist">exist</h2>
<pre><code>exist :: fn (filepath: string) bool #inline</code></pre>
<p>Check whether file or directory exists.</p>
<hr />
<h2 id="open-3">open</h2>
<pre><code>open :: fn (filepath: string, mode: ...OpenMode) (_0: File, _1: Error
) #inline</code></pre>
<p>Open an file specified by <code>filepath</code>. Function return file handle and <code>OK</code> status when file was opened, otherwise return invalid handle and proper error. File must be closed by <a href="#close">close</a> call.</p>
<p>File open <code>mode</code> is optional, any combination of <a href="#openmode">OpenMode</a> can be used. When <code>Create</code> <code>mode</code> is specified, new file is created on <code>filepath</code> only if it does not exist, otherwise already existing file is used. <code>Read</code> <code>mode</code> is used as default when neither <code>Read</code>, <code>Write</code> or <code>Append</code> is specified.</p>
<h3 id="example-10">Example</h3>
<pre><code>#import &quot;std/fs&quot;

main :: fn () s32 {
    file, err :: Fs.open(#file);
    defer Fs.close(file);
    if !is_ok(err) {
        print_err(&quot;%&quot;, err);
        return 1;
    }
    return 0;
}</code></pre>
<p>**todo*: Mode should be passed as flags in the future.</p>
<hr />
<h2 id="close-2">close</h2>
<pre><code>close :: fn (handle: File)  #inline</code></pre>
<p>Close previously openned file. Does nothing when <code>handle</code> is not valid.</p>
<hr />
<h2 id="get_uid">get_uid</h2>
<pre><code>get_uid :: fn { _FsImpl.get_uid; _FsImpl.get_uid_by_name; }</code></pre>
<p><span class="citation" data-cites="INCOMPLETE">@INCOMPLETE</span></p>
<hr />
<h2 id="remove">remove</h2>
<pre><code>remove :: fn (filepath: string) Error #inline</code></pre>
<p>Try to remove file specified by <code>filepath</code> and return <code>OK</code> on success, otherwise return error.</p>
<hr />
<h2 id="copy">copy</h2>
<pre><code>copy :: fn (src: string, dest: string, override :: ) Error #inline</code></pre>
<p>Copy existing file from <code>src</code> to <code>dest</code> and override existing file in destination if <code>override</code> is true. Return <code>ok</code> or <code>error</code>.</p>
<p><strong>note</strong>: <code>src</code> and <code>dest</code> path can be relative path to current working path set by <a href="#set_cwd">set_cwd</a>.</p>
<hr />
<h2 id="dir_copy">dir_copy</h2>
<pre><code>dir_copy :: fn (src: string, dest: string, opt : *CopyOpt: , filter : DirScanFilterFn: ) (_0: s64, _1: Error
)</code></pre>
<p>Copy from <code>src</code> path to <code>dest</code> path with specified <code>opt</code> options and return count of processed files or error.</p>
<h3 id="example-11">Example:</h3>
<pre><code>#import &quot;std/fs&quot;

main :: fn () s32 {
    // Copy options
    opt: Fs.CopyOpt;
    // Create destination directory if not exist.
    opt.recursive = true;
    // Override all existing entries.
    opt.override = true;

    // Copy content of &#39;foo&#39; into &#39;bar&#39;
    c, err :: Fs.dir_copy(&quot;foo&quot;, &quot;bar&quot;, &amp;opt, &amp;fn (item: *Fs.Info) bool {
        // Filter only txt files
        if String.compare(Fs.get_extension(item.name), &quot;txt&quot;) { return true; } 
        return false;
    });
    if !is_ok(err) { print(&quot;%\n&quot;, err); }
    else { print(&quot;Copied % files!\n&quot;, c); }
    return 0;
}</code></pre>
<p><span class="citation" data-cites="INCOIMPLETE">@INCOIMPLETE</span> Is using current dir + better descriptions.</p>
<hr />
<h2 id="size">size</h2>
<pre><code>size :: fn (handle: File) (_0: usize, _1: Error
) #inline</code></pre>
<p>Return file content size in bytes and <code>OK</code> status on success, otherwise return zero and proper error.</p>
<hr />
<h2 id="read_string">read_string</h2>
<pre><code>read_string :: fn (handle: File) (_0: string, _1: Error
)</code></pre>
<p>Read whole file content into string. Return new string instance containing file data and <code>OK</code> status on success, otherwise return empty string and error. Returned string is expected to be released by <code>String.delete</code> call if there was no error reported by function. Result string is zero terminated even if file is empty.</p>
<h3 id="example-12">Example</h3>
<pre><code>#import &quot;std/fs&quot;

main :: fn () s32 {
    // Open this file.
    file, open_err :: Fs.open(#file, Fs.OpenMode.Read);

    // Always check for errors.
    if !is_ok(open_err) {
        panic(&quot;Cannot open file with error: &#39;%&#39;!&quot;, open_err);
    }
    // Close file at the end of scope.
    defer Fs.close(file);

    // Read it&#39;s content.
    content, read_err :: Fs.read_string(file);

    // Check for errors.
    if !is_ok(read_err) {
        panic(&quot;Cannot read file with error: &#39;%&#39;!&quot;, read_err);
    }
    // Delete content string at the end of scope.
    defer String.delete(content);

    // Print file content to stdout.
    print(&quot;%\n&quot;, content);
    return 0;
}</code></pre>
<hr />
<h2 id="read_slice">read_slice</h2>
<pre><code>read_slice :: fn (handle: File) (_0: []u8, _1: Error
)</code></pre>
<p>Read whole file content into slice array. Return new slice instance containting file data and <code>OK</code> status on success, otherwise return empty slice and error. Returned slice is expected to be released by :ref:<code>slice_terminate</code> call if there was no error reported by function.</p>
<hr />
<h2 id="read-2">read</h2>
<pre><code>read :: fn (handle: File, dest: *u8, size: s64) (_0: s64, _1: Error
) #inline</code></pre>
<p>Read <code>size</code> bytes from file into raw <code>dest</code> buffer. Return count of bytes written into buffer and <code>OK</code> status when there was no error. <code>dest</code> buffer must be allocated to handle at least <code>size</code> bytes. There is no overflow check.</p>
<hr />
<h2 id="write-2">write</h2>
<pre><code>write :: fn (handle: File, src: *u8, size: s64) (_0: s64, _1: Error
) #inline</code></pre>
<p>Write <code>size</code> bytes from raw buffer <code>src</code> into the file. Return count of bytes written into the buffer and <code>OK</code> on success, otherwise return error. The <code>src</code> buffer size must be at least <code>size</code> bytes. No overflow checking is done.</p>
<hr />
<h2 id="write_string">write_string</h2>
<pre><code>write_string :: fn (handle: File, str: string) (_0: s64, _1: Error
) #inline</code></pre>
<p>Write content of <code>str</code> into the file, return count of written bytes and <code>OK</code> if there is no error, otherwise return 0 and error.</p>
<hr />
<h2 id="write_fmt">write_fmt</h2>
<pre><code>write_fmt :: fn { fn (buf_size: s32, handle: File, fmt: string, args: ...) (_0: s64, _1: Error
); fn (handle: File, fmt: string, args: ...) (_0: s64, _1: Error
); } #inline</code></pre>
<hr />
<h2 id="write_slice">write_slice</h2>
<pre><code>write_slice :: fn (handle: File, v: []u8, count : s64: -1) (_0: s64, _1: Error
) #inline</code></pre>
<p>Write content of <code>v</code> slice into the file, return count of written bytes and <code>OK</code> if there is no error, otherwise return 0 and error. Optional argument <code>count</code> specify count of bytes from <code>v</code> to be written, negative value means whole content. When passed count is greater than <code>v.len</code>, count value is set to <code>v.len</code>.</p>
<hr />
<h2 id="dir_create">dir_create</h2>
<pre><code>dir_create :: fn (dirpath: string) Error #inline</code></pre>
<p>Create new directory and return <code>OK</code> on success. This function does not create directories recursively.</p>
<hr />
<h2 id="dir_create_all">dir_create_all</h2>
<pre><code>dir_create_all :: fn (dirpath: string) Error</code></pre>
<hr />
<h2 id="dir_remove">dir_remove</h2>
<pre><code>dir_remove :: fn (dirpath: string) Error #inline</code></pre>
<p>Remove directory specified by <code>dirpath</code> and return <code>OK</code> on success, otherwise return an error.</p>
<hr />
<h2 id="dir_remove_all">dir_remove_all</h2>
<pre><code>dir_remove_all :: fn (dirpath: string, remove_root :: , filter : DirScanFilterFn: ) Error</code></pre>
<p>Remove non-empty directory specified by <code>dirpath</code> and return <code>OK</code> on success, otherwise return an error. Root directory is removed if <code>remove_root</code> is <code>true</code>. Custom file <code>filter</code> function can be specified as needed.</p>
<p><strong>note</strong>: This function recursively remove all nested folders and files in specified sub tree so it can be expensive.</p>
<hr />
<h2 id="is_directory">is_directory</h2>
<pre><code>is_directory :: fn (path: string) (_0: bool, _1: Error
) #inline</code></pre>
<p>Check whether <code>path</code> points to valid directory and return true with <code>OK</code> state, otherwise return <code>false</code> and error.</p>
<hr />
<h2 id="dirscanfilterfn">DirScanFilterFn</h2>
<pre><code>DirScanFilterFn :: *fn (info: *Info) bool</code></pre>
<p>Type of <code>dir_scan</code> filter function.</p>
<hr />
<h2 id="dir_scan">dir_scan</h2>
<pre><code>dir_scan :: fn (dirpath: string, filter : DirScanFilterFn: ) (_0: InfoList, _1: Error
) #inline</code></pre>
<p>Scan <code>dirpath</code> directory and return list of information for every file system entry found on success. Otherwise return empty list and error. Use <a href="#info_list_delete">info_list_delete</a> to release list when there was no error reported by this function.</p>
<p>Optional <code>filter</code> funtion <a href="#dirscanfilterfn">DirScanFilterFn</a> can be used to filter scan results directly during scanning, it’s called for every found entry and only those for whose filter yields true are added into the output list.</p>
<hr />
<h2 id="info_list_delete">info_list_delete</h2>
<pre><code>info_list_delete :: fn (list: InfoList)  #inline</code></pre>
<p>Release allocated file system entry info list.</p>
<hr />
<h2 id="validate_filename">validate_filename</h2>
<pre><code>validate_filename :: fn (name: string) bool #inline</code></pre>
<p>Checks whether <code>name</code> is valid file name on current platform.</p>
<hr />
<h2 id="get_cwd">get_cwd</h2>
<pre><code>get_cwd :: fn () string #inline</code></pre>
<p>Try to obtain current working directory, result must be released by <code>String.delete</code>. Path does not contain last path separator.</p>
<hr />
<h2 id="set_cwd">set_cwd</h2>
<pre><code>set_cwd :: fn (path: string) Error #inline</code></pre>
<p>Sets current working directory and return <code>OK</code> on success, otherwise return error.</p>
<hr />
<h2 id="get_home">get_home</h2>
<pre><code>get_home :: fn () string #inline</code></pre>
<p>Try to obtain system home directory, result must be released by <code>String.delete</code>. Path does not contain last path separator.</p>
<hr />
<h2 id="get_tmp">get_tmp</h2>
<pre><code>get_tmp :: fn () string #inline</code></pre>
<p>Try to obtain system temporary directory, result must be released by <code>String.delete</code>. Path does not contain last path separator.</p>
<hr />
<h2 id="normalize">normalize</h2>
<pre><code>normalize :: fn (filepath: *string) Error #inline</code></pre>
<p>Try to normalize <code>filepath</code>, basically try to remove all relative path nodes <code>..</code> and <code>.</code>. Path must be valid path (existing) on system. Original <code>filepath</code> is extended with current working directory. Function return <code>OK</code> on success or proper error on fail. Original string is not modified when error occurs.</p>
<hr />
<h2 id="remove_extension">remove_extension</h2>
<pre><code>remove_extension :: fn (filename: string) string #inline</code></pre>
<p>Remove file extension (token after first <code>.</code>) from the <code>filename</code> and return the rest. Function does not create copy of original <code>filepath</code>.</p>
<hr />
<h2 id="get_extension">get_extension</h2>
<pre><code>get_extension :: fn (filename: string) string #inline</code></pre>
<p>Get file extension (token after first <code>.</code>) from the <code>filename</code>. Function does not create copy of original <code>filepath</code>. The <code>.</code> separator is not included into result string.</p>
<hr />
<h2 id="get_directory">get_directory</h2>
<pre><code>get_directory :: fn (filepath: string) string #inline</code></pre>
<p>Get directory path from filepath. Function supports only unix path delimiters. Returns empty string in case path was not found.</p>
<hr />
<p>=== GLM ===</p>
<p>::</p>
<pre><code>#import &quot;std/glm&quot;</code></pre>
<p>3D math tools. ## v2</p>
<pre><code>v2 :: struct {
    x: f32;
    y: f32;
}</code></pre>
<hr />
<h2 id="v2_one">v2_one</h2>
<pre><code>v2_one :: </code></pre>
<hr />
<h2 id="v2_zero">v2_zero</h2>
<pre><code>v2_zero :: </code></pre>
<hr />
<h2 id="v3">v3</h2>
<pre><code>v3 :: struct {
    x: f32;
    y: f32;
    z: f32;
}</code></pre>
<hr />
<h2 id="v3_right">v3_right</h2>
<pre><code>v3_right :: </code></pre>
<hr />
<h2 id="v3_up">v3_up</h2>
<pre><code>v3_up :: </code></pre>
<hr />
<h2 id="v3_forward">v3_forward</h2>
<pre><code>v3_forward :: </code></pre>
<hr />
<h2 id="v3_one">v3_one</h2>
<pre><code>v3_one :: </code></pre>
<hr />
<h2 id="v3_zero">v3_zero</h2>
<pre><code>v3_zero :: </code></pre>
<hr />
<h2 id="v4">v4</h2>
<pre><code>v4 :: struct {
    x: f32;
    y: f32;
    z: f32;
    w: f32;
}</code></pre>
<hr />
<h2 id="v4_one">v4_one</h2>
<pre><code>v4_one :: </code></pre>
<hr />
<h2 id="v4_zero">v4_zero</h2>
<pre><code>v4_zero :: </code></pre>
<hr />
<h2 id="color_white">color_white</h2>
<pre><code>color_white :: </code></pre>
<hr />
<h2 id="color_black">color_black</h2>
<pre><code>color_black :: </code></pre>
<hr />
<h2 id="color_red">color_red</h2>
<pre><code>color_red :: </code></pre>
<hr />
<h2 id="color_green">color_green</h2>
<pre><code>color_green :: </code></pre>
<hr />
<h2 id="color_blue">color_blue</h2>
<pre><code>color_blue :: </code></pre>
<hr />
<h2 id="color_yellow">color_yellow</h2>
<pre><code>color_yellow :: </code></pre>
<hr />
<h2 id="iv2">iv2</h2>
<pre><code>iv2 :: struct {
    x: s32;
    y: s32;
}</code></pre>
<hr />
<h2 id="iv3">iv3</h2>
<pre><code>iv3 :: struct {
    x: s32;
    y: s32;
    z: s32;
}</code></pre>
<hr />
<h2 id="mat4">mat4</h2>
<pre><code>mat4 :: </code></pre>
<hr />
<h2 id="quat">quat</h2>
<pre><code>quat :: v4</code></pre>
<hr />
<h2 id="quat_identity">quat_identity</h2>
<pre><code>quat_identity :: </code></pre>
<hr />
<h2 id="v_sub">v_sub</h2>
<pre><code>v_sub :: fn { v2_sub; v2_sub_s; v3_sub; v3_sub_s; v4_sub; v4_sub_s; }</code></pre>
<hr />
<h2 id="v_add">v_add</h2>
<pre><code>v_add :: fn { v2_add; v2_add_s; v3_add; v3_add_s; v4_add; v4_add_s; }</code></pre>
<hr />
<h2 id="v_mul">v_mul</h2>
<pre><code>v_mul :: fn { v2_mul; v2_mul_s; v3_mul; v3_mul_s; v4_mul; v4_mul_s; }</code></pre>
<hr />
<h2 id="v_div">v_div</h2>
<pre><code>v_div :: fn { v2_div; v2_div_s; v3_div; v3_div_s; v4_div; v4_div_s; }</code></pre>
<hr />
<h2 id="v_length">v_length</h2>
<pre><code>v_length :: fn { v2_length; v3_length; v4_length; }</code></pre>
<hr />
<h2 id="v_sqr_lenght">v_sqr_lenght</h2>
<pre><code>v_sqr_lenght :: fn { v2_sqr_lenght; v3_sqr_lenght; v4_sqr_lenght; }</code></pre>
<hr />
<h2 id="v_dot">v_dot</h2>
<pre><code>v_dot :: fn { v2_dot; v3_dot; v4_dot; }</code></pre>
<hr />
<h2 id="v_normalize">v_normalize</h2>
<pre><code>v_normalize :: fn { v2_normalize; v3_normalize; v4_normalize; }</code></pre>
<hr />
<h2 id="v_compare">v_compare</h2>
<pre><code>v_compare :: fn { v2_compare; v3_compare; v4_compare; }</code></pre>
<hr />
<h2 id="v_negate">v_negate</h2>
<pre><code>v_negate :: fn { v2_negate; v3_negate; v4_negate; }</code></pre>
<hr />
<h2 id="v_cross">v_cross</h2>
<pre><code>v_cross :: fn { v3_cross; }</code></pre>
<hr />
<h2 id="v_round">v_round</h2>
<pre><code>v_round :: fn { v2_round; v3_round; v4_round; }</code></pre>
<hr />
<h2 id="v_floor">v_floor</h2>
<pre><code>v_floor :: fn { v2_floor; v3_floor; v4_floor; }</code></pre>
<hr />
<h2 id="v_ceil">v_ceil</h2>
<pre><code>v_ceil :: fn { v2_ceil; v3_ceil; v4_ceil; }</code></pre>
<hr />
<h2 id="mat4_init">mat4_init</h2>
<pre><code>mat4_init :: fn (m00: f32, m10: f32, m20: f32, m30: f32, m01: f32, m11: f32, m21: f32, m31: f32, m02: f32, m12: f32, m22: f32, m32: f32, m03: f32, m13: f32, m23: f32, m33: f32, out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_identity">mat4_identity</h2>
<pre><code>mat4_identity :: fn (out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_zero">mat4_zero</h2>
<pre><code>mat4_zero :: fn (out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_perspective">mat4_perspective</h2>
<pre><code>mat4_perspective :: fn (fov_rad: f32, aspect: f32, near: f32, far: f32, out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_ortho">mat4_ortho</h2>
<pre><code>mat4_ortho :: fn (left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32, out_mat: *mat4) </code></pre>
<hr />
<h2 id="mat4_look_at">mat4_look_at</h2>
<pre><code>mat4_look_at :: fn (eye: v3, target: v3, up: v3, out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_mul">mat4_mul</h2>
<pre><code>mat4_mul :: fn (a: *mat4, b: *mat4, out_mat: *mat4) </code></pre>
<hr />
<h2 id="mat4_inverse">mat4_inverse</h2>
<pre><code>mat4_inverse :: fn (src_mat: *mat4, out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_scale_s">mat4_scale_s</h2>
<pre><code>mat4_scale_s :: fn (s: f32, out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_mul_v4">mat4_mul_v4</h2>
<pre><code>mat4_mul_v4 :: fn (mat: *mat4, v: v4) v4 #inline</code></pre>
<hr />
<h2 id="mat4_translation">mat4_translation</h2>
<pre><code>mat4_translation :: fn (translation: v3, out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_scale">mat4_scale</h2>
<pre><code>mat4_scale :: fn (s: v3, out_mat: *mat4)  #inline</code></pre>
<hr />
<h2 id="mat4_get_scale">mat4_get_scale</h2>
<pre><code>mat4_get_scale :: fn (mat: *mat4) v3</code></pre>
<hr />
<h2 id="mat4_get_translation">mat4_get_translation</h2>
<pre><code>mat4_get_translation :: fn (mat: *mat4) v3 #inline</code></pre>
<hr />
<h2 id="mat4_get_quat">mat4_get_quat</h2>
<pre><code>mat4_get_quat :: fn (mat: *mat4) quat</code></pre>
<hr />
<h2 id="quat_normalize">quat_normalize</h2>
<pre><code>quat_normalize :: fn (q: quat) quat #inline</code></pre>
<hr />
<h2 id="quat_to_mat4">quat_to_mat4</h2>
<pre><code>quat_to_mat4 :: fn (q: quat, out_mat: *mat4) </code></pre>
<hr />
<h2 id="quat_look">quat_look</h2>
<pre><code>quat_look :: fn (eye: v3, ori: quat, out_mat: *mat4) </code></pre>
<hr />
<h2 id="quat_look_for">quat_look_for</h2>
<pre><code>quat_look_for :: fn (dir: v3, fwd: v3, up: v3) quat</code></pre>
<hr />
<h2 id="quat_axis_angle">quat_axis_angle</h2>
<pre><code>quat_axis_angle :: fn (axis: v3, angle_rad: f32) quat</code></pre>
<hr />
<h2 id="quat_imag">quat_imag</h2>
<pre><code>quat_imag :: fn (q: quat) v3 #inline</code></pre>
<hr />
<h2 id="quat_real">quat_real</h2>
<pre><code>quat_real :: fn (q: quat) f32 #inline</code></pre>
<hr />
<h2 id="quat_mul">quat_mul</h2>
<pre><code>quat_mul :: fn (q1: quat, q2: quat) quat</code></pre>
<hr />
<h2 id="quat_rotate_v3">quat_rotate_v3</h2>
<pre><code>quat_rotate_v3 :: fn (q: quat, v: v3) v3</code></pre>
<hr />
<h2 id="quat_forward">quat_forward</h2>
<pre><code>quat_forward :: fn (q: quat) v3</code></pre>
<hr />
<h1 id="math">Math</h1>
<p><code>#load "std/math.bl"</code> ## PI</p>
<pre><code>PI :: </code></pre>
<hr />
<h2 id="two_pi">TWO_PI</h2>
<pre><code>TWO_PI :: </code></pre>
<hr />
<h2 id="half_pi">HALF_PI</h2>
<pre><code>HALF_PI :: </code></pre>
<hr />
<h2 id="f32_epsilon">F32_EPSILON</h2>
<pre><code>F32_EPSILON :: </code></pre>
<hr />
<h2 id="f64_epsilon">F64_EPSILON</h2>
<pre><code>F64_EPSILON :: </code></pre>
<hr />
<h2 id="s8_min">S8_MIN</h2>
<pre><code>S8_MIN : s8 : </code></pre>
<hr />
<h2 id="s8_max">S8_MAX</h2>
<pre><code>S8_MAX : s8 : 127</code></pre>
<hr />
<h2 id="s16_min">S16_MIN</h2>
<pre><code>S16_MIN : s16 : </code></pre>
<hr />
<h2 id="s16_max">S16_MAX</h2>
<pre><code>S16_MAX : s16 : 32767</code></pre>
<hr />
<h2 id="s32_min">S32_MIN</h2>
<pre><code>S32_MIN : s32 : </code></pre>
<hr />
<h2 id="s32_max">S32_MAX</h2>
<pre><code>S32_MAX : s32 : 2147483647</code></pre>
<hr />
<h2 id="s64_min">S64_MIN</h2>
<pre><code>S64_MIN : s64 : </code></pre>
<hr />
<h2 id="s64_max">S64_MAX</h2>
<pre><code>S64_MAX : s64 : 9223372036854775807</code></pre>
<hr />
<h2 id="u8_min">U8_MIN</h2>
<pre><code>U8_MIN : u8 : 0</code></pre>
<hr />
<h2 id="u8_max">U8_MAX</h2>
<pre><code>U8_MAX : u8 : 255</code></pre>
<hr />
<h2 id="u16_min">U16_MIN</h2>
<pre><code>U16_MIN : u16 : 0</code></pre>
<hr />
<h2 id="u16_max">U16_MAX</h2>
<pre><code>U16_MAX : u16 : 65535</code></pre>
<hr />
<h2 id="u32_min">U32_MIN</h2>
<pre><code>U32_MIN : u32 : 0</code></pre>
<hr />
<h2 id="u32_max">U32_MAX</h2>
<pre><code>U32_MAX : u32 : 4294967295</code></pre>
<hr />
<h2 id="u64_min">U64_MIN</h2>
<pre><code>U64_MIN : u64 : 0</code></pre>
<hr />
<h2 id="u64_max">U64_MAX</h2>
<pre><code>U64_MAX : u64 : 18446744073709551615</code></pre>
<hr />
<h2 id="sin">sin</h2>
<pre><code>sin :: fn { f32_sin; f64_sin; }</code></pre>
<hr />
<h2 id="cos">cos</h2>
<pre><code>cos :: fn { f32_cos; f64_cos; }</code></pre>
<hr />
<h2 id="asin">asin</h2>
<pre><code>asin :: fn { f32_asin; f64_asin; }</code></pre>
<hr />
<h2 id="acos">acos</h2>
<pre><code>acos :: fn { f32_acos; f64_acos; }</code></pre>
<hr />
<h2 id="floor">floor</h2>
<pre><code>floor :: fn { f32_floor; f64_floor; }</code></pre>
<hr />
<h2 id="round">round</h2>
<pre><code>round :: fn { f32_round; f64_round; }</code></pre>
<hr />
<h2 id="pow">pow</h2>
<pre><code>pow :: fn { f32_pow; f64_pow; }</code></pre>
<hr />
<h2 id="log">log</h2>
<pre><code>log :: fn { f32_log; f64_log; }</code></pre>
<hr />
<h2 id="log2">log2</h2>
<pre><code>log2 :: fn { f32_log2; f64_log2; }</code></pre>
<hr />
<h2 id="log10">log10</h2>
<pre><code>log10 :: fn { f32_log10; f64_log10; }</code></pre>
<hr />
<h2 id="sqrt">sqrt</h2>
<pre><code>sqrt :: fn { f32_sqrt; f64_sqrt; }</code></pre>
<hr />
<h2 id="ceil">ceil</h2>
<pre><code>ceil :: fn { f32_ceil; f64_ceil; }</code></pre>
<hr />
<h2 id="tan">tan</h2>
<pre><code>tan :: fn { f32_tan; f64_tan; }</code></pre>
<hr />
<h2 id="atan2">atan2</h2>
<pre><code>atan2 :: fn { f32_atan2; f64_atan2; }</code></pre>
<hr />
<h2 id="copysign">copysign</h2>
<pre><code>copysign :: fn { f32_copysign; f64_copysign; }</code></pre>
<hr />
<h2 id="rand">rand</h2>
<pre><code>rand :: fn () s32 #extern</code></pre>
<hr />
<h2 id="srand">srand</h2>
<pre><code>srand :: fn (seed: u32)  #extern</code></pre>
<hr />
<h2 id="qsort">qsort</h2>
<pre><code>qsort :: fn (base: *c_void_ptr, nitems: c_size_t, size: c_size_t, compar: *fn (: c_void_ptr, : c_void_ptr) c_int)  #extern</code></pre>
<hr />
<h2 id="abs">abs</h2>
<pre><code>abs :: fn { f32_abs; f64_abs; }</code></pre>
<hr />
<h2 id="compare">compare</h2>
<pre><code>compare :: fn { f32_compare; f64_compare; }</code></pre>
<hr />
<h2 id="degtorad">degtorad</h2>
<pre><code>degtorad :: fn { f32_degtorad; f64_degtorad; }</code></pre>
<hr />
<h2 id="radtodeg">radtodeg</h2>
<pre><code>radtodeg :: fn { f32_radtodeg; f64_radtodeg; }</code></pre>
<hr />
<h2 id="max">max</h2>
<pre><code>max :: fn (a: ?T, b: T) T #inline</code></pre>
<hr />
<h2 id="min">min</h2>
<pre><code>min :: fn (a: ?T, b: T) T #inline</code></pre>
<hr />
<h2 id="lerp">lerp</h2>
<pre><code>lerp :: fn (a: ?T, b: T, fraction: T) T #inline</code></pre>
<hr />
<h2 id="clamp">clamp</h2>
<pre><code>clamp :: fn (v: ?T, minimum: T, maximum: T) T</code></pre>
<hr />
<h1 id="memory">Memory</h1>
<pre><code>#load &quot;std/memory.bl&quot;</code></pre>
<p>Toolset for manipulation with system memory.</p>
<h2 id="memory-allocator">Memory allocator</h2>
<p>Memory allocators are used across the entire program to manage allocated memory resources used in runtime. Since memory allocation can be an expensive operation in some cases, it’s good to provide an explicit API, giving information enough to fix bugs, memory leaks and performance issues.</p>
<p>Memory allocator in BL world is just some context :ref:<code>Allocator</code> used by an allocator function, and allocator function itself <a href="#allocfn">AllocFn</a>. The allocator context can hold some data needed by allocator function and the allocator function is later used to make memory allocations and deallocations.</p>
<p>Functions like <a href="#alloc">alloc</a> and <a href="#free">free</a> internally use allocator set in global executable context <code>_context</code> variable. Global context allocator is by default set to <code>default_allocator</code> and can be changed as needed. Main goal of internal use of the allocator set in the global context (used across all modules) is to have full control over what’s going on and also give some advanced options to programmer (i.e. create his/her own allocator to have truly full control over memory management of the program). ## alloc</p>
<pre><code>alloc :: fn (size: usize, loc :: ) *u8</code></pre>
<p>Allocates <code>size</code> of bytes on heap using default allocator. Use <code>free</code> to free allocated memory when it’s no longer needed. Cause panic when allocation is not possible or <code>size</code> is zero. This function use allocator set in <code>_context.allocator</code></p>
<hr />
<h2 id="calloc">calloc</h2>
<pre><code>calloc :: fn (num: usize, size: usize, loc :: ) *u8</code></pre>
<p><span class="citation" data-cites="INCOMPLETE">@INCOMPLETE</span></p>
<hr />
<h2 id="free">free</h2>
<pre><code>free :: fn (ptr: *u8, loc :: ) </code></pre>
<p>Free memory allocated on heap. This function use allocator set in <code>_context.allocator</code> to free allocated data.</p>
<p><strong>warning</strong>: Memory block must be freed by same allocator as used for allocation.</p>
<p><strong>note</strong>: Does nothing when passed <code>ptr</code> is <code>null</code>.</p>
<hr />
<h2 id="memcpy">memcpy</h2>
<pre><code>memcpy :: fn (dest: *u8, src: *u8, size: usize) </code></pre>
<p>Copy memory of defined <code>size</code> from <code>src</code> to <code>dest</code>. Destination and source size must be at least <code>size</code> bytes.</p>
<hr />
<h2 id="memset">memset</h2>
<pre><code>memset :: fn (_dest: *u8, v: u8, size: usize) *u8</code></pre>
<p>Set memory to desired value. Destination size must be atleast <code>size</code> bytes.</p>
<hr />
<h2 id="init_default">init_default</h2>
<pre><code>init_default :: fn (dest: *?T) *T #inline</code></pre>
<hr />
<h2 id="swap">swap</h2>
<pre><code>swap :: fn (first: *?T, second: *T)  #inline</code></pre>
<p>Swaps content of memory at address <code>first</code> and <code>second</code>.</p>
<hr />
<h2 id="is_aligned">is_aligned</h2>
<pre><code>is_aligned :: fn (ptr: *?T, alignment: usize) bool #inline</code></pre>
<p>Checks whether passed pointer <code>ptr</code> is properly aligned by <code>alignment</code>.</p>
<hr />
<h2 id="align_ptr_up">align_ptr_up</h2>
<pre><code>align_ptr_up :: fn (p: *u8, alignment: usize) (p: *u8, adjustment: usize
)</code></pre>
<p>Align pointer <code>p</code> to <code>alignment</code> and return adjusted pointer and number of bytes needed for adjustment.</p>
<p><strong>warning</strong>: Cause panic when alignment is not power of two.</p>
<hr />
<h2 id="slice_init">slice_init</h2>
<pre><code>slice_init :: fn (slice: *[]?T, n: s64, loc :: ) </code></pre>
<p>Allocate heap memory for <code>n</code> elements in <code>_v</code> slice. Allocated block is set to zero default value. Allocated memory must be released by :ref:<code>slice_terminate</code> call.</p>
<p>This way of memory allocation cause some overhead compared to plain <code>alloc</code> due to conversion to <code>Any</code> and more ‘generic’ behaviour, also setting to 0 have some runtime cost. Consider use</p>
<h3 id="example-13">Example</h3>
<pre><code>main :: fn () s32 {
    // Allocate slice of 10 numbers
    sl: []s32;
    slice_init(&amp;sl, 10);

    loop i := 0; i &lt; sl.len; i += 1 {
        sl[i] = i;
    }

    // release memory allocated by init
    slice_terminate(&amp;sl);
    return 0;
}</code></pre>
<hr />
<h2 id="slice_terminate">slice_terminate</h2>
<pre><code>slice_terminate :: fn (slice: *[]?T, loc :: ) </code></pre>
<p>Release slice memory allocated by <a href="#slice_init">slice_init</a> call.</p>
<hr />
<h2 id="slice_range">slice_range</h2>
<pre><code>slice_range :: fn (slice: []?T, start: s64, end : s64: -1) []T #inline</code></pre>
<p>Create slice subset defined as range <code>&lt;start-index, end-index)</code>. Notice that <code>end</code> index is excluded from range, so <code>slice_range(other, 0, other.len)</code> is valid and returns new slice pointing to the same data as <code>other</code> slice, and with same size.</p>
<p>Indexing rules:</p>
<pre><code>start &gt;= 0
start &lt; slice.len
end &gt;= 0
end &lt;= slice.len</code></pre>
<p><strong>warning</strong>: Function cause panic in case combination of <code>start</code> and <code>end</code> is out of <code>slice</code> range.</p>
<hr />
<h2 id="allocop">AllocOp</h2>
<pre><code>AllocOp :: enum {
    Allocate;
    Free;
    Release;
}</code></pre>
<p>Specify allocator opratation.</p>
<h3 id="variants-6">Variants</h3>
<p><strong>Allocate</strong> - Allocation of new memory block is required.</p>
<p><strong>Free</strong> - Free of previously allocated memory is required.</p>
<p><strong>Release</strong> - Release of all allocated memory is required. This operation is optional and is not supported by all allocators.</p>
<hr />
<h2 id="allocator">Allocator</h2>
<pre><code>Allocator :: struct {
    handler: AllocFn;
}</code></pre>
<p>Default alloactor context base.</p>
<hr />
<h2 id="allocfn">AllocFn</h2>
<pre><code>AllocFn :: *fn (ctx: *Allocator, operation: AllocOp, size: usize, ptr : *u8: , file :: , line :: 0) *u8</code></pre>
<p>Allocator handle function type.</p>
<hr />
<h2 id="allocate_memory">allocate_memory</h2>
<pre><code>allocate_memory :: fn (allocator: *Allocator, size: usize, loc :: ) *u8 #inline</code></pre>
<p>Allocate memory directly using specified <code>allocator</code>.</p>
<hr />
<h2 id="free_memory">free_memory</h2>
<pre><code>free_memory :: fn (allocator: *Allocator, ptr: *u8, loc :: )  #inline</code></pre>
<p>Free memory previously allocated by specific <code>allocator</code>.</p>
<hr />
<h2 id="release_memory">release_memory</h2>
<pre><code>release_memory :: fn (allocator: *Allocator, loc :: )  #inline</code></pre>
<p>Release all memory allocated by <code>allocator</code>.</p>
<p><strong>warning</strong>: This operation is not supported by all allocators.</p>
<hr />
<h2 id="default_allocator">default_allocator</h2>
<pre><code>default_allocator :: </code></pre>
<p>Default memory allocator using libc malloc internally.</p>
<hr />
<h1 id="print">Print</h1>
<p><code>#import "std/print"</code></p>
<p>Printing functions collection. ## PRINT_MAX_LENGTH</p>
<pre><code>PRINT_MAX_LENGTH :: 4096</code></pre>
<p>Size of buffer used by <code>print</code> function, this is maximum text length which can be printed at once.</p>
<hr />
<h2 id="print-1">print</h2>
<pre><code>print :: fn (format: string, args: ...) s32</code></pre>
<p>Write string to the standart output (stdout). Format string can include format specifiers <code>%</code> which are replaced by corresponding argument value passed in <code>args</code>. Value-string conversion is done automatically, we can pass values of any type as an arguments, even structures or arrays.</p>
<p>The <code>print</code> function accepts C-like escape sequences as <code>\n</code>, <code>\t</code>, <code>\r</code>, etc.</p>
<p>Pointers to <code>Error</code> are dereferenced automatically; so the <code>print</code> function can print out errors directly.</p>
<p>Count of printed bytes is returned.</p>
<h3 id="example-14">Example</h3>
<pre><code>main :: fn () s32 {
    print(&quot;Hello world!\n&quot;);
    print(&quot;My name is &#39;%&#39;.\n&quot;, &quot;Travis&quot;);
    print(&quot;Number: %\n&quot;, 10);

    Foo :: struct {
        i: s32;
        j: s32;
    };

    foo := {:Foo: 10, 20};
    print(&quot;foo = &#39;%&#39;\n&quot;, foo);

    return 0;
}</code></pre>
<hr />
<h2 id="eprint">eprint</h2>
<pre><code>eprint :: fn (format: string, args: ...) s32</code></pre>
<p>Write string to the error output (stderr). See also <a href="#print">print</a>.</p>
<hr />
<h2 id="bprint">bprint</h2>
<pre><code>bprint :: fn (buf: []u8, format: string, args: ...) s32</code></pre>
<p>Write formatted input to the buffer. When passed buffer has not enough space to handle whole resulting string and terminal character, function will print just part tting into the buffer.</p>
<p>Returns count of characters written into buffer, this count does not include terminal character written at the end of the result string.</p>
<p><strong>note</strong>: String written into the buffer is always zero terminated.</p>
<p>See also <a href="#print">print</a>.</p>
<hr />
<h2 id="tprint">tprint</h2>
<pre><code>tprint :: fn (format: string, args: ...) string #inline</code></pre>
<p>Write formatted input to the new string using <code>temporary_allocator</code>.</p>
<p><strong>note</strong>: There is no need to explicitly release memory used by temporary string.</p>
<p><strong>note</strong>: Created string is always zero terminated.</p>
<p>See also <a href="#print">print</a>.</p>
<hr />
<h2 id="sprint">sprint</h2>
<pre><code>sprint :: fn (format: string, args: ...) string</code></pre>
<p>Write formatted input to the new heap-allocated string.</p>
<p><strong>note</strong>: Use <code>String.delete</code> to free memory used by string.</p>
<p><strong>note</strong>: Created string is always zero terminated.</p>
<p>See also <a href="#print">print</a>.</p>
<hr />
<h2 id="fmtreal">FmtReal</h2>
<pre><code>FmtReal :: struct {
    trailing: s8;
    v: Any;
}</code></pre>
<p>Structure to hold information about custom real print formatting. Use <a href="#fmt_real">fmt_real</a> function to create formatted printable value.</p>
<h3 id="members-19">Members</h3>
<p><strong>trailing</strong> - Count of trailing zeros. When this value is less than zero, default (6) trailing will be used.</p>
<p><strong>v</strong> - Value.</p>
<hr />
<h2 id="fmt_real">fmt_real</h2>
<pre><code>fmt_real :: fn (v: Any, trailing: s8) FmtReal #inline</code></pre>
<p>Create formatted printable object for real number. Created <a href="#fmtreal">FmtReal</a> object is valid</p>
<hr />
<h2 id="fmtintbase">FmtIntBase</h2>
<pre><code>FmtIntBase :: enum u8 {
    Bin;
    Dec;
    Oct;
    Hex;
}</code></pre>
<p>Number base used for formatted printing.</p>
<h3 id="variants-7">Variants</h3>
<p><strong>Bin</strong> - Format as binary number.</p>
<p><strong>Dec</strong> - Format as decimal number.</p>
<p><strong>Oct</strong> - Format as octal number.</p>
<p><strong>Hex</strong> - Format as haxadecimal number.</p>
<hr />
<h2 id="fmtint">FmtInt</h2>
<pre><code>FmtInt :: struct {
    base: FmtIntBase;
    print_prefix: bool;
    v: Any;
}</code></pre>
<p>Specify number printing format. Use <a href="#fmt_int">fmt_int</a> helper function to create instance of this type.</p>
<h3 id="members-20">Members</h3>
<p><strong>base</strong> - Numeric base.</p>
<p><strong>print_prefix</strong> - Prints prefix based on desired numeric base.</p>
<ul>
<li><code>0b</code> for binary.</li>
<li><code>0</code> for octal.</li>
<li><code>0x</code> for hexadecimal.</li>
</ul>
<p><strong>v</strong> - Printed value.</p>
<hr />
<h2 id="fmt_int">fmt_int</h2>
<pre><code>fmt_int :: fn (v: Any, base: FmtIntBase, print_prefix :: ) FmtInt #inline</code></pre>
<p>Create formatted printable object for number. Created <a href="#fmtint">FmtInt</a> object is valid for direct printing.</p>
<hr />
<h2 id="fmtchar">FmtChar</h2>
<pre><code>FmtChar :: struct {
    v: u8;
}</code></pre>
<p>Simple wrapper used for format <code>u8</code> value as character.</p>
<hr />
<h2 id="fmt_char">fmt_char</h2>
<pre><code>fmt_char :: fn (v: u8) FmtChar #inline</code></pre>
<p>Create formatter for <code>u8</code> number to be later printed as character.</p>
<h3 id="example-15">Example</h3>
<pre><code>print(&quot;% = %\n&quot;, &#39;c&#39;, fmt_char(&#39;c&#39;));</code></pre>
<hr />
<h2 id="print_impl">_print_impl</h2>
<pre><code>_print_impl :: fn { fn (buf: []u8, format: string, args: []Any, cur :: 0) s32; fn (buf: *string, format: string, args: []Any, cur :: 0) s32; }</code></pre>
<hr />
<h1 id="string">String</h1>
<p><code>#import "std/string"</code></p>
<p>Builtin string storage. The <code>string</code> type could represent dynamic and compile time static strings.</p>
<pre><code>string :: struct {
    len: s64;
    ptr: *u8;
}


// Compile-time string literal
my_string :: &quot;This is my string!&quot;; 


// Dynamic string allocated on heap.
// New dynamic string can be created from string literal. 
my_string :: String.new(&quot;This is my string!&quot;);
defer String.delete(my_string);</code></pre>
<p>BL strings are zero terminated except of sub-string view function (terminator cannot be added because we cannot modify original string).</p>
<p><strong>note</strong>: String manipulation functions are related only to dynamic strings and cannot be used with string literals since those are constants allocated on stack. ## new</p>
<pre><code>new :: fn { fn (allocator : *Allocator: ) string; fn (size: s64, allocator : *Allocator: ) string; fn (v: string, allocator : *Allocator: ) string; fn (cstr: *u8, allocator : *Allocator: ) string; }</code></pre>
<p>Overloaded function creating new dynamic string instance. Created string is guaranteed to be zero terminated.</p>
<p><strong>warning</strong>: Every new string must be deleted by <a href="#delete">String.delete</a> call.</p>
<pre><code>new :: fn () string</code></pre>
<p>Create new empty string object.</p>
<hr />
<pre><code>new :: fn (size: s64) string</code></pre>
<p>Create new string with preallocated space. This type of string initialization can reduce count of allocations made later by extending string content. String with length up to <code>size</code> require only one memory allocation.</p>
<p>This initialization should be preferred if string length can be predicted.</p>
<h3 id="example-16">Example</h3>
<pre><code>main :: fn () s32 {
    str :: String.new();
    defer String.delete(str);
    String.append(&amp;str, &quot;Hello&quot;);

    print(&quot;str = %\n&quot;, str);
    return 0;
}</code></pre>
<hr />
<pre><code>new :: fn (v: string) string</code></pre>
<p>Create copy of <code>v</code> string. Allocates memory to hold exactly size of <code>v</code> string data.</p>
<hr />
<pre><code>new :: fn (cstr: *u8) string</code></pre>
<p>Create copy of C zero terminated string.</p>
<hr />
<h2 id="delete-1">delete</h2>
<pre><code>delete :: fn (v: string) </code></pre>
<p>Delete dynamic string.</p>
<hr />
<h2 id="reserve">reserve</h2>
<pre><code>reserve :: fn (v: *string, count: s64) </code></pre>
<p>Ensure that string’s underlying buffer is capable to hold <code>count</code> of characters and eventually do preallocation if buffer is too small. The reserve does not take in account if the string’s buffer is full or not. The function does nothing if buffer size is enough.</p>
<hr />
<h2 id="get_allocated_bytes">get_allocated_bytes</h2>
<pre><code>get_allocated_bytes :: fn (v: string) usize #inline</code></pre>
<p>Get currently allocated memory used by the string in bytes.</p>
<hr />
<h2 id="clear">clear</h2>
<pre><code>clear :: fn (v: *string) </code></pre>
<p>Clear dynamic string but keep allocated storage.</p>
<hr />
<h2 id="append">append</h2>
<pre><code>append :: fn { _append_str; _append_any; }</code></pre>
<p>Append dynamic string with any value. Allocation is done in case there is not enough space reminding in string. The <code>v</code> string is supposed to be allocated on heap.</p>
<p>Returns count of characters appended to the string excluding zero terminator.</p>
<hr />
<h2 id="append_str">_append_str</h2>
<pre><code>_append_str :: fn (v: *string, other: string) s32</code></pre>
<hr />
<h2 id="append_any">_append_any</h2>
<pre><code>_append_any :: fn (v: *string, add: Any) s32 #inline</code></pre>
<hr />
<h2 id="concatenate">concatenate</h2>
<pre><code>concatenate :: fn (v: *string, args: ...) string</code></pre>
<p>Append string with multiple values passed as <code>args</code> and return <code>@v</code>. New allocation is done in case there is space no left in currently allocated string’s memory to append <code>args</code>.</p>
<hr />
<h2 id="clear_concat">clear_concat</h2>
<pre><code>clear_concat :: fn (v: *string, args: ...) string</code></pre>
<p>Clear the <code>v</code> string and append multiple values passed as <code>args</code>. Returned value is dereference of the original <code>v</code> string after new values are appended. New allocation is done in case there is space no left in currently allocated string’s memory to append <code>args</code>.</p>
<p><strong>hint</strong>: Use this function in case you need create only temporary string i.e. file path.</p>
<pre><code>VERSION :: &quot;1.0.0&quot;;

path := String.new();
defer String.delete(path);
Fs.set_cwd(String.clear_concat(&amp;path, &quot;my-dir/project-&quot;, VERSION));</code></pre>
<hr />
<h2 id="compare-1">compare</h2>
<pre><code>compare :: fn (first: string, second: string, n :: -1) bool</code></pre>
<p>Compare <code>first</code> and <code>second</code> strings in specified range <code>n</code> and return <code>true</code> if they are same otherwise return <code>false</code>.</p>
<p>Range value <code>n</code> is optional and ignored when it’s less than 0.</p>
<hr />
<h2 id="compare2">compare2</h2>
<pre><code>compare2 :: fn (first: string, second: string) s32</code></pre>
<p><span class="citation" data-cites="INCOMPLETE">@INCOMPLETE</span></p>
<hr />
<h2 id="to_f32">to_f32</h2>
<pre><code>to_f32 :: fn (str: string, count :: -1) f32</code></pre>
<p>Convert first <code>count</code> characters of <code>str</code> to <code>f32</code>.</p>
<hr />
<h2 id="to_s64">to_s64</h2>
<pre><code>to_s64 :: fn (str: string, count :: -1) s64</code></pre>
<p>Convert first <code>count</code> characters from <code>str</code> to <code>s64</code>.</p>
<hr />
<h2 id="split_by_last">split_by_last</h2>
<pre><code>split_by_last :: fn (str: string, delimiter: u8, lhs: *string, rhs : *string: , di : *s32: ) bool</code></pre>
<p>Split input string <code>str</code> into two tokens based on the last occurrence of <code>delimiter</code>. Delimiter is not included in resulting tokens. Result tokens only points into original memory of the <code>str</code>, they are not supposed to be freed.</p>
<p>When delimiter is not present in the input string function return <code>false</code>, <code>lhs</code> and <code>rhs</code> buffers are not modified, otherwise function return <code>true</code> and sets <code>lhs</code> and <code>rhs</code> to valid values.</p>
<p>Token destination pointers <code>lhs</code> and <code>rhs</code> are optional. The <code>di</code> output variable is set to index of the split position when it’s not <code>null</code>.</p>
<p><strong>warning</strong>: <code>lhs</code> and <code>rhs</code> sub strings are not guaranteed to be zero terminated and they are not supposed to be freed.</p>
<h3 id="example-17">Example</h3>
<pre><code>main :: fn () s32 {
    lhs: string;
    rhs: string;
    if String.split_by_last(&quot;this/is/my/epic/path&quot;, &#39;/&#39;, &amp;lhs, &amp;rhs) {
        print(&quot;lhs = %\n&quot;, lhs);
        print(&quot;rhs = %\n&quot;, rhs);
    }

    return 0;
}</code></pre>
<hr />
<h2 id="split_at_index">split_at_index</h2>
<pre><code>split_at_index :: fn (str: string, index: s32, lhs : *string: , rhs : *string: ) bool</code></pre>
<p>Split input string <code>str</code> at index position and return true when split was done. Result tokens only points into original memory of the <code>str</code>, they are not supposed to be freed. When index is out of <code>str</code> range function return <code>false</code>, <code>lhs</code> and <code>rhs</code> buffers are not modified.</p>
<p>Token destination pointers <code>lhs</code> and <code>rhs</code> are optional.</p>
<p><strong>warning</strong>: <code>lhs</code> and <code>rhs</code> sub strings are not guaranteed to be zero terminated and they are not supposed to be freed.</p>
<h3 id="example-18">Example</h3>
<pre><code>main :: fn () s32 {
    lhs: string;
    rhs: string;
    if String.split_at_index(&quot;foobar&quot;, 3, &amp;lhs, &amp;rhs) {
        print(&quot;lhs = %\n&quot;, lhs);
        print(&quot;rhs = %\n&quot;, rhs);
    }

    return 0;
}</code></pre>
<hr />
<h2 id="split_by_first">split_by_first</h2>
<pre><code>split_by_first :: fn (str: string, delimiter: u8, lhs: *string, rhs : *string: , di : *s32: ) bool</code></pre>
<p>Split input string <code>str</code> into two tokens based on the first occurrence of <code>delimiter</code>. Delimiter is not included in resulting tokens. Result tokens only points into original memory of the <code>str</code>, they are not supposed to be freed.</p>
<p>When delimiter is not present in the input string function return <code>false</code>, <code>lhs</code> and <code>rhs</code> buffers are not modified, otherwise function return <code>true</code> and sets <code>lhs</code> and <code>rhs</code> to found values.</p>
<p>Token destination pointers <code>lhs</code> and <code>rhs</code> are optional.</p>
<p><strong>warning</strong>: <code>lhs</code> and <code>rhs</code> sub strings are not guaranteed to be zero terminated and they are not supposed to be freed.</p>
<h3 id="example-19">Example</h3>
<pre><code>main :: fn () s32 {
    lhs: string;
    rhs: string;
    if String.split_by_first(&quot;this/is/my/epic/path&quot;, &#39;/&#39;, &amp;lhs, &amp;rhs) {
        print(&quot;lhs = %\n&quot;, lhs);
        print(&quot;rhs = %\n&quot;, rhs);
    }

    return 0;
}</code></pre>
<hr />
<h2 id="insert">insert</h2>
<pre><code>insert :: fn { _string_insert; _char_insert; }</code></pre>
<p>Overloaded function inserting one character or other string at desired position.</p>
<pre><code>fn (str: *string, index: s32, v: u8) bool #inline</code></pre>
<p>Insert one character into <code>str</code> at <code>index</code> and return <code>true</code> when character was inserted.</p>
<p><strong>note</strong>: The input <code>str</code> can be reallocated when <code>index</code> is equal to input string <code>len</code> and more space is needed.</p>
<pre><code>fn (str: *string, index: s32, v: string) bool</code></pre>
<p>Insert other string into <code>str</code> at <code>index</code> and return <code>true</code> when string was inserted.</p>
<p><strong>note</strong>: The input <code>str</code> can be reallocated when <code>index</code> is equal to input string <code>len</code> and more space is needed.</p>
<p><strong>note</strong>: Function does nothing (return <code>false</code>) when <code>v</code> string is empty.</p>
<hr />
<h2 id="erase">erase</h2>
<pre><code>erase :: fn (str: *string, index: s32) bool</code></pre>
<p>Erase one character at <code>index</code> position and return true when character was erased. The ’<code>index</code> value is checked to fit in string bounds.</p>
<hr />
<h2 id="split_by">split_by</h2>
<pre><code>split_by :: fn (str: string, delimiter: u8) []string</code></pre>
<p>Split the <code>str</code> input string by delimiter and return new slice containing all found sub-strings.</p>
<p><strong>warning</strong>: String slice should be terminated by <a href="#sliceterminate">slice_terminate</a> call.</p>
<p><strong>warning</strong>: Slice elements are not guaranteed to be zero terminated and they are not supposed to be freed.</p>
<hr />
<h2 id="count_of">count_of</h2>
<pre><code>count_of :: fn (str: string, c: u8) s32 #inline</code></pre>
<p>Counts desired character occurrence in the input string.</p>
<hr />
<h2 id="to_lower">to_lower</h2>
<pre><code>to_lower :: fn (str: string)  #inline</code></pre>
<p>Converts input string to lower case.</p>
<hr />
<h2 id="to_upper">to_upper</h2>
<pre><code>to_upper :: fn (str: string)  #inline</code></pre>
<p>Converts input string to upper case.</p>
<hr />
<h2 id="replace_all">replace_all</h2>
<pre><code>replace_all :: fn (str: *string, c: u8, with :: ) s32</code></pre>
<p>Replace all found occurrences of character <code>c</code> in the input string with <code>with</code> character and return count of replacements made. This function cannot be used with constant string literals as input.</p>
<p>If <code>with</code> replacement is 0 character, all <code>c</code> occurrences will be erased from the string.</p>
<p>Function return count of replaced characters or zero.</p>
<hr />
<h2 id="hash">hash</h2>
<pre><code>hash :: fn (str: string) u32</code></pre>
<p>Calculates string <code>u32</code> hash.</p>
<hr />
<h2 id="is_null">is_null</h2>
<pre><code>is_null :: fn (s: string) bool #inline</code></pre>
<p>Helper inline function returning <code>true</code> when string is null. In such case string <code>len</code> could be any value.</p>
<hr />
<h2 id="is_empty">is_empty</h2>
<pre><code>is_empty :: fn (s: string) bool #inline</code></pre>
<p>Helper inline function returning <code>true</code> when string is empty. In such case string <code>ptr</code> could be any pointer.</p>
<hr />
<h2 id="empty">empty</h2>
<pre><code>empty :: </code></pre>
<hr />
<h2 id="is_null_or_empty">is_null_or_empty</h2>
<pre><code>is_null_or_empty :: fn (s: string) bool #inline</code></pre>
<p>Helper inline function returning <code>true</code> when string is empty and null.</p>
<hr />
<h2 id="sub">sub</h2>
<pre><code>sub :: fn (s: string, start: s64, len : s64: -1) string #inline</code></pre>
<p>Creates substring from passed string starting at <code>start</code> index of input string and ending at <code>start</code> + <code>len</code> index.</p>
<p>Starting index <code>start</code> must be greater than 0 and less than <code>str.len</code>. <code>len</code> specifies optional length of substring. When not specified, length from <code>start</code> to the end of the <code>str</code> is used.</p>
<p><strong>warning</strong>: Result sub-string is not guaranteed to be zero terminated and it’s not supposed to be freed.</p>
<hr />
<h2 id="is_zero_terminated">is_zero_terminated</h2>
<pre><code>is_zero_terminated :: fn (str: string) bool</code></pre>
<p>Checks whether string is zero terminated.</p>
<hr />
<h1 id="thread-synchronization">Thread synchronization</h1>
<p><code>#import "std/sync"</code></p>
<p>Multiplatform implementation of various thread synchronization tools.</p>
<p><strong>warning</strong>: This module is experimental and not fully supported across all platforms. ## Mutex</p>
<pre><code>Mutex :: _SyncImpl.Mutex</code></pre>
<p>Mutex type.</p>
<hr />
<h2 id="init-1">init</h2>
<pre><code>init :: fn (mutex: *Mutex)  #inline</code></pre>
<p>Initialize mutex. Call :ref:<code>terminate</code> when mutex is no longer needed.</p>
<hr />
<h2 id="terminate-1">terminate</h2>
<pre><code>terminate :: fn (mutex: *Mutex)  #inline</code></pre>
<p>Terminate mutex.</p>
<hr />
<h2 id="lock">lock</h2>
<pre><code>lock :: fn (mutex: *Mutex)  #inline</code></pre>
<p>Lock mutex and enter critical section.</p>
<hr />
<h2 id="try_lock">try_lock</h2>
<pre><code>try_lock :: fn (mutex: *Mutex) bool #inline</code></pre>
<hr />
<h2 id="unlock">unlock</h2>
<pre><code>unlock :: fn (mutex: *Mutex)  #inline</code></pre>
<p>Unlock previously locked mutex and leave critical section.</p>
<hr />
<h1 id="test">Test</h1>
<p><code>#load "std/test.bl"</code></p>
<p>Integrated unit testing API. ## test_eq</p>
<pre><code>test_eq :: fn { fn (got: string, expected: string, loc :: ) ; fn (got: f32, expected: f32, epsilon : f32: , loc :: ) ; fn (got: f64, expected: f64, epsilon : f64: , loc :: ) ; fn (got: ?T, expected: T, loc :: ) ; }</code></pre>
<h3 id="overloads">Overloads</h3>
<pre><code>fn (got: string, expected: string, loc := #call_location)
fn (got: f32, expected: f32, epsilon: f32 = Math.F32_EPSILON, loc := #call_location)
fn (got: f64, expected: f64, epsilon: f64 = Math.F64_EPSILON, loc := #call_location)
fn (got: ?T, expected: T, loc := #call_location)</code></pre>
<p>Test whether <code>got</code> value is equal to <code>expected</code> value.</p>
<hr />
<h2 id="test_neq">test_neq</h2>
<pre><code>test_neq :: fn { fn (got: string, not_expected: string, loc :: ) ; fn (got: f32, not_expected: f32, epsilon : f32: , loc :: ) ; fn (got: f64, not_expected: f64, epsilon : f64: , loc :: ) ; fn (got: ?T, not_expected: T, loc :: ) ; }</code></pre>
<h3 id="overloads-1">Overloads</h3>
<pre><code>fn (got: string, not_expected: string, loc := #call_location)
fn (got: f32, not_expected: f32, epsilon: f32 = Math.F32_EPSILON, loc := #call_location)
fn (got: f64, not_expected: f64, epsilon: f64 = Math.F64_EPSILON, loc := #call_location)
fn (got: ?T, not_expected: T, loc := #call_location)</code></pre>
<p>Test whether <code>got</code> value is not equal to <code>not_expected</code> value.</p>
<hr />
<h2 id="test_gt">test_gt</h2>
<pre><code>test_gt :: fn (v1: ?T, v2: T, loc :: ) </code></pre>
<p>Test whether <code>v1</code> is greater than <code>v2</code></p>
<hr />
<h2 id="test_lt">test_lt</h2>
<pre><code>test_lt :: fn (v1: ?T, v2: T, loc :: ) </code></pre>
<p>Test whether <code>v1</code> is less than <code>v2</code></p>
<hr />
<h2 id="test_true">test_true</h2>
<pre><code>test_true :: fn (v: bool, loc :: ) </code></pre>
<p>Test whether <code>v</code> value is <code>true</code>.</p>
<hr />
<h2 id="test_false">test_false</h2>
<pre><code>test_false :: fn (v: bool, loc :: ) </code></pre>
<p>Test whether <code>v</code> value is <code>false</code>.</p>
<hr />
<h2 id="test_null">test_null</h2>
<pre><code>test_null :: fn (ptr: *?T, loc :: ) </code></pre>
<p>Test whether <code>ptr</code> pointer value is <code>null</code>.</p>
<hr />
<h2 id="test_not_null">test_not_null</h2>
<pre><code>test_not_null :: fn (ptr: *?T, loc :: ) </code></pre>
<p>Test whether <code>ptr</code> pointer value is not <code>null</code>.</p>
<hr />
<h2 id="test_ok">test_ok</h2>
<pre><code>test_ok :: fn (err: Error, loc :: )  #inline</code></pre>
<p>Test whether <code>err</code> is OK.</p>
<hr />
<h2 id="test_not_ok">test_not_ok</h2>
<pre><code>test_not_ok :: fn (err: Error, loc :: )  #inline</code></pre>
<p>Test whether <code>err</code> is not OK.</p>
<hr />
<h2 id="test_is_error">test_is_error</h2>
<pre><code>test_is_error :: fn (got_err: Error, expected_code: s32, loc :: )  #inline</code></pre>
<p>Test whether <code>got_err</code> code is <code>expected_code</code>.</p>
<hr />
<h2 id="test_run">test_run</h2>
<pre><code>test_run :: fn () s32</code></pre>
<p>Execute all registered test cases in current assembly. The <code>test_run</code> function uses compiler builtin <code>testcases()</code> function returning slice of all registered test cases in the current assembly (all function with hash directive <code>#test</code>).</p>
<p>Test case execution can be used in runtime and compile time, in both cases function remap default behaviour of <code>panic()</code> function call and try to report all failing tests without execution termination.</p>
<p>Formatted output containing information about every test run status and summary report is produced during execution of this function. In case of test failure all needed information about fail source location is reported into standard output.</p>
<p>Returns number of failed tests.</p>
<h3 id="example-20">Example</h3>
<pre><code>#load &quot;std/test.bl&quot;

my_test :: fn () #test {
    print(&quot;Hello from test case!!!\n&quot;);     
}

main :: fn () s32 {
    return test_run(); 
} </code></pre>
<hr />
<h1 id="thread">Thread</h1>
<p><code>#import "std/thread"</code></p>
<p>This module contains tools for managing multithreading. It’s basically wrapper for Windows thread system and pthread on posix systems.</p>
<p><strong>warning</strong>: This module is experimental and not fully supported across all platforms. ## EntryFn</p>
<pre><code>EntryFn :: *fn (ctx: *u8) s32</code></pre>
<p>Thread entry function type.</p>
<hr />
<h2 id="handle-1">Handle</h2>
<pre><code>Handle :: _ThreadImpl.Handle</code></pre>
<p>Thread handle.</p>
<hr />
<h2 id="create">create</h2>
<pre><code>create :: fn (entry: EntryFn, ctx : *u8: ) (_0: Handle, _1: Error
) #inline</code></pre>
<p>Create and start new thread with specified <code>entry</code> function. Pointer to custom<code>ctx</code> can be optionally passed to the entry function here.</p>
<hr />
<h2 id="join">join</h2>
<pre><code>join :: fn (thread: Handle) (exit_code: s32, err: Error
) #inline</code></pre>
<p>Blocks until <code>thread</code> exits. Return value from worker function is returned as <code>exit_code</code>. When execution is successful all thread resources are released.</p>
<hr />
<h2 id="join_all">join_all</h2>
<pre><code>join_all :: fn (threads: []Handle) Error #inline</code></pre>
<p>Blocks until all <code>threads</code> exits.</p>
<hr />
<h2 id="exit">exit</h2>
<pre><code>exit :: fn (exit_code : s32: 0) Error #inline</code></pre>
<p>Exit current thread with optional <code>exit_code</code> return value.</p>
<hr />
<h2 id="current">current</h2>
<pre><code>current :: fn () Handle #inline</code></pre>
<p>Gets current thread.</p>
<hr />
<h1 id="temporary-allocator">Temporary Allocator</h1>
<p>Temporary allocator is memory allocator supposed to be used in case just temporary memory allocation is needed; i.e. to build up file path from individual path components. The allocated memory is valid until <a href="#temporary_reset">temporary_reset</a> or <a href="#temporary_release">temporary_release</a> is called.</p>
<p>The allocator makes all allocations in bigger preallocated block; i.e. when allocation is requested for the first time, new block is allocated with predefined size <code>DEFAULT_BLOCK_SIZE</code>, all following allocations use the preallocated block if there is enough space. If the block is full and new requested allocation does not fit, another block is allocated (with size slightly bigger then previous one). When <a href="#temporary_reset">temporary_reset</a> is called, allocator will release all smaller allocated blocks and keeps only the biggest one for later use.</p>
<h3 id="example-21">Example</h3>
<pre><code>#import &quot;std/tmp_allocator&quot;

main :: fn () s32 {
    // Release allocated memory at the end of the scope.
    defer temporary_release();
    
    loop i := 0; i &lt; 1000; i += 1 {
         // Reset the allocator here (all previous alocation are invalid since now).
        defer temporary_reset();
        
        // Allocate memory using temporary allocator.
        int_ptr := cast(*s32) allocate_memory(&amp;temporary_allocator, sizeof(s32));
        
        // Do something here with allocated memory.
        @int_ptr = i;

        // There is no need to free allocated memory here.
    }
    return 0;
}</code></pre>
<p><strong>note</strong>: Temporary allocator has it’s internal context allocated per-thread, so the explicit release of the allocated memory at the thread worker exit is mandatory. ## temporary_allocator</p>
<pre><code>temporary_allocator :: </code></pre>
<p>Temporary allocator instance.</p>
<hr />
<h2 id="temporary_reset">temporary_reset</h2>
<pre><code>temporary_reset :: fn ()  #inline</code></pre>
<p>Reduce allocated memory, but keeps biggest allocated chunk for later use.</p>
<p><strong>warning</strong>: All resources previously allocated by this allocator became invalid after reset.</p>
<p><strong>hint</strong>: Call this method i.e. in every event loop (update) iteration.</p>
<hr />
<h2 id="temporary_release">temporary_release</h2>
<pre><code>temporary_release :: fn ()  #inline</code></pre>
<p>Release all memory allocated by temporary allocator, this method is supposed to be called at exit of a program.</p>
<p><strong>warning</strong>: All resources previously allocated by this allocator became invalid after release.</p>
<p><strong>hint</strong>: Call this method before main returns.</p>
<hr />
<h2 id="temporary_allocated_bytes">temporary_allocated_bytes</h2>
<pre><code>temporary_allocated_bytes :: fn () usize #inline</code></pre>
<p>Return total memory used by temporary allocator in bytes. <strong>note</strong>: Reports memory usage only for current thread.</p>
<hr />
<h1 id="utils">Utils</h1>
<p><code>#load "std/utils.bl"</code></p>
<p>Set of various utility functions. ## set_flag</p>
<pre><code>set_flag :: fn (flags: *?T, flag: T) T #inline</code></pre>
<p>Set <code>flag</code> in <code>flags</code> input. This function is valid for numeric and enum types (checked by assert).</p>
<hr />
<h2 id="clr_flag">clr_flag</h2>
<pre><code>clr_flag :: fn (flags: *?T, flag: T) T #inline</code></pre>
<p>Clear <code>flag</code> in <code>flags</code> input. This function is valid for numeric and enum types (checked by assert).</p>
<hr />
<h2 id="is_flag">is_flag</h2>
<pre><code>is_flag :: fn (flags: ?T, flag: T) bool #inline</code></pre>
<p>Check whether <code>flag</code> is set in <code>flags</code>. This function is valid for numeric and enum types (checked by assert).</p>
<hr />
<h2 id="make_flags">make_flags</h2>
<pre><code>make_flags :: fn (f1: ?T, other: ...T) T</code></pre>
<hr />
<h2 id="cstr_to_str">cstr_to_str</h2>
<pre><code>cstr_to_str :: fn (cstr: *u8) string #inline</code></pre>
<p>Converts zero terminated C style string to BL string. Result string shares original memory of <code>cstr</code>.</p>
<hr />
<h2 id="ptr_shift_bytes">ptr_shift_bytes</h2>
<pre><code>ptr_shift_bytes :: fn (ptr: *?T, bytes: s64) *u8 #inline</code></pre>
<p>Produce right-shift of input <code>ptr</code> by count of <code>bytes</code>.</p>
<hr />
<h2 id="ptr_diff">ptr_diff</h2>
<pre><code>ptr_diff :: fn (a: *?T1, b: *?T2) s64 #inline</code></pre>
<p>Calculates pointer difference <code>a</code> - <code>b</code>.</p>
<hr />
<h2 id="env_get">env_get</h2>
<pre><code>env_get :: fn (var: string) string</code></pre>
<p>Reads environment variable specified by <code>var</code> name. Result is empty in case no such variable was found or has no content. It’s caller responsibility to delete result string.</p>
<hr />
<h2 id="env_set">env_set</h2>
<pre><code>env_set :: fn (var: string)  #inline</code></pre>
<p>Sets environment variable.</p>
<hr />
<h2 id="random_seed_time">random_seed_time</h2>
<pre><code>random_seed_time :: fn ()  #inline</code></pre>
<p>Sets seed for <code>Math.rand</code> or utility function <a href="#random_number">random_number</a> based on current system tick time.</p>
<hr />
<h2 id="random_number">random_number</h2>
<pre><code>random_number :: fn (min :: 0, max :: 1) s32 #inline</code></pre>
<p>Generates random number in specified range &lt;min, max&gt; using standard libc rand generator. Random number generator seed is supposed to be set by :ref:<code>random_seed_time</code> or by <code>Math.srand</code> call.</p>
<hr />
<h2 id="sort">sort</h2>
<pre><code>sort :: fn (list: []?T, cmp: *fn (a: *T, b: *T) bool) </code></pre>
<p>Polymorph slice sorting utility. <span class="citation" data-cites="INCOMPLETE">@INCOMPLETE</span></p>
<hr />
<h2 id="hash_combine">hash_combine</h2>
<pre><code>hash_combine :: fn (first: ?T, second: T, more: ...T) T #inline</code></pre>
<p>Combine two or more hashes into one, T is expected to be an integer type (checked by static assert).</p>
<hr />
</body>
</html>
