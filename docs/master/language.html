<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Biscuit Language (0.10.0)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../static/styles.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="icon" href="../static/favicon.png">
  <style>
  body {
    margin-left: 410px;
    margin-top: 50px;
  }
  </style>
</head>
<body>
<ul id="MENU">
  <li><a href="../index.html">Home</a></li>
  <li><a href="index.html">Installation</a></li>
  <li><a href="compiler.html">Compiler Usage</a></li>
  <li><a href="language.html">Language Manual</a></li>
  <li><a href="api.html">API Manual</a></li>
  <li><a href="how-to.html">How To</a></li>
</ul>
<header id="title-block-header">
<h1 class="title">Biscuit Language (0.10.0)</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#language-reference">Language Reference</a>
<ul>
<li><a href="#basic-data-types">Basic data types</a></li>
<li><a href="#pointer">Pointer</a></li>
<li><a href="#array">Array</a></li>
<li><a href="#string">String</a></li>
<li><a href="#slice">Slice</a></li>
<li><a href="#structure">Structure</a></li>
<li><a href="#union">Union</a></li>
<li><a href="#any">Any</a></li>
<li><a href="#enum">Enum</a></li>
<li><a href="#enum-flags">Enum flags</a></li>
<li><a href="#type-aliasing">Type aliasing</a></li>
<li><a href="#function-type">Function type</a></li>
<li><a href="#type-casting">Type casting</a></li>
<li><a href="#simple-literals">Simple literals</a></li>
<li><a href="#integer-literals">Integer literals</a></li>
<li><a href="#binary-operators">Binary Operators</a></li>
<li><a href="#unary-operators">Unary Operators</a></li>
<li><a href="#special-operators">Special Operators</a></li>
<li><a href="#type-info">Type Info</a></li>
<li><a href="#hash-directive">Hash directive</a></li>
<li><a href="#variable">Variable</a></li>
<li><a href="#compound-expression">Compound expression</a></li>
<li><a href="#function">Function</a></li>
<li><a href="#block">Block</a></li>
<li><a href="#if---else">If - Else</a></li>
<li><a href="#loop">Loop</a></li>
<li><a href="#break-and-continue">Break and continue</a></li>
<li><a href="#switch">Switch</a></li>
<li><a href="#defer-statement">Defer statement</a></li>
<li><a href="#using-statement">Using statement</a></li>
<li><a href="#main-function">Main function</a></li>
<li><a href="#modules-and-import">Modules and import</a></li>
<li><a href="#unit-testing">Unit testing</a></li>
<li><a href="#use-bl-code-from-cc">Use BL code from C/C++</a></li>
<li><a href="#builtin-variables">Builtin variables</a></li>
</ul></li>
</ul>
</nav>
<h1 id="language-reference">Language Reference</h1>
<p>Basically, every construct in bl follows the same rules of declaration syntax. We define the name of the entity, type and optionally some initial value. Name can usually be used to reference the entity later in the code and type describes layout of data represented by the entity. It could be a number, text or more complex types.</p>
<p>Possible declarations:</p>
<pre class="text"><code>&lt;name&gt;: &lt;type&gt;;              // mutable declaration
&lt;name&gt;: [type] = &lt;value&gt;;    // mutable declaration
&lt;name&gt;: [type] : &lt;value&gt;;    // immutable declaration (value can be set only once)</code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>foo<span class="op">:</span> s32<span class="op">;</span>                <span class="co">// integer variable without initial value</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>name<span class="op">:</span> string_view <span class="op">=</span> <span class="st">&quot;Martin&quot;</span><span class="op">;</span> <span class="co">// string variable</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>name<span class="op">:</span> string_view <span class="op">:</span> <span class="st">&quot;Martin&quot;</span><span class="op">;</span> <span class="co">// string constant</span></span></code></pre></div>
<p>When we decide to explicitly specify initial value, data type can be inferred from this value. In such case, the type is optional.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>name <span class="op">:=</span> <span class="st">&quot;Martin&quot;</span><span class="op">;</span> <span class="co">// string variable</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>name <span class="op">::</span> <span class="st">&quot;Martin&quot;</span><span class="op">;</span> <span class="co">// string constant</span></span></code></pre></div>
<p>Comment lines will be ignored by compiler.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this is line comment</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"> this</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"> is</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"> multi line</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"> comment</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span></code></pre></div>
<h2 id="basic-data-types">Basic data types</h2>
<p>Basic types are atomic basic types builtin into BL compiler.</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>s8</td>
<td>Signed 8-bit number.</td>
</tr>
<tr class="even">
<td>s16</td>
<td>Signed 16-bit number.</td>
</tr>
<tr class="odd">
<td>s32</td>
<td>Signed 32-bit number.</td>
</tr>
<tr class="even">
<td>s64</td>
<td>Signed 64-bit number.</td>
</tr>
<tr class="odd">
<td>u8</td>
<td>Unsigned 8-bit number.</td>
</tr>
<tr class="even">
<td>u16</td>
<td>Unsigned 16-bit number.</td>
</tr>
<tr class="odd">
<td>u32</td>
<td>Unsigned 32-bit number.</td>
</tr>
<tr class="even">
<td>u64</td>
<td>Unsigned 64-bit number.</td>
</tr>
<tr class="odd">
<td>usize</td>
<td>Unsigned 64-bit size.</td>
</tr>
<tr class="even">
<td>bool</td>
<td>Boolean. (true/false)</td>
</tr>
<tr class="odd">
<td>f32</td>
<td>32-bit floating point number.</td>
</tr>
<tr class="even">
<td>f64</td>
<td>64-bit floating point number.</td>
</tr>
<tr class="odd">
<td>string_view</td>
<td>String slice.</td>
</tr>
</tbody>
</table>
<h2 id="pointer">Pointer</h2>
<p>Represents the address of some allocated data.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="er">#import &quot;std/test&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>pointers <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> <span class="dv">666</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    i_ptr <span class="op">:</span> <span class="op">*</span>s32 <span class="op">=</span> <span class="op">&amp;</span>i<span class="op">;</span> <span class="co">// taking the address of &#39;i&#39; variable and set &#39;i_ptr&#39;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    j <span class="op">:=</span> @i_ptr<span class="op">;</span>       <span class="co">// pointer dereferencing</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    test_true<span class="op">(</span>j <span class="op">==</span> i<span class="op">);</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="array">Array</h2>
<p>The array is an aggregate type of multiple values of the same type. Size value must be known in compile time. Arrays can be inline initialized with compound block; type is required. Zero initializers can be used for zero initializations of whole array storage, otherwise we must specify value for every element in an array.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>array_type <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    arr1 <span class="op">:</span> <span class="op">[</span><span class="dv">10</span><span class="op">]</span> s32<span class="op">;</span> <span class="co">// declare zero initialized array variable</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    arr1<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">666</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    arr1<span class="op">.</span>len<span class="op">;</span> <span class="co">// yields array element count (s64)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    arr1<span class="op">.</span>ptr<span class="op">;</span> <span class="co">// yields pointer to first element &#39;&amp;arr[0]&#39;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// inline initialization of array type</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    arr2 <span class="op">:=</span> <span class="op">[</span><span class="dv">10</span><span class="op">].</span>s32<span class="op">{};</span>            <span class="co">// Initialize all elements to 0. </span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    arr3 <span class="op">:=</span> <span class="op">[</span><span class="dv">4</span><span class="op">]</span>s32<span class="op">.{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span> <span class="op">};</span> <span class="co">// Initialize array to the sequence 1, 2, 3, 4</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Arrays can be implicitly converted to slice:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>array_to_slice <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">:</span> <span class="op">[</span><span class="dv">10</span><span class="op">]</span> s32<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    slice <span class="op">:</span> <span class="op">[]</span>s32 <span class="op">=</span> arr<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="string">String</h2>
<p>String type in Biscuit aka <code>string_view</code> is slice containing a pointer to string data and string length. String literals are always zero terminated. The <code>string_view</code> represents a string of fixed length. In case you want dynamically allocated string use <code>string</code> type and its associated methods. Values of <code>string</code> can be implicitly converted to <code>string_view</code>.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>string_type <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    msg <span class="op">:</span> string_view <span class="op">=</span> <span class="st">&quot;Hello world</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    msg<span class="op">.</span>len<span class="op">;</span> <span class="co">// character count of the string</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    msg<span class="op">.</span>ptr<span class="op">;</span> <span class="co">// pointer to the string content</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="slice">Slice</h2>
<p>The array slice consists of a pointer to the first array element and array length.</p>
<p>Slice layout:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Slice <span class="op">::</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    len<span class="op">:</span> s64<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    ptr<span class="op">:</span> <span class="op">*</span>T</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>array_slice <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">::</span> <span class="op">[</span><span class="dv">4</span><span class="op">]</span>s32<span class="op">.{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    slice <span class="op">:</span> <span class="op">[]</span>s32 <span class="op">=</span> arr<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    loop i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> slice<span class="op">.</span>len<span class="op">;</span> i <span class="op">+=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> slice<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>hint:</strong> <code>slice_init</code> can be used to allocate slice on the heap using context allocator.</p>
<h2 id="structure">Structure</h2>
<p>The structure is a composite type representing a group of data as a single type. The structure is as an array another way to define user data type, but types of structure members could be different. It can be used in situations when it’s better to group data into one unit instead of interacting with separate units.</p>
<p>Structure can be declared with use of struct keyword.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Person <span class="op">::</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    id<span class="op">:</span> s32<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    name<span class="op">:</span> string_view<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    age<span class="op">:</span> s32<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Structure Person in example consists of id, name and age. Now we can create variable of this type and fill it with data. To access person’s member fields use <code>.</code> operator.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    my_person<span class="op">:</span> Person<span class="op">;</span> <span class="co">// Create instance of type Person</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    my_person<span class="op">.</span>id <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    my_person<span class="op">.</span>age <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    my_person<span class="op">.</span>name <span class="op">=</span> <span class="st">&quot;Martin&quot;</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Inline initialization is also possible. We can use compound expression to set all members at once.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set all data in person to 0</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    my_person1 <span class="op">:=</span> Person<span class="op">.{};</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize all members.</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    my_person2 <span class="op">:=</span> Person<span class="op">.{</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;Martin&quot;</span><span class="op">,</span> <span class="dv">20</span> <span class="op">};</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can explicitly name the members we want to initialize.</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    my_person3 <span class="op">:=</span> Person<span class="op">.{</span> id <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> name <span class="op">=</span> <span class="st">&quot;Martin&quot;</span><span class="op">,</span> age <span class="op">=</span> <span class="dv">20</span> <span class="op">};</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can change the order. </span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    my_person4 <span class="op">:=</span> Person<span class="op">.{</span> name <span class="op">=</span> <span class="st">&quot;Martin&quot;</span><span class="op">,</span> age <span class="op">=</span> <span class="dv">20</span><span class="op">,</span> id <span class="op">=</span> <span class="dv">1</span> <span class="op">};</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Or initialize only someting. In such a case the rest is initialized to 0 by default.</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    my_person5 <span class="op">:=</span> Person<span class="op">.{</span> name <span class="op">=</span> <span class="st">&quot;Martin&quot;</span> <span class="op">};</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Structure content can be printed by print function.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    my_person <span class="op">:=</span> Person<span class="op">.{</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;Martin&quot;</span><span class="op">,</span> <span class="dv">20</span> <span class="op">};</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> my_person<span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Person <span class="op">{</span>id <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> name <span class="op">=</span> Martin<span class="op">,</span> age <span class="op">=</span> <span class="dv">20</span><span class="op">}</span></span></code></pre></div>
<p>Due to lack of OOP support, we cannot declare member functions in structures and there is no class or object concept in the language. Common way to manipulate with data is passing them into the function as an argument.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>person_add_age <span class="op">::</span> fn <span class="op">(</span>person<span class="op">:</span> <span class="op">*</span>Person<span class="op">,</span> add<span class="op">:</span> s32<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    person<span class="op">.</span>age <span class="op">+=</span> add<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Structure can extend any type with use of <code>#base &lt;T&gt;</code>. This is kind of inheritance similar to the C style where inheritance can be simulated by composition. The <code>#base &lt;T&gt;</code> basically insert <code>base: T</code>; as the first member into the structure. The compiler can use this information later to provide more inheritance related features like merging of scopes to enable direct access to base-type members via <code>.</code> operator or implicit cast from child to parent type.</p>
<p>Example of struct extension:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>Entity <span class="op">::</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    id<span class="op">:</span> s32</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Player has base type Entity</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>Player <span class="op">::</span> <span class="kw">struct</span> #base Entity <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// base: Entity; is implicitly inserted as first member</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    name<span class="op">:</span> string_view<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>Wall <span class="op">::</span> <span class="kw">struct</span> #base Entity <span class="op">{</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    height<span class="op">:</span> s32</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>Enemy <span class="op">::</span> <span class="kw">struct</span> #base Entity <span class="op">{</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    health<span class="op">:</span> s32</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="co">// Multi-level extension Boss -&gt; Enemy -&gt; Entity</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>Boss <span class="op">::</span> <span class="kw">struct</span> #base Enemy <span class="op">{</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Extended struct can be empty.</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>struct_extending <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    p<span class="op">:</span> Player<span class="op">;</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    p<span class="op">.</span>id <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">// direct access to base-type members</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    p<span class="op">.</span>name <span class="op">=</span> <span class="st">&quot;Travis&quot;</span><span class="op">;</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>p<span class="op">.</span>base<span class="op">.</span>id <span class="op">==</span> <span class="dv">10</span><span class="op">);</span> <span class="co">// access via .base</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    w<span class="op">:</span> Wall<span class="op">;</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    w<span class="op">.</span>id <span class="op">=</span> <span class="dv">11</span><span class="op">;</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    w<span class="op">.</span>height <span class="op">=</span> <span class="dv">666</span><span class="op">;</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    e<span class="op">:</span> Enemy<span class="op">;</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span>id <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span>health <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>    b<span class="op">:</span> Boss<span class="op">;</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>id <span class="op">=</span> <span class="dv">13</span><span class="op">;</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// implicit down cast to entity</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>    update<span class="op">(&amp;</span>p<span class="op">);</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>    update<span class="op">(&amp;</span>w<span class="op">);</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>    update<span class="op">(&amp;</span>e<span class="op">);</span></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>    update<span class="op">(&amp;</span>b<span class="op">);</span></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>update <span class="op">::</span> fn <span class="op">(</span>e<span class="op">:</span> <span class="op">*</span>Entity<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;id = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> e<span class="op">.</span>id<span class="op">);</span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="union">Union</h2>
<p>The union is a special composite type representing value of multiple types. Union size is always equal to size of the biggest member type and memory offset of all members is the same. Union is usually associated with some enum providing information about stored type.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>Token <span class="op">::</span> <span class="kw">union</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    as_string<span class="op">:</span> string_view<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    as_int<span class="op">:</span> s32<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>Kind <span class="op">::</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    String<span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    Int<span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>test_union <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    token1<span class="op">:</span> Token<span class="op">;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    token2<span class="op">:</span> Token<span class="op">;</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Token has total size of the biggest member.</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>token1 <span class="op">==</span> <span class="kw">sizeof</span><span class="op">(</span>string_view<span class="op">));</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    token1<span class="op">.</span>as_string <span class="op">=</span> <span class="st">&quot;This is string&quot;</span><span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    consumer<span class="op">(&amp;</span>token<span class="op">,</span> Kind<span class="op">.</span>String<span class="op">);</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    token2<span class="op">.</span>as_int <span class="op">=</span> <span class="dv">666</span><span class="op">;</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    consumer<span class="op">(&amp;</span>token<span class="op">,</span> Kind<span class="op">.</span>Int<span class="op">);</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>consumer <span class="op">::</span> fn <span class="op">(</span>token<span class="op">:</span> <span class="op">*</span>Token<span class="op">,</span> kind<span class="op">:</span> TokenKind<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> kind <span class="op">{</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        Kind<span class="op">.</span>String <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> token<span class="op">.</span>as_string<span class="op">);</span> <span class="op">}</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        Kind<span class="op">.</span>Int    <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> token<span class="op">.</span>as_int<span class="op">);</span> <span class="op">}</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span> <span class="op">{</span> panic<span class="op">();</span> <span class="op">}</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="any">Any</h2>
<p>Any type is a special builtin structure containing a pointer to TypeInfo and pointer to data. Any value can be implicitly cast to this type on function call.</p>
<p>Any type layout:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>Any <span class="op">::</span> <span class="kw">struct</span> #compiler <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    type_info<span class="op">:</span> <span class="op">*</span>TypeInfo<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    data<span class="op">:</span> <span class="op">*</span>u8</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Remember that Any instance does not contain a copy of the value but only pointer to already stack or heap allocated data. Any instance never owns pointed data and should not be responsible for memory free.</p>
<p>Since Any contains a pointer to data, we need to generate temporary storage on stack for constant literals converted to Any.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="dv">10</span><span class="op">);</span> <span class="co">// temp for &#39;10&#39; is created here</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>foo <span class="op">::</span> fn <span class="op">(</span>v<span class="op">:</span> Any<span class="op">)</span> <span class="op">{}</span></span></code></pre></div>
<p>For types converted to the Any compiler implicitly sets <code>type_info</code> field to a pointer to the TypeType type-info and data field to the pointer to actual type-info of the converted type.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span>s32<span class="op">);</span> <span class="co">// Type passed</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>foo <span class="op">::</span> fn <span class="op">(</span>v<span class="op">:</span> Any<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>v<span class="op">.</span>type_info<span class="op">.</span>kind <span class="op">==</span> TypeKind<span class="op">.</span>TYPE<span class="op">);</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    data_info <span class="op">:=</span> cast<span class="op">(*</span>TypeInfo<span class="op">)</span> v<span class="op">.</span>data<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>data_info<span class="op">.</span>kind <span class="op">==</span> TypeKind<span class="op">.</span>INT<span class="op">);</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Any can be combined with vargs; good example of this use case is print function where args argument type is vargs of Any (... is the same as ...Any). The print function can take values of any type passed in args.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>print <span class="op">::</span> fn <span class="op">(</span>format<span class="op">:</span> string_view<span class="op">,</span> args<span class="op">:</span> <span class="op">...)</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="enum">Enum</h2>
<p>The enum allows the creation of type representing one of the listed variants. Biscuit enums can represent variants of any integer type (<code>s32</code> by default). All variants are grouped into enum’s namespace.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Enum declaration (base type is by default s32)</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>Color <span class="op">:</span> type <span class="op">:</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    Red<span class="op">;</span>    <span class="co">// default value 0</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    Green<span class="op">;</span>  <span class="co">// default value 1</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    Blue    <span class="co">// default value 2</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>simple_enumerator <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>cast<span class="op">(</span>s32<span class="op">)</span> Color<span class="op">.</span>Red <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>cast<span class="op">(</span>s32<span class="op">)</span> Color<span class="op">.</span>Green <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>cast<span class="op">(</span>s32<span class="op">)</span> Color<span class="op">.</span>Blue <span class="op">==</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Base type is s32</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>Color<span class="op">)</span> <span class="op">==</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Declare variable of type Color with value Red</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    color <span class="op">:=</span> Color<span class="op">.</span>Red<span class="op">;</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>cast<span class="op">(</span>s32<span class="op">)</span> color <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a><span class="co">// Enum declaration (base type is u8)</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>Day <span class="op">::</span> <span class="kw">enum</span> u8 <span class="op">{</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    Sat <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// first value explicitly set to 1</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    Sun<span class="op">;</span>     <span class="co">// implicitly set to previous value + 1 -&gt; 2</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    Mon<span class="op">;</span>     <span class="co">// 3</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    Tue<span class="op">;</span>     <span class="co">// ...</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    Wed<span class="op">;</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    Thu<span class="op">;</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>    Fri</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>test_enumerator <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Day */</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>cast<span class="op">(</span>s32<span class="op">)</span> Day<span class="op">.</span>Sat <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>cast<span class="op">(</span>s32<span class="op">)</span> Day<span class="op">.</span>Sun <span class="op">==</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>cast<span class="op">(</span>s32<span class="op">)</span> Day<span class="op">.</span>Mon <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Base type is u8</span></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>Day<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="enum-flags">Enum flags</h2>
<p>An enumerator can be used as a definition of bit flags by adding #flags directive to the type definition. This directive slightly changes the way how the enumerator values are generated. By default, the enumerator starts with zero variant (if it’s not explicitly changed by the programmer) and every following enumerator variant has a value set to the previous one plus one. The flags enumerator start with the first variant set to 1 and the following variants are set to the left-bit-shifted value of the previous one.</p>
<p>Enumerators marked as flags are also serialized as a combination of atomic flags instead of just one value.</p>
<p><strong>note:</strong> Flags enumerators must use unsigned number type as a base type (<code>u32</code> by default).</p>
<p><strong>note:</strong> It’s possible to do implicit casting of flags enumerators to it’s base type.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>OpenMode <span class="op">::</span> <span class="kw">enum</span> #flags <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    Read<span class="op">;</span>   <span class="co">// 1</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    Write<span class="op">;</span>  <span class="co">// 2</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    Append<span class="op">;</span> <span class="co">// 4</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    Create<span class="op">;</span> <span class="co">// 8</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    WriteAppend <span class="op">=</span> Write <span class="op">|</span> Append<span class="op">;</span> <span class="co">// Combination of multiple variants.</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    WriteCreate <span class="op">=</span> Write <span class="op">|</span> Create<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">:</span> OpenMode<span class="op">;</span> <span class="co">// Set to OpenMode.Read by default</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    mode <span class="op">=</span> OpenMode<span class="op">.</span>WriteCreate<span class="op">;</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;mode = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> mode<span class="op">);</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set flag</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    set_flag<span class="op">(&amp;</span>mode<span class="op">,</span> OpenMode<span class="op">.</span>Append<span class="op">);</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;mode = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> mode<span class="op">);</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check flag</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> is_flag<span class="op">(</span>mode<span class="op">,</span> OpenMode<span class="op">.</span>Append<span class="op">)</span> <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;Append is enabled!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Clear flag</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    clr_flag<span class="op">(&amp;</span>mode<span class="op">,</span> OpenMode<span class="op">.</span>Append<span class="op">);</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>hint:</strong> Since flags enumerators starts implicitly with value 1, you can explicitly define <code>NoFlag = 0;</code> variant at the beginning of the variant list.</p>
<h2 id="type-aliasing">Type aliasing</h2>
<p>It’s possible to create alias to any data type except function types, those can be referenced only by pointers.</p>
<pre class="text"><code>&lt;alias name&gt; :: &lt;type&gt;;</code></pre>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>alias <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    T <span class="op">::</span> s32<span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:</span> T<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="function-type">Function type</h2>
<p>Type of function.</p>
<pre class="text"><code>fn ([arguments]) [T|(T1, T2)]</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">// type of function without arguments and without return value</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>fn <span class="op">()</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">// type of function without arguments, returning value of &#39;s32&#39; type</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>fn <span class="op">()</span> s32</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co">// type of function with two arguments, returning value of &#39;s32&#39; type</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>fn <span class="op">(</span>s32<span class="op">,</span> <span class="dt">bool</span><span class="op">)</span> s32</span></code></pre></div>
<h2 id="type-casting">Type casting</h2>
<p>Change type of value to the other type. Conventions between integer types, from pointer to <code>bool</code> and from array to slice are generated implicitly by the compiler.</p>
<pre class="text"><code>cast(&lt;T&gt;) &lt;expr&gt;</code></pre>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>type_cast <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// default type of integer literal is &#39;s32&#39;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> <span class="dv">666</span><span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// type of the integer literal is changed to u64</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    j <span class="op">:</span> u16 <span class="op">=</span> <span class="dv">666</span><span class="op">;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// implicit cast on function call</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    fn <span class="op">(</span>num<span class="op">:</span> u64<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="op">(</span>j<span class="op">);</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// explicit cast of &#39;f32&#39; type to &#39;s32&#39;</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    l <span class="op">:=</span> <span class="fl">1.5</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    m <span class="op">:=</span> cast<span class="op">(</span>s32<span class="op">)</span> l<span class="op">;</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Biscuit type casting rules are more strict compared to C or C++, there are no void pointers or implicit conversion between integers and enums etc. Despite this fact an explicit cast can be in some cases replaced by auto cast. The auto cast operator does not need explicit destination type notation, it will automatically detect destination type based on expression if possible. When auto operator cannot detect type, it will keep expression’s type untouched. In such case auto does not generate any instructions into IR.</p>
<pre class="text"><code>auto &lt;expr&gt;</code></pre>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>type_auto_cast <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    s32_ptr <span class="op">:</span> <span class="op">*</span>s32<span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    u32_ptr <span class="op">:</span> <span class="op">*</span>u32<span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// auto cast from *u32 to *s32</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    s32_ptr <span class="op">=</span> <span class="dt">auto</span> u32_ptr<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// keep expession type s32</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> <span class="dt">auto</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<hr />
<h2 id="simple-literals">Simple literals</h2>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>b <span class="op">::</span> true<span class="op">;</span>         <span class="co">// bool true literal</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">::</span> false<span class="op">;</span>        <span class="co">// bool false literal</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>ptr <span class="op">:</span> <span class="op">*</span>s32 <span class="op">=</span> null<span class="op">;</span> <span class="co">// *s32 null pointer literal</span></span></code></pre></div>
<h2 id="integer-literals">Integer literals</h2>
<p>Biscuit language provides constant integer literals written in various formats showed in example section. Integer literals has volatile type, when desired type is not specified compiler will choose best type to hold the value. Numbers requiring less space than 32 bits will be implicitly set to s32, numbers requiring more space than 31 bits and less space than 64 bits will be set to s64 and numbers requiring 64 bits will be set to u64 type. Bigger numbers are not supported and compiler will complain. When we specify type explicitly (ex.: foo : u8 : 10;), integer literal will inherit that type.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>i     <span class="op">::</span> <span class="dv">10</span><span class="op">;</span>      <span class="co">// s32 literal</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>i_u8  <span class="op">:</span> u8 <span class="op">:</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// u8 literal</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>i_hex <span class="op">::</span> <span class="bn">0x10</span><span class="op">;</span>    <span class="co">// s32 literal</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>i_bin <span class="op">::</span> <span class="bn">0b1011</span><span class="op">;</span>  <span class="co">// s32 literal</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>f     <span class="op">::</span> <span class="fl">13.43</span><span class="bu">f</span><span class="op">;</span>  <span class="co">// f32 literal</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>d     <span class="op">::</span> <span class="fl">13.43</span><span class="op">;</span>   <span class="co">// f64 literal</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span>  <span class="op">::</span> <span class="ch">&#39;i&#39;</span><span class="op">;</span>     <span class="co">// u8 literal</span></span></code></pre></div>
<h2 id="binary-operators">Binary Operators</h2>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>Addition.</td>
</tr>
<tr class="even">
<td>-</td>
<td>Subtraction.</td>
</tr>
<tr class="odd">
<td>*</td>
<td>Multiplication.</td>
</tr>
<tr class="even">
<td>/</td>
<td>Division.</td>
</tr>
<tr class="odd">
<td>%</td>
<td>Remainder division.</td>
</tr>
<tr class="even">
<td>+=</td>
<td>Addition and assign.</td>
</tr>
<tr class="odd">
<td>-=</td>
<td>Subtraction and assign.</td>
</tr>
<tr class="even">
<td>*=</td>
<td>Multiplication and assign.</td>
</tr>
<tr class="odd">
<td>/=</td>
<td>Division and assign.</td>
</tr>
<tr class="even">
<td>%=</td>
<td>Remainder division and assign.</td>
</tr>
<tr class="odd">
<td>&lt;</td>
<td>Less.</td>
</tr>
<tr class="even">
<td>&gt;</td>
<td>Greater.</td>
</tr>
<tr class="odd">
<td>&lt;=</td>
<td>Less or equals.</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>Greater or equals.</td>
</tr>
<tr class="odd">
<td>==</td>
<td>Equals.</td>
</tr>
<tr class="even">
<td>&amp;&amp;</td>
<td>Logical AND.</td>
</tr>
<tr class="odd">
<td>||</td>
<td>Logical OR.</td>
</tr>
<tr class="even">
<td>&amp;</td>
<td>Bit AND.</td>
</tr>
<tr class="odd">
<td>|</td>
<td>Bit OR.</td>
</tr>
<tr class="even">
<td>^</td>
<td>Bit XOR.</td>
</tr>
<tr class="odd">
<td>&amp;=</td>
<td>Bit AND and assign.</td>
</tr>
<tr class="even">
<td>|=</td>
<td>Bit OR and assign.</td>
</tr>
<tr class="odd">
<td>^=</td>
<td>Bit XOR and assign.</td>
</tr>
<tr class="even">
<td>&lt;&lt;</td>
<td>Bitshift left.</td>
</tr>
<tr class="odd">
<td>&gt;&gt;</td>
<td>Bitshift right.</td>
</tr>
</tbody>
</table>
<h2 id="unary-operators">Unary Operators</h2>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>Positive value.</td>
</tr>
<tr class="even">
<td>-</td>
<td>Negative value.</td>
</tr>
<tr class="odd">
<td>@</td>
<td>Pointer dereference.</td>
</tr>
<tr class="even">
<td>&amp;</td>
<td>Address of.</td>
</tr>
<tr class="odd">
<td>!</td>
<td>Logical not.</td>
</tr>
<tr class="even">
<td>~</td>
<td>Bit flip.</td>
</tr>
</tbody>
</table>
<h2 id="special-operators">Special Operators</h2>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Relevant for types</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sizeof(expr)</td>
<td>Any</td>
<td>Determinates size in bytes.</td>
</tr>
<tr class="even">
<td>alignof(expr)</td>
<td>Any</td>
<td>Determinates alignment of epression.</td>
</tr>
<tr class="odd">
<td>typeinfo(expr)</td>
<td>Any</td>
<td>Determinates TypeInfo of expression.</td>
</tr>
<tr class="even">
<td>typekind(expr)</td>
<td>Any</td>
<td>Determinates TypeKind of expression.</td>
</tr>
<tr class="odd">
<td>typeof(expr)</td>
<td>Any</td>
<td>Determinates type of expression.</td>
</tr>
</tbody>
</table>
<h2 id="type-info">Type Info</h2>
<p>Biscuit language provides type reflection allowing access to the type structure of the code. Pointer to the type information structure can be yielded by <code>typeinfo(&lt;T&gt;)</code> builtin operator call. Type information can be yielded in compile time and also in runtime, with low additional overhead for runtime (only pointer to the TypeInfo constant is pushed on the stack).</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>RTTI <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// yields pointer to TypeInfo constant structure</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    info <span class="op">:=</span> typeinfo<span class="op">(</span>s32<span class="op">);</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> info<span class="op">.</span>kind <span class="op">==</span> TypeKind<span class="op">.</span>INT <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// safe cast to *TypeInfoInt</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        info_int <span class="op">:=</span> cast<span class="op">(*</span>TypeInfoInt<span class="op">)</span> info<span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;bit_count = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> info_int<span class="op">.</span>bit_count<span class="op">);</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> info_int<span class="op">.</span>is_signed <span class="op">{</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>            print<span class="op">(</span><span class="st">&quot;signed</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>            print<span class="op">(</span><span class="st">&quot;unsigned</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>By calling the <code>typeinfo</code> operator compiler will automatically include desired type information into output binary.</p>
<h2 id="hash-directive">Hash directive</h2>
<p>Hash directives specify special compile-time information used by compiler. They are introduced by <code>#</code> character followed by directive name and optionally some other information.</p>
<h3 id="load">#load</h3>
<p>Load source file into the current assembly. Every file is included into the assembly only once even if we load it from multiple locations.</p>
<p>Lookup order:</p>
<ul>
<li>Current file parent directory.</li>
<li>BL API directory set in install location/etc/bl.conf.</li>
<li>System PATH environment variable.</li>
</ul>
<pre class="text"><code>#load &quot;&lt;bl file&gt;&quot;</code></pre>
<h3 id="import">#import</h3>
<p>Import module into current assembly.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="er">#import &quot;&lt;bl module&gt;&quot;</span></span></code></pre></div>
<h3 id="private">#private</h3>
<p>Creates private (file scope) block in the file. Everything after this is going to be private and visible only inside the current file.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">// main is public</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">();</span> <span class="co">// can be called only inside this file.</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="er">#private</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="co">// private function can be called only inside this file</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>foo <span class="op">::</span> fn <span class="op">()</span> <span class="op">{</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="co">// private constant</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>bar <span class="op">::</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<h3 id="scope">#scope</h3>
<p>Creates new named scope i.e. <code>#scope std</code>. Every symbol written after the <code>scope</code> tag lives in named scope (aka namespace). This prevents possible symbol collisions and makes local names shorter. Named scope cannot be nested in another one and can be specified only once per file unit. Scopes with the same name defined in multiple units are merged into one.</p>
<p>To refer to public symbols from the outside of the named scope use the scope name followed by the dot operator. (i.e. <code>std.compare</code>)</p>
<h3 id="extern">#extern</h3>
<p>Used for marking entities as an external (imported from dynamic library). Custom linkage name can be specified since version 0.5.2 as a string <code>#extern "malloc"</code>, when linkage name is not explicitly specified compiler will use name of the entity as linkage name.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// libc functions</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>malloc <span class="op">::</span> fn <span class="op">(</span>size<span class="op">:</span> usize<span class="op">)</span> <span class="op">*</span>u8 #extern<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co">// since 0.5.2</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>my_free <span class="op">::</span> fn <span class="op">(</span>ptr<span class="op">:</span> <span class="op">*</span>u8<span class="op">)</span> #extern <span class="st">&quot;free&quot;</span><span class="op">;</span></span></code></pre></div>
<h3 id="export">#export</h3>
<p>Mark symbol to be exported when compile into library. This can be used only for functions for now.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">// libc functions</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>my_func <span class="op">::</span> fn <span class="op">()</span> #export <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;Hello!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="compiler">#compiler</h3>
<p>Used for marking entities as an compiler internals.</p>
<p><strong>warning:</strong> This directive is compiler internal.</p>
<h3 id="test">#test</h3>
<p>Introduce test case function. The test case function is supposed not to take any arguments and return always <code>void</code>. All function with <code>test</code> hash directive are automatically stored into builtin implicit array and can be acquired by <code>testcases()</code> function call. Every test case is stored as <code>TestCase</code> type.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>this_is_my_test <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>   <span class="op">...</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="line">#line</h3>
<p>Fetch current line in source code as s32.</p>
<h3 id="file">#file</h3>
<p>Fetch current source file name string_view.</p>
<h3 id="noinit">#noinit</h3>
<p>Disable variable default initialization. This directive cannot be used with global variables (those must be initialized every time).</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>test_no_init <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    my_large_array<span class="op">:</span> <span class="op">[</span><span class="dv">1024</span><span class="op">]</span>u8 #noinit<span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="call_location">#call_location</h3>
<p>This directive yields pointer to static <code>CodeLocation</code> structure generated by compiler containing call-side location in code. The <code>call_location</code> can be used only as function argument default value. It’s useful in cases we want to know from where function was called.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>test_call_location <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    print_location<span class="op">();</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>print_location <span class="op">::</span> fn <span class="op">(</span>loc <span class="op">:=</span> #call_location<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> loc<span class="op">);</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="inline-and-no_inline">#inline and #no_inline</h3>
<p>Function related directives giving the compiler information about possibility of inlining marked function during optimization pass.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>my_inline_function <span class="op">::</span> fn <span class="op">()</span> #inline <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>   <span class="op">...</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="base">#base</h3>
<p>Specify base type of structure.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>Type <span class="op">::</span> <span class="kw">struct</span> #base s32 <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>   <span class="op">...</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="entry">#entry</h3>
<p>Specify executable entry function.</p>
<p><strong>warning:</strong> This directive is compiler internal.</p>
<h3 id="build_entry">#build_entry</h3>
<p>Specify build system entry function.</p>
<h3 id="tag">#tag</h3>
<p>Specify struct member tag. This value can be evaluated by type info.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>NO_SERIALIZE <span class="op">::</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>NO_GUI <span class="op">::</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>Type <span class="op">::</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    i<span class="op">:</span> s32 #tag NO_SERIALIZE <span class="op">|</span> NO_GUI<span class="op">;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="intrinsic">#intrinsic</h3>
<p>Mark external function as compiler specific intrinsic function.</p>
<p><strong>warning:</strong> This directive is compiler internal.</p>
<h3 id="maybe_unused">#maybe_unused</h3>
<p>Suppress usage checking for declaration. This can be helpful i.e.: in case the polymorphic function is using some private global variables and the function is not used (the body is never generated). Such variable should not be reported as unused.</p>
<p>This is workaround to get rid of unwanted warning for now.</p>
<h3 id="comptime">#comptime</h3>
<p>Mark the function as compile-time executed function.</p>
<h2 id="variable">Variable</h2>
<p>Variable associate name with value of some type. Variables in BL can be declared as mutable or immutable, value of immutable variable cannot be changed and can be set only by variable initializer. Type of variable is optional when value is specified. Variables can be declared in local or global scope, local variable lives only in particular function during function execution, global variables lives during whole execution.</p>
<p>Variables without explicit initialization value are <code>zero initialized</code> (set to default value). We can suppress this behaviour by <code>#noinit</code> directive. Global variables must be initialized every time (explicitly or zero initialized) so <code>#noinit</code> cannot be used.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>mutable_variables <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:</span> s32 <span class="op">=</span> <span class="dv">666</span><span class="op">;</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    j <span class="op">:=</span> <span class="dv">666</span><span class="op">;</span> <span class="co">// type is optional here</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// value can be changed</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>immutable_variables <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:</span> s32 <span class="op">:</span> <span class="dv">666</span><span class="op">;</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    j <span class="op">::</span> <span class="dv">666</span><span class="op">;</span> <span class="co">// type is optional here</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// value cannot be changed</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>variable_initialization <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    i<span class="op">:</span> s32<span class="op">;</span> <span class="co">// implicitly initialized to 0</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    arr<span class="op">:</span> <span class="op">[</span><span class="dv">1024</span><span class="op">]</span>u8 #noinit<span class="op">;</span> <span class="co">// not initialized</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>hint</strong>: Prefer immutable variables as possible, immutable value can be effectively optimized by compiler and could be evaluated in compile time in some cases.</p>
<h2 id="compound-expression">Compound expression</h2>
<p>Compound expression can be used for inline initialization of variables or directly as value. Implicit temporary variable is created as needed. Zero initializer can be used as short for memset(0) call.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>array_compound <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// print out all array values</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    print_arr <span class="op">::</span> fn <span class="op">(</span>v<span class="op">:</span> <span class="op">[</span><span class="dv">2</span><span class="op">]</span>s32<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>        loop i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v<span class="op">.</span>len<span class="op">;</span> i <span class="op">+=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>            print<span class="op">(</span><span class="st">&quot;v[%] = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> v<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// create array of 2 elements directly in call</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    print_arr<span class="op">([</span><span class="dv">2</span><span class="op">]</span>s32<span class="op">.{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">});</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// create zero initialized array</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    print_arr<span class="op">([</span><span class="dv">2</span><span class="op">]</span>s32<span class="op">.{</span><span class="dv">0</span><span class="op">});</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>struct_compound <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    Foo <span class="op">::</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>        i<span class="op">:</span> s32<span class="op">;</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>        j<span class="op">:</span> s32</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>    print_strct <span class="op">::</span> fn <span class="op">(</span>v<span class="op">:</span> Foo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;v.i = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> v<span class="op">.</span>i<span class="op">);</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;v.j = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> v<span class="op">.</span>j<span class="op">);</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// create structure in call</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>    print_strct<span class="op">(</span>Foo<span class="op">.{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">});</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// create zero initialized structure</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>    print_strct<span class="op">(</span>Foo<span class="op">.{}});</span></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="function">Function</h2>
<p>Function is chunk of code representing specific piece of program functionality. Function can be called with call operator <code>()</code>, we can provide any number of arguments into function and get return value back on call-side.</p>
<p>Functions can be declared in global or local scope (one function can be nested in other).</p>
<h3 id="named-function">Named function</h3>
<p>Function associated with name can be later called by this name. In this case we treat function like immutable variable.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">// named function</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>my_function <span class="op">::</span> fn <span class="op">()</span> <span class="op">{</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;Hello!!!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>my_function_with_return_value <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>my_function_with_arguments <span class="op">::</span> fn <span class="op">(</span>i<span class="op">:</span> s32<span class="op">,</span> j<span class="op">:</span> s32<span class="op">)</span> s32 <span class="op">{</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i <span class="op">+</span> j<span class="op">;</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>test_fn <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// call function by name</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    my_function<span class="op">();</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>    result1 <span class="op">::</span> my_function_with_return_value<span class="op">();</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>    result2 <span class="op">::</span> my_function_with_arguments<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="anonymous-function">Anonymous function</h3>
<p>Functions can be used without explicit name defined and can be directly called.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>test_anonymous_function <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> fn <span class="op">(</span>i<span class="op">:</span> s32<span class="op">)</span> s32 <span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="op">(</span><span class="dv">666</span><span class="op">);</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="function-pointer">Function pointer</h3>
<p>Functions can be called via pointer. Call on null pointer will produce error in interpreter.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>test_fn_pointers <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    foo <span class="op">::</span> fn <span class="op">()</span> <span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;Hello from foo!!!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    bar <span class="op">::</span> fn <span class="op">()</span> <span class="op">{</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;Hello from bar!!!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Grab the pointer of &#39;foo&#39;</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    fn_ptr <span class="op">:=</span> <span class="op">&amp;</span>foo<span class="op">;</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Call via pointer reference.</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    fn_ptr<span class="op">();</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    fn_ptr <span class="op">=</span> <span class="op">&amp;</span>bar<span class="op">;</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    fn_ptr<span class="op">();</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="function-with-variable-argument-count">Function with variable argument count</h3>
<p>Biscuit supports functions with variable argument count of the same type. VArgs type must be last in function argument list. Compiler internally creates temporary array of all arguments passed in vargs. Inside function body variable argument list acts like regular array slice.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>sum <span class="op">::</span> fn <span class="op">(</span>nums<span class="op">:</span> <span class="op">...</span>s32<span class="op">)</span> s32 <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// nums is slice of s32</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    result <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    loop i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>len<span class="op">;</span> i <span class="op">+=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>        result <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>test_vargs <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    s <span class="op">:=</span> sum<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">);</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>s <span class="op">==</span> <span class="dv">60</span><span class="op">);</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> sum<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span></span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>s <span class="op">==</span> <span class="dv">30</span><span class="op">);</span></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> sum<span class="op">();</span></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>s <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="local-function">Local function</h3>
<p>Function can be declared even in local scope of another function. Local-scoped functions does not capture variables from parent scope (scope of the upper_func in example), this leads to some restrictions. You cannot access i variable declared in upper_func from the inner_func.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>upper_func <span class="op">::</span> fn <span class="op">()</span> <span class="op">{</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">// local for upper_func</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    inner_func <span class="op">::</span> fn <span class="op">()</span> <span class="op">{</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>        i <span class="op">:=</span> <span class="dv">20</span><span class="op">;</span> <span class="co">// local for inner_func (no capture)</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="default-argument-value">Default argument value</h3>
<p>Function arguments can use default value if value is not provided on call side. Default value must be known in compile time.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>foo <span class="op">::</span> fn <span class="op">(</span>i<span class="op">:</span> s32<span class="op">,</span> j <span class="op">:=</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>test_foo <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// here we call foo only with one argument so j will</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use default value 10</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explicit-function-overloading">Explicit function overloading</h3>
<p>More functions can be associated with one name with explicit function overloading groups. Call to group of functions is replaced with proper function call during compilation, based on provided arguments.</p>
<p><strong>note:</strong> There is no additional runtime overhead caused by function overloading.</p>
<p><strong>note:</strong> Ordering of functions inside the group is arbitrary.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>group <span class="op">::</span> fn <span class="op">{</span> s32_add<span class="op">;</span> f32_add<span class="op">;</span> <span class="op">}</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>s32_add <span class="op">::</span> fn <span class="op">(</span>a<span class="op">:</span> s32<span class="op">,</span> b<span class="op">:</span> s32<span class="op">)</span> s32 <span class="op">{</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>f32_add <span class="op">::</span> fn <span class="op">(</span>a<span class="op">:</span> f32<span class="op">,</span> b<span class="op">:</span> f32<span class="op">)</span> f32 <span class="op">{</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>test_group <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    i <span class="op">::</span> group<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>    j <span class="op">::</span> group<span class="op">(</span><span class="fl">0.2</span><span class="bu">f</span><span class="op">,</span> <span class="fl">13.534</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;i = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;j = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Functions can be declared directly inside the overload group:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>group <span class="op">::</span> fn <span class="op">{</span> </span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    fn <span class="op">(</span>a<span class="op">:</span> s32<span class="op">,</span> b<span class="op">:</span> s32<span class="op">)</span> s32 <span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    fn <span class="op">(</span>a<span class="op">:</span> f32<span class="op">,</span> b<span class="op">:</span> f32<span class="op">)</span> f32 <span class="op">{</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Overload Resolution</strong></p>
<p>When function group is called the function overload resolution takes into account multiple options to sort all possible call candidates by its priority. Candidate function with the highest priority is used. In case there are multiple functions with the same priority found in the group, compiler complains about ambiguous function call. In case there is no call candidate, the first one is used. This usually leads to an error later if the function interface is not compatible.</p>
<p><strong>The overload resolution is based on:</strong></p>
<ol type="1">
<li>Argument count.</li>
<li>Argument types.</li>
<li>Type casting.</li>
<li>Conversion to slice.</li>
<li>Conversion to any.</li>
</ol>
<p><strong>note:</strong> The return type has no effect on choosing the best call candidate.</p>
<p><strong>Resolving of the best call candidate is done in two passes:</strong></p>
<ol type="1">
<li>Pick all possible candidates based on call-side argument count when:
<ul>
<li>Argument count is exactly matching the count of arguments required by the function interface.</li>
<li>All arguments up to the first defaulted or variadic argument in the function interface are provided.</li>
</ul></li>
<li>Iterate over previously picked functions and rank them comparing call-side arguments with the each function’s interface arguments one by one:
<ul>
<li>Type is exactly the same. (Rank +3)</li>
<li>Can be implicitly casted. (Rank +2)</li>
<li>Can be implicitly converted. (Rank +2)</li>
<li>Can be implicitly converted <code>Any</code>. (Rank +1)</li>
<li>Can be added into vargs. (Rank +1)</li>
</ul></li>
<li>Use function with highest rank.</li>
</ol>
<p><strong>Examples:</strong></p>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">::</span> fn <span class="op">(</span>_<span class="op">:</span> <span class="op">[]</span>u8<span class="op">)</span>                <span class="op">{}</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">::</span> fn <span class="op">(</span>_<span class="op">:</span> string<span class="op">)</span>              <span class="op">{}</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">::</span> fn <span class="op">(</span>_<span class="op">:</span> Any<span class="op">)</span>                 <span class="op">{}</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>d <span class="op">::</span> fn <span class="op">(</span>_<span class="op">:</span> s32<span class="op">,</span> _<span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> true<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>group <span class="op">::</span> fn <span class="op">{</span> a<span class="op">;</span> b<span class="op">;</span> c<span class="op">;</span> d<span class="op">;</span> <span class="op">}</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="co">// a: rank = 3 &lt;- used </span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a><span class="co">// b: rank = 0  </span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a><span class="co">// c: rank = 1</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a><span class="co">// d: rank = 0</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>group<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">);</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a><span class="co">// a: rank = 2 (can be implicitly converted to []u8)</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a><span class="co">// b: rank = 3 &lt;- used </span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a><span class="co">// c: rank = 1</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a><span class="co">// d: rank = 0</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>str<span class="op">:</span> string<span class="op">;</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>group<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a><span class="co">// a: rank = 0 </span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a><span class="co">// b: rank = 0 </span></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a><span class="co">// c: rank = 1</span></span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a><span class="co">// d: rank = 3 &lt;- used</span></span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a>group<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a><span class="co">// a: rank = 0 </span></span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a><span class="co">// b: rank = 0 </span></span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a><span class="co">// c: rank = 0</span></span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a><span class="co">// d: rank = 6 &lt;- used</span></span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a>group<span class="op">(</span><span class="dv">10</span><span class="op">,</span> false<span class="op">);</span></span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a><span class="co">// a: rank = 0 </span></span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a><span class="co">// b: rank = 0 </span></span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a><span class="co">// c: rank = 1</span></span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true" tabindex="-1"></a><span class="co">// d: rank = 2 &lt;- used (implicitly casted s8 to s32)</span></span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true" tabindex="-1"></a>i<span class="op">:</span> s8<span class="op">;</span></span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true" tabindex="-1"></a>group<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span></code></pre></div>
<h3 id="polymorphic-functions">Polymorphic functions</h3>
<p><a href="examples/polymorph.bl">How-To</a></p>
<p>Polymorphic function (aka templated function or generic function) is a well-known concept in many programming languages. It’s a sort of meta-programming method providing good type safety and proper error reporting. The basic idea is the automatic generation of functions doing the same operation using multiple types, instead of rewriting the function for every type needed, we just specify it as a “recipe” for later generations.</p>
<p>Consider the following function doing an addition of two values, when we want to use the function with multiple different types, we must explicitly rewrite the same function for every type needed:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>add_s32 <span class="op">::</span> fn <span class="op">(</span>a<span class="op">:</span> s32<span class="op">,</span> b<span class="op">:</span> s32<span class="op">)</span> s32 <span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Same for floats.</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>add_f32 <span class="op">::</span> fn <span class="op">(</span>a<span class="op">:</span> f32<span class="op">,</span> b<span class="op">:</span> f32<span class="op">)</span> f32 <span class="op">{</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this case, we can use polymorph instead:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>add <span class="op">::</span> fn <span class="op">(</span>a<span class="op">:</span> <span class="op">?</span>T<span class="op">,</span> b<span class="op">:</span> T<span class="op">)</span> T <span class="op">{</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Value of <code>T</code> represents any type, in this case, chosen based on usage of the function. The question mark before <code>T</code> says the first <code>T</code> is the master polymorph type. The compiler tries to replace all master types with the type of argument on the call side and register the new type alias <code>T</code> in the function scope.</p>
<p>Example of usage:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    result_1 <span class="op">:</span> s32 <span class="op">=</span> add<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    result_2 <span class="op">:</span> f32 <span class="op">=</span> add<span class="op">(</span><span class="fl">1.4</span><span class="bu">f</span><span class="op">,</span> <span class="fl">42.5</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that we call the same function, first with integers and second with floats. The type of <code>T</code> is based on the first argument type (because the master type is defined as the type of the first argument). The second argument type, in this case, must be the same type as the master because <code>b</code> use, as its type, alias <code>T</code>. The same alias is used also as a return type.</p>
<p>So two functions are generated internally:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>add<span class="fl">.1</span> <span class="op">::</span> fn <span class="op">(</span>a<span class="op">:</span> s32<span class="op">,</span> b<span class="op">:</span> s32<span class="op">)</span> s32 <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>add<span class="fl">.2</span> <span class="op">::</span> fn <span class="op">(</span>a<span class="op">:</span> f32<span class="op">,</span> b<span class="op">:</span> f32<span class="op">)</span> f32 <span class="op">{</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>note:</strong> Content of polymorphic function is semantically analyzed only when function is used.</p>
<h4 id="nested-master-type">Nested master type</h4>
<p>Polymorph master type replacement can be used also as nested member in more complex types.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>sum <span class="op">::</span> fn <span class="op">(</span>slice<span class="op">:</span> <span class="op">[]?</span>T<span class="op">)</span> T <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    result<span class="op">:</span> T<span class="op">;</span> <span class="co">// We can use T inside the function as well</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    loop i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> slice<span class="op">.</span>len<span class="op">;</span> i <span class="op">+=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>        result <span class="op">+=</span> slice<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Sum function accepts any slice as an input and any array is implicitly convertible</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="co">// to slice.</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Use the function with static array</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>arr_static <span class="op">:=</span> <span class="op">[</span><span class="dv">3</span><span class="op">]</span>s32<span class="op">.{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">};</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>sum<span class="op">(</span>arr_static<span class="op">);</span> <span class="co">// T = s32</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Use the function with dynamic array</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>arr_dynamic<span class="op">:</span> <span class="op">[..]</span>f32<span class="op">;</span></span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>defer array_terminate<span class="op">(&amp;</span>arr_dynamic<span class="op">);</span></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>array_push<span class="op">(&amp;</span>arr_dynamic<span class="op">,</span> <span class="fl">10.</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>array_push<span class="op">(&amp;</span>arr_dynamic<span class="op">,</span> <span class="fl">20.</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>array_push<span class="op">(&amp;</span>arr_dynamic<span class="op">,</span> <span class="fl">30.</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>sum<span class="op">(</span>arr_dynamic<span class="op">);</span> <span class="co">// T = f32</span></span></code></pre></div>
<h4 id="multiple-polymorph-masters">Multiple polymorph masters</h4>
<p>More than one polymorphic masters can be declared inside the function argument list:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>table_insert <span class="op">::</span> fn <span class="op">(</span>table<span class="op">:</span> <span class="op">*</span>Table<span class="op">,</span> key<span class="op">:</span> <span class="op">?</span>TKey<span class="op">,</span> value<span class="op">:</span> <span class="op">?</span>TValue<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="specify-implementation-for-type">Specify implementation for type</h4>
<p>In some cases we want to specify explicitly what implementation should be used for some specific type, i.e. in a function doing comparison of two values, we can provide specific handling for string:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>is_equal <span class="op">::</span> fn <span class="op">{</span> <span class="co">// function group</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Implementation used for strings only.</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    fn <span class="op">(</span>a<span class="op">:</span> string_view<span class="op">,</span> b<span class="op">:</span> string_view<span class="op">)</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> std<span class="op">.</span>str_compare<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Implementation used for all other types.</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    fn <span class="op">(</span>a<span class="op">:</span> <span class="op">?</span>T<span class="op">,</span> b<span class="op">:</span> T<span class="op">)</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">==</span> b<span class="op">;</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>note:</strong> Compiler error is reported in case content of the polymorph generated for some type specification is not semantically valid. (i.e. we can’t compare strings directly by <code>==</code> operator)</p>
<p><strong>warning:</strong> Getting address (by <code>&amp;</code> operator) of polymorphic function recipe is not possible, polymorphic recipe as it is does not represent any allocated memory in program binary.</p>
<h3 id="multiple-return-values">Multiple Return Values</h3>
<p>Function in BL can return more than one value, this can be useful i.e. in cases we want to return value and error code. There is no explicit limitation of returned value count. Return value can be also named to make the function interface more readable.</p>
<p>Returned values are implicitly converted to anonymous structure instances with possibility to implicitly unroll results on caller side.</p>
<p>Use unnamed identifier to ignore some of returned values on caller side.</p>
<p>Example of multiple return:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>foo <span class="op">::</span> fn <span class="op">()</span> <span class="op">(</span>s32<span class="op">,</span> <span class="dt">bool</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">666</span><span class="op">,</span> true<span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    int1<span class="op">,</span> boolean1 <span class="op">:=</span> foo<span class="op">();</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// no all values must be captured</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    int2 <span class="op">:=</span> foo<span class="op">();</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Example of multiple return with named values:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>foo <span class="op">::</span> fn <span class="op">()</span> <span class="op">(</span>number<span class="op">:</span> s32<span class="op">,</span> boolean<span class="op">:</span> <span class="dt">bool</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">666</span><span class="op">,</span> true<span class="op">;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    int1<span class="op">,</span> boolean1 <span class="op">:=</span> foo<span class="op">();</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>    _<span class="op">,</span> b <span class="op">:=</span> foo<span class="op">();</span> <span class="co">// Ignore first returned value.</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="comptime-function">Comptime Function</h3>
<p>The <code>comptime</code> function is every function marked by <code>#comptime</code> hash directive in a declaration. Every call to such a function is going to be evaluated in compile-time and replaced by constant eventually.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>hash_string <span class="op">::</span> fn <span class="op">(</span>s<span class="op">:</span> string_view<span class="op">)</span> u32 #comptime <span class="op">{</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> std<span class="op">.</span>str_hash<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>hash</code> function can be later called as any other regular function, but the call itself is replaced by constant result in the final binary.</p>
<pre><code>main :: fn () s32 {
    hash := hash_string(&quot;Hello!&quot;);
    print(&quot;%\n&quot;, hash);
    return 0;
}</code></pre>
<p>So the comptime function has no runtime overhead.</p>
<p><strong>List of cons:</strong></p>
<ol type="1">
<li>Every argument passed, must be known in compile-time.</li>
<li>All arguments inside the function are constant (we cannot change it’s values).</li>
<li>Returning pointers from comptime functions is not a good idea in general (i.e. addresses of functions in compile-time are not the same in runtime).</li>
</ol>
<p><strong>List of pros:</strong></p>
<ol type="1">
<li>We can pass any type as a value to the comptime function.</li>
<li>We can return any type as a value.</li>
<li>Since all comptime functions are evaluated in compile-time, there is no runtime overhead.</li>
</ol>
<h2 id="block">Block</h2>
<p>Block can limit scope of the variable.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="er">#import &quot;std/test&quot;</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>blocks <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    a <span class="op">:=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this variable lives only in this scope</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>       i <span class="op">:=</span> a<span class="op">;</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>       assert<span class="op">(</span>i <span class="op">==</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>i <span class="op">==</span> <span class="dv">20</span><span class="op">);</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="if---else">If - Else</h2>
<p>If represents condition statement which can change program flow. If executes following code block only if passed condition is <code>true</code>, otherwise skip the block and continue on next statement after the block. We can specify <code>else</code> block which is executed only if condition is <code>false</code>.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>test_ifs <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    b <span class="op">:=</span> true<span class="op">;</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b <span class="op">{</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;b is true!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;b is false!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>If statement can be static. In this case the condition must be known in compile time. Static ifs are evaluated during compilation and can be used i.e. for including/excluding some parts of code based on some constant expression.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>test_static_ifs <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if IS_DEBUG {</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;This is compiled in debug mode!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;This is compiled in release mode!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>note:</strong> The excluded branch is removed completely from compilation, but it still has to be semantically valid.</p>
<h2 id="loop">Loop</h2>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>simple_loops <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">::</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    loop <span class="op">{</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> count <span class="op">{</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>    loop i <span class="op">&lt;</span> count <span class="op">{</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    loop j <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> count<span class="op">;</span> j <span class="op">+=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do something amazing here</span></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="break-and-continue">Break and continue</h2>
<p>Break/continue statements can be used in loops to control execution flow.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>break_and_continue <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    loop <span class="op">{</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">10</span> <span class="op">{</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="switch">Switch</h2>
<p>Switch can compare one numeric value against multiple values and switch execution flow to matching case. The <code>default</code> case can be used for all other values we don’t explicitly specify case for.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>test_switch <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">:=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> i <span class="op">{</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span> <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;Zero!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;One!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span> <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;Other!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Switch can be also used with enumerators, in such case we have to specify cases for all enumerator variations or specify <code>default</code> one.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>Color <span class="op">::</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    Red<span class="op">;</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    Green<span class="op">;</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    Blue<span class="op">;</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>test_switch <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>    c <span class="op">:=</span> Color<span class="op">.</span>Blue<span class="op">;</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> c <span class="op">{</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>        Color<span class="op">.</span>Red   <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;Red!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>   <span class="op">}</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>        Color<span class="op">.</span>Green <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;Green!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>        Color<span class="op">.</span>Blue  <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;Blue!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="op">}</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// default is not needed here, we covered all variants.</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It’s also possible to define one execution block for multiple cases.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb76"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>Color <span class="op">::</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    Red<span class="op">;</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    Green<span class="op">;</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    Blue<span class="op">;</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>test_switch <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    c <span class="op">:=</span> Color<span class="op">.</span>Blue<span class="op">;</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> c <span class="op">{</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>        Color<span class="op">.</span>Red<span class="op">,</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>        Color<span class="op">.</span>Green <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;Red or green!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>        Color<span class="op">.</span>Blue  <span class="op">{</span> print<span class="op">(</span><span class="st">&quot;Blue!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="op">}</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="defer-statement">Defer statement</h2>
<p>The defer statement can be used for defering execution of some expression. All deferred expressions will be executed at the end of the current scope in reverse order. This is usually useful for calling cleanup functions. When scope is terminated by return all previous defers up the scope tree will be called after evaluation of return value.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>test_defer_example <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    defer print<span class="op">(</span><span class="st">&quot;1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>        defer print<span class="op">(</span><span class="st">&quot;2 &quot;</span><span class="op">);</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>        defer print<span class="op">(</span><span class="st">&quot;3 &quot;</span><span class="op">);</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>        defer print<span class="op">(</span><span class="st">&quot;4 &quot;</span><span class="op">);</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">// defer 4, 3, 2</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>    defer_with_return<span class="op">();</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>    defer print<span class="op">(</span><span class="st">&quot;5 &quot;</span><span class="op">);</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// defer 5, 1</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>defer_with_return <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>    defer print<span class="op">(</span><span class="st">&quot;6 &quot;</span><span class="op">);</span></span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>    defer print<span class="op">(</span><span class="st">&quot;7 &quot;</span><span class="op">);</span></span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> true <span class="op">{</span></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a>        defer print<span class="op">(</span><span class="st">&quot;8 &quot;</span><span class="op">);</span></span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb77-22"><a href="#cb77-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">// defer 8, 7, 6</span></span>
<span id="cb77-23"><a href="#cb77-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-24"><a href="#cb77-24" aria-hidden="true" tabindex="-1"></a>    defer print<span class="op">(</span><span class="st">&quot;9 &quot;</span><span class="op">);</span> <span class="co">// never reached</span></span>
<span id="cb77-25"><a href="#cb77-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb77-26"><a href="#cb77-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="ex">4</span> 3 2 8 7 6 5 1</span></code></pre></div>
<h2 id="using-statement">Using statement</h2>
<p>The using statement can be used to allow direct access to another scope’s or enum’s members.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    using my_scope<span class="op">;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Directly call function from my_scope.</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    print_kind<span class="op">(</span>Kind<span class="op">.</span>PLAYER<span class="op">);</span> </span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    print_kind<span class="op">(</span>Kind<span class="op">.</span>ENEMY<span class="op">);</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    using Kind<span class="op">;</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Directly use enum variants from my_scope.Kind.</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    print_kind<span class="op">(</span>PLAYER<span class="op">);</span> </span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>    print_kind<span class="op">(</span>ENEMY<span class="op">);</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a><span class="er">#scope my_scope</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>Kind <span class="op">::</span> <span class="kw">enum</span> <span class="op">{</span> PLAYER<span class="op">;</span> ENEMY<span class="op">;</span> <span class="op">}</span></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>print_kind <span class="op">::</span> fn <span class="op">(</span>k<span class="op">:</span> Kind<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;Kind is = %</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> k<span class="op">);</span></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Be careful with the <code>using</code> statement, ambiguous declaration references can be introduced easily. Scope lookup rules are following in case the <code>using</code> is present:</p>
<ul>
<li>Symbols declared in the function scope and its child scopes are preferred during lookup. In case there is a symbol of the same name in the used scope it’s ignored and a local one is used without warnings/errors.</li>
<li>In case a symbol with the same name is found in multiple used scopes, it’s reported as ambiguous.</li>
<li>In case a symbol from the used scope collides with a symbol in global/private scope, it’s also reported as ambiguous.</li>
</ul>
<p><strong>note:</strong> The <code>using</code> statement placement is limited to local scopes due to explicitness and readability of the code.</p>
<h2 id="main-function">Main function</h2>
<p>The <code>main</code> function is mandatory entry function which should be defined in every program. It’s basically entry point of your application. Main function must return <code>s32</code> execution state, zero in this case indicates successful execution.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// some useful stuff goes here.</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>hint</strong>: Command line arguments are not passed directly as parameter in BL. Use <code>command_line_arguments</code> builtin array.</p>
<h2 id="modules-and-import">Modules and import</h2>
<p>The module system can be used to split source into chunks (modules) which can be later imported into assembly by <code>#import</code> directive. Modules can distinguish between platforms and load different sources on them during the compilation process.</p>
<p>A module is basically directory containing <code>module.yaml</code> configuration file, the name of the directory is used as module name during import process.</p>
<p>See <code>ModuleImportPolicy</code> for more information about module import policy.</p>
<p><strong>note:</strong> Module root directory usually contains all source files, libraries and unit tests related to the module.</p>
<p><strong>Example of the module file structure:</strong></p>
<pre class="text"><code>thread/
  module.yaml       - module config
  _thread.win32.bl  - windows implementation
  _thread.posix.bl  - posix implementation
  thread.bl         - interface
  thread.test.bl    - unit tests</code></pre>
<p><strong>Example of the module config:</strong></p>
<div class="sourceCode" id="cb82"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="dv">4</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="fu">x86_64-pc-windows-msvc</span><span class="kw">:</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">src</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;_thread.win32.bl&quot;</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="fu">x86_64-pc-linux-gnu</span><span class="kw">:</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">src</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;_thread.posix.bl&quot;</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="fu">x86_64-apple-darwin</span><span class="kw">:</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">src</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;_thread.posix.bl&quot;</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a><span class="fu">arm64-apple-darwin</span><span class="kw">:</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">src</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;_thread.posix.bl&quot;</span></span></code></pre></div>
<p>To import the <code>thread</code> module use:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="er">#import &quot;path/to/module/thread&quot;</span></span></code></pre></div>
<h3 id="list-of-module-config-entries">List of module config entries</h3>
<p><strong>Global options:</strong> - <code>version: &lt;N&gt;</code> - Module version number used during import to distinguish various versions of same module, see also <code>ModuleImportPolicy</code> for more information.</p>
<p><strong>Global or platform specific options:</strong></p>
<ul>
<li><code>src: "&lt;FILE1[;FILE2;...]&gt;"</code> - List of source file paths relative to the module <em>root</em> directory separated by <strong>platform specific</strong> separator (<code>:</code> on Windows and <code>;</code> on Unix).</li>
<li><code>linker_opt: "&lt;OPTIONS&gt;"</code> - Additional linker options.</li>
<li><code>linker_lib_path: "&lt;DIR1;[DIR2;...]&gt;"</code> - Additional linker lookup directories relative to the module <em>root</em> directory.</li>
<li><code>link: "&lt;LIB1[;LIB2;...]&gt;</code> - Libraries to link.</li>
</ul>
<p><strong>Global vs local options</strong></p>
<p>Module platform specific options can be set in sub-groups starting with platform target triple name (use <code>blc --target-host</code> to get your current default target and <code>blc --target-supported</code> to get list of all supported targets).</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="dv">1</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="fu">src</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;my_file_imported_everytime.bl&quot;</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="fu">x86_64-pc-windows-msvc</span><span class="kw">:</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">src</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;my_file_only_for_windows.bl&quot;</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="fu">x86_64-pc-linux-gnu</span><span class="kw">:</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">src</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;my_file_only_for_linux.bl&quot;</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">linker_opt</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;-lc -lm&quot;</span><span class="co"> # link these only on linux</span></span></code></pre></div>
<h2 id="unit-testing">Unit testing</h2>
<p>Biscuit compiler provides unit testing by default.</p>
<p>Create unit test case:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="er">#import &quot;std/test&quot;</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="co">// function to be tested</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>add <span class="op">::</span> fn <span class="op">(</span>a<span class="op">:</span> s32<span class="op">,</span> b<span class="op">:</span> s32<span class="op">)</span> s32 <span class="op">{</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>this_is_OK <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>add<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">)</span> <span class="op">==</span> <span class="dv">30</span><span class="op">);</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>this_is_not_OK <span class="op">::</span> fn <span class="op">()</span> #test <span class="op">{</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>add<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">30</span><span class="op">);</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>main <span class="op">::</span> fn <span class="op">()</span> s32 <span class="op">{</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>    test_run<span class="op">();</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Run tests:</p>
<pre class="text"><code>$ blc -rt test.bl
Compiler version: 0.7.0, LLVM: 10
Compile assembly: out [DEBUG]
Target: x86_64-pc-windows-msvc

Testing start in compile time
--------------------------------------------------------------------------------
[ PASS |      ] this_is_OK (0.021000 ms)
assert [test.bl:21]: Assertion failed!
execution reached unreachable code
C:/Develop/bl/lib/bl/api/std/debug.bl:113:5
  112 |     if IS_DEBUG { _os_debug_break(); }
&gt; 113 |     unreachable;
      |     ^^^^^^^^^^^
  114 | };
called from:
C:/Develop/bl/tests/test.bl:21:11
  20 | this_is_not_OK :: fn () #test {
&gt; 21 |     assert(add(10, 20) != 30);
     |           ^
  22 | };
[      | FAIL ] this_is_not_OK (1.630000 ms)

Results:
--------------------------------------------------------------------------------
[      | FAIL ] this_is_not_OK (1.630000 ms)
--------------------------------------------------------------------------------
Executed: 2, passed 50%.
--------------------------------------------------------------------------------</code></pre>
<h2 id="use-bl-code-from-cc">Use BL code from C/C++</h2>
<p>Since BL compiler supports compilation into shared library, ABI compatible with C, BL code can be easily called from C/C++ program. Use <code>#export</code> to mark function to be exported from library and <code>--shared</code> flag to create shared object (<code>so</code> on Linux). See example bellow on Linux.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Content of my-lib.bl</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>my_bl_function <span class="op">::</span> fn <span class="op">(</span>count<span class="op">:</span> s32<span class="op">)</span> #export <span class="op">{</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    loop i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> count<span class="op">;</span> i <span class="op">+=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;Hello from foo library!!!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb88"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Content of main.c</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> my_bl_function<span class="op">(</span><span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    my_bl_function<span class="op">(</span><span class="dv">100</span><span class="op">);</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb89"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> blc <span class="at">--shared</span> my-lib.bl</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> gcc <span class="at">-L.</span> <span class="at">-o</span> test main.c <span class="at">-lout</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> export LD_LIBRARY_PATH=. <span class="kw">&amp;&amp;</span> <span class="ex">./test</span></span></code></pre></div>
<h2 id="builtin-variables">Builtin variables</h2>
<p>List of builtin variables set by compiler.</p>
<ul>
<li><code>IS_DEBUG</code> Is bool immutable variable set to true when assembly is running in debug mode.</li>
<li><code>IS_COMPTIME_RUN</code> Is bool immutable variable set to true when assembly is executed in compile time.</li>
</ul>
</body>
</html>
