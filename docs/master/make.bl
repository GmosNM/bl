#!blc --silent -run
#import "std/fs"

SRC_API_DIR :: "../../lib/bl/api";
TMP_DIR :: "tmp-docs";

PANDOC :: 
    "pandoc "
    "% "
    "--toc "
    "--toc-depth=2 "
    "--top-level-division=chapter "
    "--css ../static/styles.css "
    "--metadata=title:\"Biscuit Language (%)\" "
    "--metadata=lang:\"en-US\" "
    "--include-in-header=\"header.html\" "
    "--include-before-body=\"menu.html\" "
    "--standalone "
    "-o \"%\"";

IGNORE :: [3]string_view.{
           "sdl2",
           "glfw3",
           "gl",
          };

blc_ver :: fn () string #inline {
    return tprint("%.%.%", BLC_VER_MAJOR, BLC_VER_MINOR, BLC_VER_PATCH);
}

cmd :: fn (fmt: string_view, args: ...) Error {
    c :: tprint(fmt, args);
    state :: os_execute(c);
    if state != 0 {
        return error(state, "Executed shell command failed '%'!", c);
    }
    return ok();
}

html :: fn () Error {
    ver :: blc_ver();
    /*
    state := cmd(PANDOC, "index.md", ver, "index.html");
    if !is_ok(state) { return state; }
    state = cmd(PANDOC, "compiler.md", ver, "compiler.html");
    if !is_ok(state) { return state; }
    state = cmd(PANDOC, "language.md", ver, "language.html");
    if !is_ok(state) { return state; }
    state = cmd(PANDOC, "how-to.md", ver, "how-to.html");
    if !is_ok(state) { return state; }
    state = cmd(PANDOC, "api.md", ver, "api.html");
    if !is_ok(state) { return state; }

    //list, list_error :: list_files(TMP_DIR, "md");
    //if !is_ok(list_error) { return list_error; }
    //defer std.str_delete(&list);
    //return cmd(PANDOC, list, ver, "api.html");
    */
    return ok();
}

prepare :: fn () Error {
    print("Prepare\n");
    if std.path_exist(TMP_DIR) {
        err :: std.dir_remove_all(TMP_DIR);
        if !is_ok(err) { return err; }
    }
    err :: std.dir_create_all(TMP_DIR);
    if !is_ok(err) { return err; }
    return ok();
}

cleanup :: fn () Error {
    print("Cleanup\n");
    if std.path_exist(TMP_DIR) {
        //err :: std.dir_remove_all(TMP_DIR);
        //if !is_ok(err) { return err; }
    }
    return ok();
}

process_dir :: fn (path: string_view, extension: string_view, out: *string) Error {
    list, err :: std.dir_scan(path, &fn (info: *std.Info) bool {
        if std.str_is_empty(info.name)        { return false; }
        if std.str_match(info.name, ".")    { return false; }
        if std.str_match(info.name, "..")   { return false; }
        if std.str_match(info.name, "_", 1) { return false; }
        if info.kind == std.InfoKind.DIRECTORY {
            loop i := 0; i < IGNORE.len; i += 1 {
                if std.str_match(info.name, IGNORE[i]) { return false; }
            }
        }
        return true;
    });
    defer std.info_list_delete(list);
    if !is_ok(err) { return err; }

    loop i := 0; i < list.len; i += 1 {
        info :: &list[i];
        switch info.kind {
            std.InfoKind.FILE {
                file, ext: string_view;
                std.str_split_by_first(info.name, '.', &file, &ext);
                if std.str_match(ext, extension) { 
                    std.str_append(out, path);
                    std.str_append(out, "/");
                    std.str_append(out, info.name);
                    std.str_append(out, " ");
                }
            }
            std.InfoKind.DIRECTORY {
                new_path :: tprint("%/%", path, info.name);
                err :: process_dir(new_path, extension, out);
                if !is_ok(err) { return err; }
            }
        }
    }
    return ok();
}

list_files :: fn (dir: string_view, extension := "bl") (string, Error) {
    list :: std.str_new(128);
    err :: process_dir(dir, extension, &list);
    if !is_ok(err) { 
        std.str_delete(&list);
        return list, err;
    }
    return list, err;
}

docs_dir :: fn () Error {
    print("Process '%'\n", SRC_API_DIR);
    files, err_list :: list_files(SRC_API_DIR);
    if !is_ok(err_list) { return err_list; }
    defer std.str_delete(&files);
    if std.str_is_empty(files) { return ok(); }
    err_cmd :: cmd("blc -doc --doc-out-dir=\"%\" %", TMP_DIR, files);
    if !is_ok(err_cmd) { return err_cmd; }
    return ok();
}

main :: fn () s32 {
    defer std.temporary_release();
    print("Generate BL documentation...\n");
    e1:: prepare();
    if !is_ok(e1) { print_err("%", e1); return e1.code; }
    e2 :: docs_dir();
    if !is_ok(e2) { print_err("%", e2); return e2.code; }
    e3 :: html();
    if !is_ok(e3) { print_err("%", e3); return e3.code; }
    print("DONE!\n");
    e4 :: cleanup();
    if !is_ok(e4) { print_err("%", e4); return e4.code; }
    print("DONE!\n");
    return 0;
}
