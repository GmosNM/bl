#+TITLE: Biscuit-MIR Documentation
#+AUTHOR: Martin Dorazil
#+OPTIONS: toc:nil H:3 num:1 ^:nil pri:t
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org.css"/>

# now prints out the previously disabled (toc:nil) table of contents.
#+TOC: headlines 2

* About
 BL-MIR (Biscuit Language Middle Intermediate Representation) is a simplified representation of the Biscuit Language created from AST. It is located between AST and LLVM-IR. 

** MIR Interpreter
   BL Compiler has integrated interpreter for MIR. 
   
   - Default execution stack size is 2MB.
   - Stack allocations are 8 byte aligned.

** Assert function in MIR
 #+BEGIN_SRC blm
 @assert fn(bool) void {
 init_0:
   %0              *bool decl cond : bool
   %1               bool arg $0
   %3               void store %1 -> %0
   %11              void br entry_1
 
 entry_1:
   %5               bool load %0
   %6               bool unop !%5
   %7               void br %6 ? if_then_2 : if_else_3
 
 if_then_2:
   %8               void unreachable
   %9               void br if_cont_4
 
 if_else_3:
   %10              void br if_cont_4
 
 if_cont_4:
   %12              void ret
 }
 #+END_SRC
   
** Stack manipulation
   - Interpreter is used for evaluation of compile-time known expressions during analyze process.
   - Compile-time known values are not pushed on the stack.

   Example function:
   #+BEGIN_SRC bl
   #load "std/debug.bl"
   main :: fn () s32 {
     v :: 10;
     assert(v == 10);
     return 0;
   };
   #+END_SRC

   Stack operation produced during execution of the main function:
   #+BEGIN_EXAMPLE
   executing 'main' in compile time...
        -             Terminal  PUSH RA
       10         InstrDeclVar  PUSH    (4B, 0x7f377a17a060) s32
       11           InstrConst  PUSH    (4B, 0x7f377a17a068) s32
       13           InstrStore  POP     (4B, 0x7f377a17a06c) s32
       15           InstrConst  PUSH    (4B, 0x7f377a17a068) s32
       17            InstrLoad  PUSH    (4B, 0x7f377a17a070) s32
       18           InstrBinop  POP     (4B, 0x7f377a17a074) s32
       18           InstrBinop  POP     (4B, 0x7f377a17a06c) s32
       18           InstrBinop  PUSH    (1B, 0x7f377a17a068) bool
       19            InstrCall  PUSH RA
       87         InstrDeclVar  PUSH    (1B, 0x7f377a17a088) bool
       88             InstrArg  PUSH    (1B, 0x7f377a17a090) bool
       90           InstrStore  POP     (1B, 0x7f377a17a097) bool
       96            InstrLoad  PUSH    (1B, 0x7f377a17a090) bool
       97            InstrUnop  POP     (1B, 0x7f377a17a097) bool
       97            InstrUnop  PUSH    (1B, 0x7f377a17a090) bool
       98          InstrCondBr  POP     (1B, 0x7f377a17a097) bool
      104             InstrRet  POP RA
      104             InstrRet  POP     (1B, 0x7f377a17a06f) bool
       20           InstrConst  PUSH    (4B, 0x7f377a17a068) s32
       21             InstrRet  POP     (4B, 0x7f377a17a06c) s32
       21             InstrRet  POP RA
   execution finished with state: 0
   #+END_EXAMPLE


* Function
   #+BEGIN_EXAMPLE
   @<name> <T> [flags] { 
     [entry block]
   }
   #+END_EXAMPLE

* Block
  Basic block representation.

  #+BEGIN_EXAMPLE
  <name>: 
    ...
    <terminal instruction>
  #+END_EXAMPLE

* Instructions: 
  
** const
   Constant values are known in compile time.

   #+BEGIN_EXAMPLE
   <T> const <value> // yields constant value of the type T
   #+END_EXAMPLE

** decl
   Variable declaration.

   #+BEGIN_EXAMPLE
   void decl <name> : <T> = <init value> // yields void 
   #+END_EXAMPLE

   | stack op | data | description              |
   |----------+------+--------------------------|
   | PUSH     | -    | storage for the variable |

   Constant declaration.

   #+BEGIN_EXAMPLE
   void decl <name> : <T> : <init value> // yields void 
   #+END_EXAMPLE
** declref
   Reference to some declaration. This instruction is 'noop'. Symbol lookup is done here during analyze pass, when symbol is not found error is generated.
   
   #+BEGIN_EXAMPLE
   <T*> declref <name> // yields pointer to found declaration
   #+END_EXAMPLE

** load
   Push pointed value on the stack.

   #+BEGIN_EXAMPLE
   <T> load <ptr> // yields T loaded from ptr
   #+END_EXAMPLE

   | stack op | data  | description              |
   |----------+-------+--------------------------|
   | POP      | ptr   | pointer to source        |
   | PUSH     | value | value loaded from source |
   
** store
   Store value from source to destination address.

   #+BEGIN_EXAMPLE
   void store <src> -> <dest ptr> // yields void
   #+END_EXAMPLE

   | stack op | data     | description            |
   |----------+----------+------------------------|
   | POP      | dest ptr | pointer to destination |
   | POP      | src ptr  | value                  |
   
** arg
   Load argument of the current function on the stack.

   #+BEGIN_EXAMPLE
   <T> arg $<arg number> // yields T
   #+END_EXAMPLE

   | stack op | data | description |
   |----------+------+-------------|
   | PUSH     | arg  | fn argument |

** call
   Call function. This instruction will create new stack frame and switch control to the callee. All call arguments in example case are known only in runtime (compile-time known arguments is passed by const value).

   | stack op | data         | description                                                                |
   |----------+--------------+----------------------------------------------------------------------------|
   | PUSH     | arg 3        | push 3rd argument                                                          |
   | PUSH     | arg 2        | push 2nd argument                                                          |
   | PUSH     | arg 1        | push 1st argument                                                          |
   | PUSH RA  | pc, call ptr | create new frame stack (push program counter and call instruction pointer) |

** ret
   Return value from the function and return control to the caller. This instruction terminates current basic block.

   #+BEGIN_EXAMPLE
   void ret [value] // yields void
   #+END_EXAMPLE

   | stack op | data  | description                            |
   |----------+-------+----------------------------------------|
   | POP RA   | -     | rollback the stack to return address   |
   | POP      | arg 1 | clenup fn argument                     |
   | POP      | arg 2 | clenup fn argument                     |
   | POP      | arg 3 | clenup fn argument                     |
   | PUSH     | value | push call result value if there is one |

** br
   Breaks to the basic block. This instruction terminates current basic block.

   #+BEGIN_EXAMPLE
   void br <block> // yields void
   #+END_EXAMPLE

** br (conditional)
   Breaks into then block if the condition is true. This instruction terminates current basic block.

   #+BEGIN_EXAMPLE
   void br <cont> ? <then_block> : <else_block> // yields void
   #+END_EXAMPLE

   | stack op | data      | description       |
   |----------+-----------+-------------------|
   | POP      | condition | checked condition |

** unreachable
   Abort execution when this instruction is reached.

** binop
   Binary operation.

   #+BEGIN_EXAMPLE
   <T> binop <lhs> <+|-|*|/|%> <rhs> // yields result value of type T
   #+END_EXAMPLE

   | stack op | data   | description                   |
   |----------+--------+-------------------------------|
   | POP      | lhs    | left-hand side of operation   |
   | POP      | rhs    | right-hand side of operation  |
   | PUSH     | result | result value of the operation |

** unop
   Unary operation.

   #+BEGIN_EXAMPLE
   <T> unop <+|-|*|&> <value> // yields result value of type T
   #+END_EXAMPLE

   | stack op | data   | description                   |
   |----------+--------+-------------------------------|
   | POP      | value  |                               |
   | PUSH     | result | result value of the operation |

** elemptr
   Evaluates address of the array element and push it on the stack.

   #+BEGIN_EXAMPLE
   <*T> elemptr <arr ptr>[<index>] // yields result address *T (elem type)
   #+END_EXAMPLE

   | stack op | data     | description                  |
   |----------+----------+------------------------------|
   | POP      | index    |                              |
   | PUSH     | elem ptr | Address of the array element |
** memberptr
   Evaluates address of member access via '.' operator.

   #+BEGIN_EXAMPLE
   <*T> memberptr <target ptr>.<member name|order> // yields result address *T (member type)
   #+END_EXAMPLE

   | stack op | data       | description           |
   |----------+------------+-----------------------|
   | POP      | target ptr |                       |
   | PUSH     | member ptr | Address of the member |
** addrof
    Evaluates address of the variable.

   #+BEGIN_EXAMPLE
   <*T> addrof <target> // yields result address *T
   #+END_EXAMPLE

    Getting address of variable:
    | stack op | data    | description                   |
    |----------+---------+-------------------------------|
    | PUSH     | var ptr | pointer to allocated variable |

    Skipped when address has been pushed by previous instruction (ex.: 'elemptr').
    
** bitcast
   Produce bit casting from one type to other. Bit cast just change type of pushed value. No stack operations are produced.

   #+BEGIN_EXAMPLE
   <T> bitcast <target> // yields value with casted type
   #+END_EXAMPLE

** sext
   Signed-extend cast. 

   #+BEGIN_EXAMPLE
   <T> sext <target> // yields value with casted type
   #+END_EXAMPLE

    | stack op | data   | description          |
    |----------+--------+----------------------|
    | POP      | target |                      |
    | PUSH     | result | result with new type |

** zext
   Zero-extend cast. 

   #+BEGIN_EXAMPLE
   <T> zext <target> // yields value with casted type
   #+END_EXAMPLE

    | stack op | data    | description          |
    |----------+---------+----------------------|
    | POP      | target  |                      |
    | PUSH     | resutlt | result with new type |

** trunc
   Truncates target to destination type 'T'.

   #+BEGIN_EXAMPLE
   <T> trunc <target> // yields value with casted type
   #+END_EXAMPLE

    | stack op | data    | description          |
    |----------+---------+----------------------|
    | POP      | target  |                      |
    | PUSH     | resutlt | result with new type |
** fptosi
   Floating point to signed integer cast. 

   #+BEGIN_EXAMPLE
   <T> fptosi <target> // yields value with casted type
   #+END_EXAMPLE
** fptoui
   Floating point to unsigned integer cast. 

   #+BEGIN_EXAMPLE
   <T> fptoui <target> // yields value with casted type
   #+END_EXAMPLE
** ptrtoint
   Pointer to integer cast. This cast is noop cast when T has same size as type of the target.

   #+BEGIN_EXAMPLE
   <T> ptrtoint <target> // yields value with casted type
   #+END_EXAMPLE
** inttoptr 
   Integer to pointer cast. This cast is noop cast when T has same size as type of the target.

   #+BEGIN_EXAMPLE
   <T> inttoptr <target> // yields value with casted type
   #+END_EXAMPLE

* Special instructions
  Special instructions are used only during analyze pass inside the compiler.

** validate_type
   Validates if the source instruction yields value of type 'type'. 
   
   #+BEGIN_EXAMPLE
   void validate_type <src> // yields void
   #+END_EXAMPLE

* Footnotes
