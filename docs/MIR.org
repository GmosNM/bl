#+TITLE: Biscuit-MIR Documentation
#+AUTHOR: Martin Dorazil
#+OPTIONS: toc:nil H:3 num:1 ^:nil pri:t
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

# now prints out the previously disabled (toc:nil) table of contents.
#+TOC: headlines 2

* About
 BL-MIR (Biscuit Language Middle Intermediate Representation) is a simplified representation of the Biscuit Language created from AST. It is located between AST and LLVM-IR. 

** MIR Interpreter
   BL Compiler has integrated interpreter for MIR. 
   
   - Default execution stack size is 2MB.
   - Stack allocations are 8 byte aligned.

** Assert function example
   #+BEGIN_SRC bl
   assert :: fn (cond: bool) {
     if (!cond) {
       unreachable;
     }
   };
   #+END_SRC

   #+BEGIN_SRC blm
   @assert fn(bool) void {
   %entry_0:
     %0              bool arg $0
     %1              void decl cond : bool = %0
     %2             *bool declref cond
     %5              bool load %2
     %3              bool unop !%5
     %4              void br %3 ? %if_then_1 : %if_else_2
   
   %if_then_1:
     %5              void unreachable 
     %6              void br %if_cont_3
   
   %if_else_2:
     %7              void br %if_cont_3
   
   %if_cont_3:
     %8              void ret 
   }
   #+END_SRC
   
   #+BEGIN_SRC llvm
   define void @assert(i1) {
   entry:
     %cond = alloca i1, align 1
     store i1 %0, i1* %cond
     %1 = load i1, i1* %cond, align 1
     %2 = xor i1 %1, true
     br i1 %2, label %if_then, label %if_else
   
   if_then:                                          ; preds = %entry
     call void @llvm.debugtrap()
     br label %if_cont
   
   if_else:                                          ; preds = %entry
     br label %if_cont
   
   if_cont:                                          ; preds = %if_else, %if_then
     ret void
   }
   #+END_SRC

   
** Stack manipulation
   - Interpreter is used for evaluation of compile-time known expressions during analyze process.
   - Compile-time known values are not pushed on the stack.

   Example function:
   #+BEGIN_SRC bl
   assert :: fn (cond: bool) {
     if (!cond) {
       unreachable;
     }
   };

   main :: fn () s32 {
     v :: 10;
     assert(v == 10);
     return 0;
   };
   #+END_SRC

   Stack operation produced during execution of the main function:
   #+BEGIN_EXAMPLE
   executing 'main' in compile time...
        -             Terminal  PUSH RA
       15            InstrCall  PUSH RA
       27             InstrArg  PUSH    (1B, 0x7fbd02347078) bool
       28         InstrDeclVar  POP     (1B, 0x7fbd0234707f) bool
       28         InstrDeclVar  PUSH    (1B, 0x7fbd02347078) bool
       39            InstrLoad  PUSH    (1B, 0x7fbd02347080) bool
       33            InstrUnop  POP     (1B, 0x7fbd02347087) bool
       33            InstrUnop  PUSH    (1B, 0x7fbd02347080) bool
       34          InstrCondBr  POP     (1B, 0x7fbd02347087) bool
       40             InstrRet  POP RA
       17             InstrRet  POP RA
   execution finished with state: 0
   #+END_EXAMPLE


* Function
   #+BEGIN_EXAMPLE
   @<name> <T> [flags] { 
     [entry block]
   }
   #+END_EXAMPLE

* Block
  Basic block representation.

  #+BEGIN_EXAMPLE
  <name>: 
    ...
    <terminal instruction>
  #+END_EXAMPLE

* Instructions 
  
** const
   Constant values are known in compile time.

   #+BEGIN_EXAMPLE
   <T> const <value> // yields constant value of the type T
   #+END_EXAMPLE

** decl
   Variable declaration.

   #+BEGIN_EXAMPLE
   void decl <name> : <T> = <init value> // yields void 
   #+END_EXAMPLE

   | stack op | data | description              |
   |----------+------+--------------------------|
   | PUSH     | -    | storage for the variable |

   Constant declaration.

   #+BEGIN_EXAMPLE
   void decl <name> : <T> : <init value> // yields void 
   #+END_EXAMPLE
** declref
   Reference to some declaration. This instruction is 'noop'. Symbol lookup is done here during analyze pass, when symbol is not found error is generated.
   
   #+BEGIN_EXAMPLE
   <T*> declref <name> // yields pointer to found declaration
   #+END_EXAMPLE

** load
   Push pointed value on the stack.

   #+BEGIN_EXAMPLE
   <T> load <ptr> // yields T loaded from ptr
   #+END_EXAMPLE

   | stack op | data  | description              |
   |----------+-------+--------------------------|
   | POP      | ptr   | pointer to source        |
   | PUSH     | value | value loaded from source |
   
** store
   Store value from source to destination address.

   #+BEGIN_EXAMPLE
   void store <src> -> <dest ptr> // yields void
   #+END_EXAMPLE

   | stack op | data     | description            |
   |----------+----------+------------------------|
   | POP      | dest ptr | pointer to destination |
   | POP      | src ptr  | value                  |
   
** arg
   Load argument of the current function on the stack.

   #+BEGIN_EXAMPLE
   <T> arg $<arg number> // yields T
   #+END_EXAMPLE

   | stack op | data | description |
   |----------+------+-------------|
   | PUSH     | arg  | fn argument |

** call
   Call function. This instruction will create new stack frame and switch control to the callee. All call arguments in example case are known only in runtime (compile-time known arguments is passed by const value).

   | stack op | data         | description                                                                |
   |----------+--------------+----------------------------------------------------------------------------|
   | PUSH     | arg 3        | push 3rd argument                                                          |
   | PUSH     | arg 2        | push 2nd argument                                                          |
   | PUSH     | arg 1        | push 1st argument                                                          |
   | PUSH RA  | pc, call ptr | create new frame stack (push program counter and call instruction pointer) |

** ret
   Return value from the function and return control to the caller. This instruction terminates current basic block.

   #+BEGIN_EXAMPLE
   void ret [value] // yields void
   #+END_EXAMPLE

   | stack op | data  | description                            |
   |----------+-------+----------------------------------------|
   | POP RA   | -     | rollback the stack to return address   |
   | POP      | arg 1 | clenup fn argument                     |
   | POP      | arg 2 | clenup fn argument                     |
   | POP      | arg 3 | clenup fn argument                     |
   | PUSH     | value | push call result value if there is one |

** br
   Breaks to the basic block. This instruction terminates current basic block.

   #+BEGIN_EXAMPLE
   void br <block> // yields void
   #+END_EXAMPLE

** br (conditional)
   Breaks into then block if the condition is true. This instruction terminates current basic block.

   #+BEGIN_EXAMPLE
   void br <cont> ? <then_block> : <else_block> // yields void
   #+END_EXAMPLE

   | stack op | data      | description       |
   |----------+-----------+-------------------|
   | POP      | condition | checked condition |

** unreachable
   Abort execution when this instruction is reached.

** binop
   Binary operation.

   #+BEGIN_EXAMPLE
   <T> binop <lhs> <+|-|*|/|%> <rhs> // yields result value of type T
   #+END_EXAMPLE

   | stack op | data   | description                   |
   |----------+--------+-------------------------------|
   | POP      | lhs    | left-hand side of operation   |
   | POP      | rhs    | right-hand side of operation  |
   | PUSH     | result | result value of the operation |

** unop
   Unary operation.

   #+BEGIN_EXAMPLE
   <T> unop <+|-|*|&> <value> // yields result value of type T
   #+END_EXAMPLE

   | stack op | data   | description                   |
   |----------+--------+-------------------------------|
   | POP      | value  |                               |
   | PUSH     | result | result value of the operation |

** elemptr
   Evaluates address of the array element and push it on the stack.

   #+BEGIN_EXAMPLE
   <*T> elemptr <arr ptr>[<index>] // yields result address *T (elem type)
   #+END_EXAMPLE

   | stack op | data     | description                  |
   |----------+----------+------------------------------|
   | POP      | index    |                              |
   | PUSH     | elem ptr | Address of the array element |
** memberptr
   Evaluates address of member access via '.' operator.

   #+BEGIN_EXAMPLE
   <*T> memberptr <target ptr>.<member name|order> // yields result address *T (member type)
   #+END_EXAMPLE

   | stack op | data       | description           |
   |----------+------------+-----------------------|
   | POP      | target ptr |                       |
   | PUSH     | member ptr | Address of the member |
** addrof
    Evaluates address of the variable.

   #+BEGIN_EXAMPLE
   <*T> addrof <target> // yields result address *T
   #+END_EXAMPLE

    Getting address of variable:
    | stack op | data    | description                   |
    |----------+---------+-------------------------------|
    | PUSH     | var ptr | pointer to allocated variable |

    Skipped when address has been pushed by previous instruction (ex.: 'elemptr').
    
** bitcast
   Produce bit casting from one type to other. Bit cast just change type of pushed value. No stack operations are produced.

   #+BEGIN_EXAMPLE
   <T> bitcast <target> // yields value with casted type
   #+END_EXAMPLE

** sext
   Signed-extend cast. 

   #+BEGIN_EXAMPLE
   <T> sext <target> // yields value with casted type
   #+END_EXAMPLE

    | stack op | data   | description          |
    |----------+--------+----------------------|
    | POP      | target |                      |
    | PUSH     | result | result with new type |

** zext
   Zero-extend cast. 

   #+BEGIN_EXAMPLE
   <T> zext <target> // yields value with casted type
   #+END_EXAMPLE

    | stack op | data    | description          |
    |----------+---------+----------------------|
    | POP      | target  |                      |
    | PUSH     | resutlt | result with new type |

** trunc
   Truncates target to destination type 'T'.

   #+BEGIN_EXAMPLE
   <T> trunc <target> // yields value with casted type
   #+END_EXAMPLE

    | stack op | data    | description          |
    |----------+---------+----------------------|
    | POP      | target  |                      |
    | PUSH     | resutlt | result with new type |
** fptosi
   Floating point to signed integer cast. 

   #+BEGIN_EXAMPLE
   <T> fptosi <target> // yields value with casted type
   #+END_EXAMPLE
** fptoui
   Floating point to unsigned integer cast. 

   #+BEGIN_EXAMPLE
   <T> fptoui <target> // yields value with casted type
   #+END_EXAMPLE
** ptrtoint
   Pointer to integer cast. This cast is noop cast when T has same size as type of the target.

   #+BEGIN_EXAMPLE
   <T> ptrtoint <target> // yields value with casted type
   #+END_EXAMPLE
** inttoptr 
   Integer to pointer cast. This cast is noop cast when T has same size as type of the target.

   #+BEGIN_EXAMPLE
   <T> inttoptr <target> // yields value with casted type
   #+END_EXAMPLE

* Special instructions
  Special instructions are used only during analyze pass inside the compiler.

** validate_type
   Validates if the source instruction yields value of type 'type'. 
   
   #+BEGIN_EXAMPLE
   void validate_type <src> // yields void
   #+END_EXAMPLE

