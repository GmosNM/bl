#+TITLE: Biscuit Documentation
#+AUTHOR: Martin Dorazil
#+EMAIL: biscuitlang@gmail.com

#+OPTIONS: toc:nil H:3 num:0 ^:nil pri:t
#+HTML_HEAD: <link rel="stylesheet" href="org-mode.css" type="text/css" />
#+BEGIN_EXPORT html
<div class="menu">
<a href="index.html">Home</a> |
<a href="documentation.html">Documentation</a> |
<a href="MIR.html">Mir</a> |
<a href="https://github.com/travisdoor/bl">Source</a>
</div>
#+END_EXPORT


#+TOC: headlines 3

* Compiler usage
   #+BEGIN_EXAMPLE
   blc [options] <source-files>
   #+END_EXAMPLE

   | Option                      | Description                             |
   |-----------------------------+-----------------------------------------|
   | 	-h, -help           | Print usage information and exit.       |
   | 	-r, -run            | Execute 'main' method in compile time.  |
   | 	-rt, -run-tests     | Execute all unit tests in compile time. |
   | 	-emit-llvm          | Write LLVM-IR to file.                  |
   | 	-emit-mir           | Write MIR to file.                      |
   | 	-ast-dump           | Print AST.                              |
   | 	-lex-dump           | Print output of lexer.                  |
   | 	-mir-pre-dump       | Print output of MIR pre analyze stage.  |
   | 	-mir-post-dump      | Print output of MIR post analyze stage. |
   | 	-syntax-only        | Check syntax and exit.                  |
   | 	-no-bin             | Don't write binary to disk.             |
   | 	-no-warning         | Ignore all warnings.                    |
   | 	-verbose            | Verbose mode.                           |
   | 	-no-api             | Don't load internal api.                |
   | 	-force-test-to-llvm | Force llvm generation of unit tests.    |
   | 	-configure          | Generate config file.                   |

* Language
** Base syntax
   Basicly every construct in Biscuit language fallows the same rules of declaration. We define name of the entity, type and optionally some initial value.

   Declarations and mutability:
   #+BEGIN_EXAMPLE
   <name>: <type>;              // mutable declaration
   <name>: [type] = <value>;    // mutable declaration
   <name>: [type] : <value>;    // immutable declaration 
   #+END_EXAMPLE
   
   Data type is optional when we specify some value.

   #+BEGIN_SRC bl
   foo: s32; // data type required
   foo := 10; // data type based on value type (in this case s32)
   #+END_SRC

** Comments
   #+BEGIN_SRC bl
   // this is line comment
   /*
    this
    is
    multi line
    comment
   */
   #+END_SRC

** Operators
   There is no operator overloading in Biscuit.

*** Binary
   | Symbol     | Relevant for types         | Description                    |
   |------------+----------------------------+--------------------------------|
   | \plus      | Integers, Floats           | Addition.                      |
   | \minus     | Integers, Floats           | Subtraction.                   |
   | \star      | Integers, Floats           | Multiplication.                |
   | \slash     | Integers, Floats           | Division.                      |
   | %          | Integers, Floats           | Remainder division.            |
   | \plus=     | Integers, Floats           | Addition and assign.           |
   | \minus=    | Integers, Floats           | Subtraction and assign.        |
   | \star=     | Integers, Floats           | Multiplication and assign.     |
   | \slash=    | Integers, Floats           | Division and assign.           |
   | %=         | Integers, Floats           | Remainder division and assign. |
   | <          | Integers, Floats           | Less.                          |
   | >          | Integers, Floats           | Greater.                       |
   | <=         | Integers, Floats           | Less or equals.                |
   | >=         | Integers, Floats           | Greater or equals.             |
   | ==         | Integers, Floats, Booleans | Equals.                        |
   | &&         | Booleans                   | Logical AND                    |
   | \vert\vert | Booleans                   | Logical                        |

   Usage:
   #+BEGIN_EXAMPLE
   <expr> <op> <expr>
   #+END_EXAMPLE

*** Unary
   | Symbol | Relevant for types | Description          |
   |--------+--------------------+----------------------|
   | \plus  | Integers, Floats   | Positive value.      |
   | \minus | Integers, Floats   | Negative value.      |
   | \wedge | Pointers           | Pointer dereference. |
   | &      | Allocated value    | Address of.          |

   Usage:
   #+BEGIN_EXAMPLE
   <op> <expr>
   #+END_EXAMPLE
   
*** Special
   | Symbol   | Relevant for types | Description                     |
   |----------+--------------------+---------------------------------|
   | sizeof   | Any                | Determinates size in bytes.     |
   | alignof  | Any                | Determinates alignment of type. |
   | typeinfo | Any                | Determinates TypeInfo of type.  |
   | typekind | Any                | Determinates TypeKind of type.  |

    Example:
    #+INCLUDE: "../examples/special_op.bl" src bl -n
    
*** RTTI
    Biscuit language provides type reflection allowing access to the type structure of the code. Pointer to the type information structure can be yielded by =typeinfo(<T>)= builtin operator call. Type informations can be yielded in compile time and in runtime also, with low additional overhead for runtime (only pointer to the TypeInfo constant is pushed on the stack). 

    Example:
    #+INCLUDE: "../examples/rtti.bl" src bl -n
    
    RTTI is generated in static segment of compiled binary (only desired types are included).
   
** Hash directives
   Hash directives are used to specify internal compiler operations.

*** #load
    Load source file into the current assembly. Every file is included into the assembly only once even if we load it from multiple locations.

    Lookup order:
    1) Current file parent directory
    2) BL API directory set in =install location/etc/bl.conf=.
    3) System PATH environment variable.

    #+BEGIN_EXAMPLE
    #load "<bl file>"
    #+END_EXAMPLE

*** TODO #link
    #+BEGIN_EXAMPLE
    #link "<lib>"
    #+END_EXAMPLE

*** #private
    Creates private (file scope) block in the file. Everything after this is going to be private and visible only inside the current file.

    Example:
    #+BEGIN_SRC bl
    // main is public
    main :: fn () s32 {
        foo(); // can be called only inside this file.
	return 0;
    };

    #private

    // private function can be called only inside this file
    foo :: fn () {
    };

    // private constant
    bar :: 10;
    #+END_SRC

    /Since version 0.4.2/

*** #extern
    Used for marking entities as an external.
    
    Example:
    #+BEGIN_SRC bl
    // libc functions
    malloc  :: fn (size: usize) *u8 #extern;
    free    :: fn (ptr: *u8) #extern;
    #+END_SRC


*** #compiler
    Used for marking entities as an compiler internals. This flag should not be used by user.
    
    Example:
    #+BEGIN_SRC bl
    Any :: struct #compiler {
	type_info: *TypeInfo,
	data: *u8
    };
    #+END_SRC
*** #test
    Introduce test case function. [[utest][Unit testing section]]

** Data types
*** Fundamental data types
    | Name   | Description                   |
    |--------+-------------------------------|
    | s8     | Signed 8-bit number.          |
    | s16    | Signed 16-bit number.         |
    | s32    | Signed 32-bit number.         |
    | s64    | Signed 64-bit number.         |
    | u8     | Unsigned 8-bit number.        |
    | u16    | Unsigned 16-bit number.       |
    | u32    | Unsigned 32-bit number.       |
    | u64    | Unsigned 64-bit number.       |
    | usize  | Unsigned 64-bit size.         |
    | bool   | Boolean. (true/false)         |
    | f32    | 32-bit floating point number  |
    | f64    | 64-bit floating point number. |
    | string | String slice.                 |

*** Pointers
    Represents the address of some allocated data.

    #+BEGIN_EXAMPLE
    *<T>
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../examples/pointers.bl" src bl -n
    
*** Arrays
    Array is aggregate type of multiple values of the same type.
    #+BEGIN_EXAMPLE
    [<size>] <T>
    #+END_EXAMPLE
    
    Arrays can be inline initialized with compound block, type is required. Zero initializer can be used for zero initialization of whole array storage, otherwise we must specify value for every element in an array.
    #+BEGIN_EXAMPLE
    {:<T>: [val], ...}
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../examples/array_type.bl" src bl -n

*** Strings
    String type in biscuit is slice containting pointer to string data and string lenght. String literals are zero terimated.

    Example:
    #+INCLUDE: "../examples/array_string.bl" src bl -n

*** Array slice
    Array slice is consist of pointer to the first array element and array lenght. 

    Syntax:
    #+BEGIN_EXAMPLE
    [] <type>
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../examples/array_ref.bl" src bl -n
*** Structures
    Structure is simple group of data.

    #+BEGIN_EXAMPLE
    struct { 
      <member1 name>: <type>,
      <member2 name>: <type>,
      <member3 name>: <type>
    };
    #+END_EXAMPLE
    
    Example:
    #+INCLUDE: "../examples/struct.bl" src bl -n

*** Enums
    Example:
    #+INCLUDE: "../examples/enums.bl" src bl -n

*** Type aliasing
    It's posible to create alias to any data type.

    #+BEGIN_EXAMPLE
    <alias name> :: <type>;
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../examples/alias.bl" src bl -n

*** Function type
    Type of function. 
    
    #+BEGIN_EXAMPLE
    fn ([arguments]) [return type]
    #+END_EXAMPLE

    #+BEGIN_SRC bl
    // type of function without arguments and without return value
    fn ()             
    
    // type of function without arguments, returning value of 's32' type
    fn () s32

    // type of function with two arguments, returning value of 's32' type
    fn (s32, bool) s32 
    #+END_SRC

*** Type casting
    Change type of value to other type. Conventions between integer types is generated implicitly by the compiler.

    #+BEGIN_EXAMPLE
    cast(<T>) <expr>
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../examples/type_cast.bl" src bl -n
** Literals
*** Simple literals
   #+BEGIN_SRC bl
   b :: true;         // bool true literal 
   b :: false;        // bool false literal 
   ptr : *s32 = null; // *s32 null pointer literal
   #+END_SRC

*** Numeric literals 
   #+BEGIN_SRC bl
   i     :: 10;      // s32 literal
   i_hex :: 0x10;    // s32 literal
   f     :: 13.43f;  // f32 literal
   d     :: 13.43;   // f64 literal
   char  :: 'i';     // u8 literal 
   #+END_SRC

** Variables
   Example of variable allocated on stack.

   #+BEGIN_EXAMPLE
   <name> : <type>;
   <name> : [type] = <value>;
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../examples/variables.bl" src bl -n

** Constants
   Example of constant allocated on stack. Constant must be initialized and cannot be changed later.

   Syntax:
   #+BEGIN_EXAMPLE
   <name> : [type] : <value>;
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../examples/constants.bl" src bl -n
   
** Compound expressions
   Compound expression can be used for inline initialization of variables or directly as value.
   Implicit temporary variable is created as needed. Zero initializer can be used as short for memset(0) call.

   Syntax:
   #+BEGIN_EXAMPLE
   {:<type>: <arg1, arg2, ...>};
   {:<type>: 0}; // zero initializer
   #+END_EXAMPLE

   Example:
   #+INCLUDE: "../examples/compounds.bl" src bl -n
** Functions
*** Named function
   Examples of named function.

   #+BEGIN_EXAMPLE
   <name> : [type] : fn ([args]) [return type] {[body]};
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../examples/named_functions.bl" src bl -n
   
*** Anonymous function
    Anonymous function has no name and contains only function literal.

    #+BEGIN_EXAMPLE
    fn ([args]) [return type] {[body]};
    #+END_EXAMPLE

    Example of anonymous function.
    #+INCLUDE: "../examples/anonymous_function.bl" src bl -n
    
*** Function pointers
    Functions can be called via pointer. Call on ~null~ pointer will produce error in interpreter.
    
    Example:
    #+INCLUDE: "../examples/fn_pointers.bl" src bl -n
   
*** Functions with variable argument count
    Biscuit supports functions with variable argument count of the same type. VArgs type must be last in function argument list. Compiler internally creates temporary array of all arguments passed in vargs. Inside function body variable argument list acts like regular array.

    Example of variable argument count function:
    #+INCLUDE: "../examples/vargs.bl" src bl -n
** Blocks
   Block can limit scope of the variable.

    Example:
   #+INCLUDE: "../examples/blocks.bl" src bl -n
   
** Ifs 
   If - else base syntax:
   #+BEGIN_EXAMPLE
   if <condition> {[then block]} [else {[else block]}]
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../examples/ifs.bl" src bl -n

** Loops
   Loop base syntax:
   #+BEGIN_EXAMPLE
   loop {[block]} 
   loop <condition> {[block]} 
   loop <initialization>; <condition>; <increment> {[block]} 
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../examples/loops.bl" src bl -n

** Break and continue
   Break/continue statements can be used in loops to control execution flow.

   Examples:
   #+INCLUDE: "../examples/break_continue.bl" src bl -n

** Unit tests <<utest>>
   Biscuit compiler supports unit testing by default.

   Create unit test case:
   #+BEGIN_SRC bl :var css-file="org.css" :results raw
   #load "std/debug.bl"

   // function to be tested
   add :: fn (a: s32, b: s32) s32 {
     return a + b;
   };

   #test "this is OK" {
     assert(add(10, 20) == 30); 
   };

   #test "this is not OK" {
     assert(add(10, 20) != 30); 
   };
   #+END_SRC
   
   Run tests:
   #+BEGIN_EXAMPLE
   $ blc -no-bin -run-tests test.bl
   compiler version: 0.4.0 (pre-alpha)
   compile assembly: test
   
   executing test cases...
   [ PASSED ] (1/2) /Users/travis/Desktop/test.bl:8 'this is my test'
   error: execution reached unreachable code
   /Users/travis/Develop/bl/api/std/debug.bl:31:5 
     30 |   if (!cond) {
     31 |     unreachable;
        |     ^^^^^^^^^^^
     32 |   }
   /Users/travis/Desktop/test.bl:13:12 
     12 |    #test "this is not OK" {
     13 |      assert(add(10, 20) != 30); 
        |            ^
     14 |    };
   [ FAILED ] (2/2) /Users/travis/Desktop/test.bl:12 'this is not OK'
   testing done, 1 of 2 failed
   
   compiled 47 lines in 0.001551 seconds
   
   finished at 22-01-2019 21:28:10
   done
   #+END_EXAMPLE

* Footnotes
