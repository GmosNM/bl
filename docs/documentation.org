#+TITLE: Biscuit Documentation
#+AUTHOR: Martin Dorazil
#+OPTIONS: toc:nil H:3 num:0 ^:nil pri:t
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

# now prints out the previously disabled (toc:nil) table of contents.
#+TOC: headlines 3
* Instalation
** Requirements
  - git
  - CMake
  - LLVM
  - [[https://github.com/travisdoor/bobject][bobject]]
  - [[http://www.dyncall.org][dyncall]]
  - GCC/CLANG/Visual Studio compiler

** Linux
   - Install bobject.
   - Install dyncall.
   - Install LLVM dev packages.
   - Download and compile bl.
   
   #+BEGIN_EXAMPLE
   git clone https://github.com/travisdoor/bl.git
   cd bl
   mkdir build
   cd build
   cmake ..
   make
   #+END_EXAMPLE

   - Add 'bl/api' and 'bl/bin' into the system PATH

** MacOS
   - Install bobject.
   - Install dyncall.
   - Install LLVM dev packages.
   - Download and compile bl.
   
   #+BEGIN_EXAMPLE
   git clone https://github.com/travisdoor/bl.git
   cd bl
   mkdir build
   cd build
   cmake ..
   make
   #+END_EXAMPLE

   - Add 'bl/api' and 'bl/bin' into the system PATH

** TODO Windows 

* Compiler usage
   #+BEGIN_EXAMPLE
   blc [options] <source-files>
   #+END_EXAMPLE

   | Option              | Description                             |
   |---------------------+-----------------------------------------|
   | -h, -help           | Print usage information and exit.       |
   | -ast-dump           | Print AST.                              |
   | -lex-dump           | Print output of lexer.                  |
   | -mir-pre-dump       | Print output of MIR pre analyze stage.  |
   | -mir-post-dump      | Print output of MIR post analyze stage. |
   | -syntax-only        | Check syntax and exit.                  |
   | -emit-llvm          | Write LLVM-IR to file.                  |
   | -emit-mir           | Write MIR to file.                      |
   | -no-bin             | Don't write binary to disk.             |
   | -no-warning         | Ignore all warnings.                    |
   | -verbose            | Verbose mode.                           |
   | -no-api             | Don't load internal api.                |
   | -force-test-to-llvm | Force llvm generation of unit tests.    |
   | -run                | Execute 'main' method in compile time.  |
   | -run-tests          | Execute all unit tests in compile time. |

* Language
** Base syntax
   Basicly every construct in Biscuit language fallows the same rules of declaration. We define name of the entity, type and optionally some initial value.

   Declarations and mutability:
   #+BEGIN_EXAMPLE
   <name>: <type>;              // mutable declaration
   <name>: [type] = <value>;    // mutable declaration
   <name>: [type] : <value>;    // immutable declaration 
   #+END_EXAMPLE
   
   Data type is optional when we specify some value.

   #+BEGIN_SRC bl
   foo: s32; // data type required
   foo := 10; // data type based on value type (in this case s32)
   #+END_SRC

** Comments
   #+BEGIN_SRC bl
   // this is line comment
   /*
    this
    is
    multi line
    comment
   */
   #+END_SRC

** Operators
   There is no operator overloading in Biscuit.

*** Binary
   | Symbol     | Relevant for types         | Description                    |
   |------------+----------------------------+--------------------------------|
   | \plus      | Integers, Floats           | Addition.                      |
   | \minus     | Integers, Floats           | Subtraction.                   |
   | \star      | Integers, Floats           | Multiplication.                |
   | \slash     | Integers, Floats           | Division.                      |
   | %          | Integers, Floats           | Remainder division.            |
   | \plus=     | Integers, Floats           | Addition and assign.           |
   | \minus=    | Integers, Floats           | Subtraction and assign.        |
   | \star=     | Integers, Floats           | Multiplication and assign.     |
   | \slash=    | Integers, Floats           | Division and assign.           |
   | %=         | Integers, Floats           | Remainder division and assign. |
   | <          | Integers, Floats           | Less.                          |
   | >          | Integers, Floats           | Greater.                       |
   | <=         | Integers, Floats           | Less or equals.                |
   | >=         | Integers, Floats           | Greater or equals.             |
   | ==         | Integers, Floats, Booleans | Equals.                        |
   | &&         | Booleans                   | Logical AND                    |
   | \vert\vert | Booleans                   | Logical                        |

   Usage:
   #+BEGIN_EXAMPLE
   <expr> <op> <expr>
   #+END_EXAMPLE


*** Unary
   | Symbol | Relevant for types | Description          |
   |--------+--------------------+----------------------|
   | \plus  | Integers, Floats   | Positive value.      |
   | \minus | Integers, Floats   | Negative value.      |
   | \wedge | Pointers           | Pointer dereference. |
   | &      | Allocated value    | Address of.          |

   Usage:
   #+BEGIN_EXAMPLE
   <op> <expr>
   #+END_EXAMPLE


** Data types
*** Fundamental data types
    | Name  | Description                   |
    |-------+-------------------------------|
    | s8    | Signed 8-bit number.          |
    | s16   | Signed 16-bit number.         |
    | s32   | Signed 32-bit number.         |
    | s64   | Signed 64-bit number.         |
    | u8    | Unsigned 8-bit number.        |
    | u16   | Unsigned 16-bit number.       |
    | u32   | Unsigned 32-bit number.       |
    | u64   | Unsigned 64-bit number.       |
    | usize | Unsigned 64-bit size.         |
    | bool  | Boolean. (true/false)         |
    | f32   | 32-bit floating point number  |
    | f64   | 64-bit floating point number. |

*** Pointers
    Represents the address of some allocated data.

    #+BEGIN_EXAMPLE
    *<T>
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../tests/src/examples/pointers.bl" src bl -n
    
*** TODO Arrays
    #+BEGIN_EXAMPLE
    [<size>] <T>
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../tests/src/examples/array_type.bl" src bl -n

*** TODO Strings
    String in BL is just an array. There is no zero terminator at the end.

    #+BEGIN_EXAMPLE
    [<size>] u8
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../tests/src/examples/array_string.bl" src bl -n

*** TODO Slices
    Slice is consist of pointer to the first element and element count of an array. Slice is internally represented as special kind of structure passed by value. 

    #+BEGIN_EXAMPLE
    [] <type>
    #+END_EXAMPLE
*** Structures
    Structure is simple group of some data separated by comma.

    #+BEGIN_EXAMPLE
    struct { 
      <member1 name>: <type>,
      <member2 name>: <type>,
      <member3 name>: <type>
    };
    #+END_EXAMPLE
    
    Example:
    #+INCLUDE: "../tests/src/examples/struct.bl" src bl -n

*** TODO Emus
    #+BEGIN_EXAMPLE
    <name> :: enum [type] { 
      <variant1 name> [:: <expr>],
      <variant2 name> [:: <expr>],
      <variant3 name> [:: <expr>]
    };
    #+END_EXAMPLE

*** TODO Type aliasing
    It's posible to create alias to any data type.

    #+BEGIN_EXAMPLE
    <alias name> :: <type>;
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../tests/src/examples/alias.bl" src bl -n

*** Function type
    Type of function. 
    
    #+BEGIN_EXAMPLE
    fn ([arguments]) [return type]
    #+END_EXAMPLE

    #+BEGIN_SRC bl
    // type of function without arguments and without return value
    fn ()             
    
    // type of function without arguments, returning value of 's32' type
    fn () s32

    // type of function with two arguments, returning value of 's32' type
    fn (s32, bool) s32 
    #+END_SRC

*** Type casting
    Change type of value to other type. Conventions between integer types is generated implicitly by the compiler.

    #+BEGIN_EXAMPLE
    cast(<T>) <expr>
    #+END_EXAMPLE

    Example:
    #+INCLUDE: "../tests/src/examples/type_cast.bl" src bl -n
** Literals
*** Simple literals
   #+BEGIN_SRC bl
   b :: true;         // bool true literal 
   b :: false;        // bool false literal 
   ptr : *s32 = null; // *s32 null pointer literal
   #+END_SRC

*** Numeric literals 
   #+BEGIN_SRC bl
   i     :: 10;      // s32 literal
   i_hex :: 0x10;    // s32 literal
   f     :: 13.43f;  // f32 literal
   d     :: 13.43;   // f64 literal
   char  :: 'i';     // u8 literal 
   #+END_SRC

** Variables
   Example of variable allocated on stack.

   #+BEGIN_EXAMPLE
   <name> : <type>;
   <name> : [type] = <value>;
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../tests/src/examples/variables.bl" src bl -n

** Constants
   Example of constant allocated on stack. Constant must be initialized and cannot be changed later.

   #+BEGIN_EXAMPLE
   <name> : [type] : <value>;
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../tests/src/examples/constants.bl" src bl -n
   
** Functions
*** Named function
   Examples of named function.

   #+BEGIN_EXAMPLE
   <name> : [type] : fn ([args]) [return type] {[body]};
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../tests/src/examples/named_functions.bl" src bl -n
   
*** Anonymous function
    Anonymous function has no name and contains only function literal.

    #+BEGIN_EXAMPLE
    fn ([args]) [return type] {[body]};
    #+END_EXAMPLE

    Example of anonymous function.
    #+INCLUDE: "../tests/src/examples/anonymous_function.bl" src bl -n
   
** Blocks
   Block can limit scope of the variable.

    Example:
   #+INCLUDE: "../tests/src/examples/blocks.bl" src bl -n
   
** Ifs 
   If - else base syntax:
   #+BEGIN_EXAMPLE
   if <condition> {[then block]} [else {[else block]}]
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../tests/src/examples/ifs.bl" src bl -n

** Loops
   Loop base syntax:
   #+BEGIN_EXAMPLE
   loop {[block]} 
   loop <condition> {[block]} 
   loop <initialization>; <condition>; <increment> {[block]} 
   #+END_EXAMPLE

    Example:
   #+INCLUDE: "../tests/src/examples/loops.bl" src bl -n

** Break and continue
   Break/continue statements can be used in loops to control execution flow.

   Examples:
   #+INCLUDE: "../tests/src/examples/break_continue.bl" src bl -n

** Unit tests
   Biscuit compiler supports unit testing by default.

   Create unit test case:
   #+BEGIN_SRC bl :var css-file="org.css" :results raw
   load "std/debug.bl"

   // function to be tested
   add :: fn (a: s32, b: s32) s32 {
     return a + b;
   };

   test "this is OK" {
     assert(add(10, 20) == 30); 
   };

   test "this is not OK" {
     assert(add(10, 20) != 30); 
   };
   #+END_SRC
   
   Run tests:
   #+BEGIN_EXAMPLE
   $ blc -no-bin -run-tests test.bl
   compiler version: 0.4.0 (pre-alpha)
   compile assembly: test
   
   executing test cases...
   [ PASSED ] (1/2) /Users/travis/Desktop/test.bl:8 'this is my test'
   error: execution reached unreachable code
   /Users/travis/Develop/bl/api/std/debug.bl:31:5 
     30 |   if (!cond) {
     31 |     unreachable;
        |     ^^^^^^^^^^^
     32 |   }
   /Users/travis/Desktop/test.bl:13:12 
     12 |    #test "this is not OK" {
     13 |      assert(add(10, 20) != 30); 
        |            ^
     14 |    };
   [ FAILED ] (2/2) /Users/travis/Desktop/test.bl:12 'this is not OK'
   testing done, 1 of 2 failed
   
   compiled 47 lines in 0.001551 seconds
   
   finished at 22-01-2019 21:28:10
   done
   #+END_EXAMPLE

* Footnotes
