<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-04-22 Mon 19:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Biscuit-MIR Documentation</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Martin Dorazil" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Biscuit-MIR Documentation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8c7934c">1. About</a>
<ul>
<li><a href="#orgf2b90b3">MIR Interpreter</a></li>
<li><a href="#org44e1d39">Assert function example</a></li>
<li><a href="#orga8b4369">Stack manipulation</a></li>
</ul>
</li>
<li><a href="#org1ec88c9">2. Function</a></li>
<li><a href="#org6db99e5">3. Block</a></li>
<li><a href="#org3a2333e">4. Instructions</a>
<ul>
<li><a href="#orgd82bc06">const</a></li>
<li><a href="#org42f3d42">decl</a></li>
<li><a href="#org9a84558">declmember</a></li>
<li><a href="#org2feafe7">declvariant</a></li>
<li><a href="#org7ec1056">declref</a></li>
<li><a href="#orgf30d507">load</a></li>
<li><a href="#orgdaa722b">store</a></li>
<li><a href="#org0fa8e19">arg</a></li>
<li><a href="#orge9e7efb">call</a></li>
<li><a href="#orgef25415">ret</a></li>
<li><a href="#org20485a1">br</a></li>
<li><a href="#orgc15ef1f">br (conditional)</a></li>
<li><a href="#org3220709">unreachable</a></li>
<li><a href="#orgb996aec">binop</a></li>
<li><a href="#org89b9ff3">unop</a></li>
<li><a href="#org09ebece">elemptr</a></li>
<li><a href="#org4e1af55">memberptr</a></li>
<li><a href="#org3ff2570">addrof</a></li>
<li><a href="#org86317ce">bitcast</a></li>
<li><a href="#org6e9f0f7">sext</a></li>
<li><a href="#org8949acb">zext</a></li>
<li><a href="#orgf009043">trunc</a></li>
<li><a href="#orga7cafab">fptosi</a></li>
<li><a href="#org473a1bb">fptoui</a></li>
<li><a href="#org691255b">ptrtoint</a></li>
<li><a href="#orgc62ac96">inttoptr</a></li>
<li><a href="#orgc2654a7">fpext</a></li>
<li><a href="#orgd03bbf5">fptrunc</a></li>
<li><a href="#org4b5e6c5">sizeof</a></li>
<li><a href="#org8d57670">alignof</a></li>
<li><a href="#org1fdd592">compound</a></li>
<li><a href="#org85c056a">vargs</a></li>
<li><a href="#orgf470d38">phi</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8c7934c" class="outline-2">
<h2 id="org8c7934c"><span class="section-number-2">1</span> About</h2>
<div class="outline-text-2" id="text-1">
<p>
BL-MIR (Biscuit Language Middle Intermediate Representation) is a simplified representation of the Biscuit Language created from AST. It is located between AST and LLVM-IR. 
</p>
</div>

<div id="outline-container-orgf2b90b3" class="outline-3">
<h3 id="orgf2b90b3">MIR Interpreter</h3>
<div class="outline-text-3" id="text-orgf2b90b3">
<p>
BL Compiler has integrated interpreter for MIR. 
</p>

<ul class="org-ul">
<li>Default execution stack size is 2MB.</li>
<li>Stack allocations are 8 byte aligned.</li>
</ul>
</div>
</div>

<div id="outline-container-org44e1d39" class="outline-3">
<h3 id="org44e1d39">Assert function example</h3>
<div class="outline-text-3" id="text-org44e1d39">
<div class="org-src-container">
<pre class="src src-bl"><span class="org-function-name">assert</span> :: <span class="org-keyword">fn</span> (cond: <span class="org-type">bool</span>) {
  <span class="org-keyword">if</span> !cond {
    <span class="org-keyword">unreachable</span>;
  }
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-blm"><span class="org-function-name">@assert</span>  : <span class="org-type">fn(bool) void</span> : {
<span class="org-variable-name">%entry_0</span>:
  <span class="org-variable-name">%0</span>              <span class="org-type">bool</span> <span class="org-keyword">arg</span> <span class="org-constant">$0</span>
  <span class="org-variable-name">%1</span>              <span class="org-type">void</span> <span class="org-keyword">decl</span> cond : <span class="org-type">bool</span> = <span class="org-variable-name">%0</span>
  <span class="org-variable-name">%2</span>             <span class="org-type">*bool</span> <span class="org-keyword">declref</span> cond
  <span class="org-variable-name">%8</span>              <span class="org-type">bool</span> <span class="org-keyword">load</span> <span class="org-variable-name">%2</span>
  <span class="org-variable-name">%3</span>              <span class="org-type">bool</span> <span class="org-keyword">unop</span> !<span class="org-variable-name">%8</span>
  <span class="org-variable-name">%4</span>              <span class="org-type">void</span> <span class="org-keyword">br</span> <span class="org-variable-name">%3</span> ? <span class="org-variable-name">%if_then_1</span> : <span class="org-variable-name">%if_else_2</span>

<span class="org-variable-name">%if_then_1</span>:
  <span class="org-variable-name">%5</span>              <span class="org-type">void</span> <span class="org-keyword">unreachable</span> 
  <span class="org-variable-name">%6</span>              <span class="org-type">void</span> <span class="org-keyword">br</span> <span class="org-variable-name">%if_cont_3</span>

<span class="org-variable-name">%if_else_2</span>:
  <span class="org-variable-name">%7</span>              <span class="org-type">void</span> <span class="org-keyword">br</span> <span class="org-variable-name">%if_cont_3</span>

<span class="org-variable-name">%if_cont_3</span>:
  <span class="org-variable-name">%9</span>              <span class="org-type">void</span> <span class="org-keyword">ret</span> 
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-llvm"><span class="org-keyword">define</span> <span class="org-type">void</span> @assert(<span class="org-type">i1</span>) local_unnamed_addr #<span class="org-preprocessor">0</span> {
<span class="org-variable-name">entry:</span>
  <span class="org-keyword">br</span> <span class="org-type">i1</span> <span class="org-variable-name">%0</span>, <span class="org-type">label</span> <span class="org-variable-name">%if_cont</span>, <span class="org-type">label</span> <span class="org-variable-name">%if_then</span>

<span class="org-variable-name">if_then:</span>                                          <span class="org-comment">; preds = %entry</span>
  <span class="org-keyword">tail</span> <span class="org-keyword">call</span> <span class="org-type">void</span> @llvm.debugtrap()
  <span class="org-keyword">br</span> <span class="org-type">label</span> <span class="org-variable-name">%if_cont</span>

<span class="org-variable-name">if_cont:</span>                                          <span class="org-comment">; preds = %entry, %if_then</span>
  <span class="org-keyword">ret</span> <span class="org-type">void</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8b4369" class="outline-3">
<h3 id="orga8b4369">Stack manipulation</h3>
<div class="outline-text-3" id="text-orga8b4369">
<ul class="org-ul">
<li>Interpreter is used for evaluation of compile-time known expressions during analyze process.</li>
<li>Compile-time known values are not pushed on the stack.</li>
</ul>

<p>
Example function:
</p>
<div class="org-src-container">
<pre class="src src-bl"><span class="org-function-name">assert</span> :: <span class="org-keyword">fn</span> (cond: <span class="org-type">bool</span>) {
  <span class="org-keyword">if</span> (!cond) {
    <span class="org-keyword">unreachable</span>;
  }
};

<span class="org-function-name">main</span> :: <span class="org-keyword">fn</span> () <span class="org-type">s32</span> {
  <span class="org-constant">v</span> :: <span class="org-constant">10</span>;
  <span class="org-function-name">assert</span>(v == <span class="org-constant">10</span>);
  <span class="org-keyword">return</span> <span class="org-constant">0</span>;
};
</pre>
</div>

<p>
Stack operation produced during execution of the main function:
</p>
<pre class="example">
executing 'main' in compile time...
     -             Terminal  PUSH RA
    15            InstrCall  PUSH RA
    27             InstrArg  PUSH    (1B, 0x7fbd02347078) bool
    28         InstrDeclVar  POP     (1B, 0x7fbd0234707f) bool
    28         InstrDeclVar  PUSH    (1B, 0x7fbd02347078) bool
    39            InstrLoad  PUSH    (1B, 0x7fbd02347080) bool
    33            InstrUnop  POP     (1B, 0x7fbd02347087) bool
    33            InstrUnop  PUSH    (1B, 0x7fbd02347080) bool
    34          InstrCondBr  POP     (1B, 0x7fbd02347087) bool
    40             InstrRet  POP RA
    17             InstrRet  POP RA
execution finished with state: 0
</pre>
</div>
</div>
</div>

<div id="outline-container-org1ec88c9" class="outline-2">
<h2 id="org1ec88c9"><span class="section-number-2">2</span> Function</h2>
<div class="outline-text-2" id="text-2">
<pre class="example">
@&lt;name&gt; &lt;T&gt; [flags] { 
  [entry block]
}
</pre>
</div>
</div>

<div id="outline-container-org6db99e5" class="outline-2">
<h2 id="org6db99e5"><span class="section-number-2">3</span> Block</h2>
<div class="outline-text-2" id="text-3">
<p>
Basic block representation.
</p>

<pre class="example">
&lt;name&gt;: 
  ...
  &lt;terminal instruction&gt;
</pre>
</div>
</div>

<div id="outline-container-org3a2333e" class="outline-2">
<h2 id="org3a2333e"><span class="section-number-2">4</span> Instructions</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgd82bc06" class="outline-3">
<h3 id="orgd82bc06">const</h3>
<div class="outline-text-3" id="text-orgd82bc06">
<p>
Constant values are known in compile time.
</p>

<pre class="example">
&lt;T&gt; const &lt;value&gt; // yields constant value of the type T
</pre>
</div>
</div>

<div id="outline-container-org42f3d42" class="outline-3">
<h3 id="org42f3d42">decl</h3>
<div class="outline-text-3" id="text-org42f3d42">
<p>
Variable declaration:
</p>
<pre class="example">
void decl &lt;name&gt; : &lt;T&gt; = &lt;init value&gt; // yields void 
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PUSH</td>
<td class="org-left">-</td>
<td class="org-left">storage for the variable</td>
</tr>
</tbody>
</table>

<p>
Constant declaration:
</p>
<pre class="example">
void decl &lt;name&gt; : &lt;T&gt; : &lt;init value&gt; // yields void 
</pre>
</div>
</div>
<div id="outline-container-org9a84558" class="outline-3">
<h3 id="org9a84558">declmember</h3>
<div class="outline-text-3" id="text-org9a84558">
<p>
Declare member of the structured type.
</p>

<pre class="example">
void declmember &lt;name&gt; : &lt;T&gt; // yields void 
</pre>
</div>
</div>
<div id="outline-container-org2feafe7" class="outline-3">
<h3 id="org2feafe7">declvariant</h3>
<div class="outline-text-3" id="text-org2feafe7">
<p>
Declare enum variant.
</p>

<pre class="example">
void declvariant &lt;name&gt; : &lt;T&gt; : &lt;value&gt; // yields void 
</pre>
</div>
</div>
<div id="outline-container-org7ec1056" class="outline-3">
<h3 id="org7ec1056">declref</h3>
<div class="outline-text-3" id="text-org7ec1056">
<p>
Reference to some declaration. This instruction is 'noop'. Symbol lookup is done here during analyze pass, when symbol is not found error is generated.
</p>

<pre class="example">
&lt;*T&gt; declref &lt;name&gt; // yields pointer to found declaration
</pre>
</div>
</div>

<div id="outline-container-orgf30d507" class="outline-3">
<h3 id="orgf30d507">load</h3>
<div class="outline-text-3" id="text-orgf30d507">
<p>
Push pointed value on the stack.
</p>

<pre class="example">
&lt;T&gt; load &lt;ptr&gt; // yields T loaded from ptr
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">ptr</td>
<td class="org-left">pointer to source</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">value</td>
<td class="org-left">value loaded from source</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgdaa722b" class="outline-3">
<h3 id="orgdaa722b">store</h3>
<div class="outline-text-3" id="text-orgdaa722b">
<p>
Store value from source to destination address.
</p>

<pre class="example">
void store &lt;src&gt; -&gt; &lt;dest ptr&gt; // yields void
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">dest ptr</td>
<td class="org-left">pointer to destination</td>
</tr>

<tr>
<td class="org-left">POP</td>
<td class="org-left">src ptr</td>
<td class="org-left">value</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org0fa8e19" class="outline-3">
<h3 id="org0fa8e19">arg</h3>
<div class="outline-text-3" id="text-org0fa8e19">
<p>
Load argument of the current function on the stack.
</p>

<pre class="example">
&lt;T&gt; arg $&lt;arg number&gt; // yields T
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PUSH</td>
<td class="org-left">arg</td>
<td class="org-left">fn argument</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orge9e7efb" class="outline-3">
<h3 id="orge9e7efb">call</h3>
<div class="outline-text-3" id="text-orge9e7efb">
<p>
Call some function. This instruction will create new stack frame and switch control to the callee. 
</p>

<p>
Compile-time known arguments are passed by const value otherwise call instruction expects that all arguments are already pushed on the stack in reverse order.
</p>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PUSH RA</td>
<td class="org-left">pc, call ptr</td>
<td class="org-left">create new frame stack (push program counter and call instruction pointer)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgef25415" class="outline-3">
<h3 id="orgef25415">ret</h3>
<div class="outline-text-3" id="text-orgef25415">
<p>
Return value from the function and return control to the caller. This instruction terminates current basic block.
</p>

<p>
This instruction also clean up all argumets pushed on the stack and push return value if there is one and if it is used.
</p>

<pre class="example">
void ret [value] // yields void
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP RA</td>
<td class="org-left">-</td>
<td class="org-left">rollback the stack to return address</td>
</tr>

<tr>
<td class="org-left">POP</td>
<td class="org-left">arg 1</td>
<td class="org-left">clenup fn argument</td>
</tr>

<tr>
<td class="org-left">POP</td>
<td class="org-left">arg 2</td>
<td class="org-left">clenup fn argument</td>
</tr>

<tr>
<td class="org-left">POP</td>
<td class="org-left">arg 3</td>
<td class="org-left">clenup fn argument</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">value</td>
<td class="org-left">push call result value if there is one</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org20485a1" class="outline-3">
<h3 id="org20485a1">br</h3>
<div class="outline-text-3" id="text-org20485a1">
<p>
Breaks to the basic block. This instruction terminates current basic block.
</p>

<pre class="example">
void br &lt;block&gt; // yields void
</pre>
</div>
</div>

<div id="outline-container-orgc15ef1f" class="outline-3">
<h3 id="orgc15ef1f">br (conditional)</h3>
<div class="outline-text-3" id="text-orgc15ef1f">
<p>
Breaks into then block if the condition is true. This instruction terminates current basic block.
</p>

<pre class="example">
void br &lt;cont&gt; ? &lt;then_block&gt; : &lt;else_block&gt; // yields void
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">condition</td>
<td class="org-left">checked condition</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org3220709" class="outline-3">
<h3 id="org3220709">unreachable</h3>
<div class="outline-text-3" id="text-org3220709">
<p>
Abort execution when this instruction is reached.
</p>
</div>
</div>

<div id="outline-container-orgb996aec" class="outline-3">
<h3 id="orgb996aec">binop</h3>
<div class="outline-text-3" id="text-orgb996aec">
<p>
Binary operation.
</p>

<pre class="example">
&lt;T&gt; binop &lt;lhs&gt; &lt;+|-|*|/|%&gt; &lt;rhs&gt; // yields result value of type T
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">lhs</td>
<td class="org-left">left-hand side of operation</td>
</tr>

<tr>
<td class="org-left">POP</td>
<td class="org-left">rhs</td>
<td class="org-left">right-hand side of operation</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">result</td>
<td class="org-left">result value of the operation</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org89b9ff3" class="outline-3">
<h3 id="org89b9ff3">unop</h3>
<div class="outline-text-3" id="text-org89b9ff3">
<p>
Unary operation.
</p>

<pre class="example">
&lt;T&gt; unop &lt;+|-|*|&amp;&gt; &lt;value&gt; // yields result value of type T
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">value</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">result</td>
<td class="org-left">result value of the operation</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org09ebece" class="outline-3">
<h3 id="org09ebece">elemptr</h3>
<div class="outline-text-3" id="text-org09ebece">
<p>
Evaluates address of the array element and push it on the stack. Input array pointer can also be a pointer to slice.
</p>

<pre class="example">
&lt;*T&gt; elemptr &lt;[arr ptr|slice ptr]&gt;[&lt;index&gt;] // yields result address *T (elem type)
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">index</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">elem ptr</td>
<td class="org-left">Address of the array element</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org4e1af55" class="outline-3">
<h3 id="org4e1af55">memberptr</h3>
<div class="outline-text-3" id="text-org4e1af55">
<p>
Evaluates address of member of the structured type via '.' operator.
</p>

<pre class="example">
&lt;*T&gt; memberptr &lt;target ptr&gt;.&lt;member name|order&gt; // yields result address *T (member type)
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">target ptr</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">member ptr</td>
<td class="org-left">Address of the member</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org3ff2570" class="outline-3">
<h3 id="org3ff2570">addrof</h3>
<div class="outline-text-3" id="text-org3ff2570">
<p>
Evaluates address of the variable.
</p>

<pre class="example">
&lt;*T&gt; addrof &lt;target&gt; // yields result address *T
</pre>

<p>
Getting address of variable:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PUSH</td>
<td class="org-left">var ptr</td>
<td class="org-left">pointer to allocated variable</td>
</tr>
</tbody>
</table>

<p>
Skipped when address has been pushed by previous instruction (ex.: 'elemptr').
</p>
</div>
</div>

<div id="outline-container-org86317ce" class="outline-3">
<h3 id="org86317ce">bitcast</h3>
<div class="outline-text-3" id="text-org86317ce">
<p>
Produce bit casting from one type to other. Bit cast just change type of pushed value. No stack operations are produced.
</p>

<pre class="example">
&lt;T&gt; bitcast &lt;target&gt; // yields value with casted type
</pre>
</div>
</div>

<div id="outline-container-org6e9f0f7" class="outline-3">
<h3 id="org6e9f0f7">sext</h3>
<div class="outline-text-3" id="text-org6e9f0f7">
<p>
Signed-extend cast. 
</p>

<pre class="example">
&lt;T&gt; sext &lt;target&gt; // yields value with casted type
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">target</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">result</td>
<td class="org-left">result with new type</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8949acb" class="outline-3">
<h3 id="org8949acb">zext</h3>
<div class="outline-text-3" id="text-org8949acb">
<p>
Zero-extend cast. 
</p>

<pre class="example">
&lt;T&gt; zext &lt;target&gt; // yields value with casted type
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">target</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">resutlt</td>
<td class="org-left">result with new type</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf009043" class="outline-3">
<h3 id="orgf009043">trunc</h3>
<div class="outline-text-3" id="text-orgf009043">
<p>
Truncates target to destination type 'T'.
</p>

<pre class="example">
&lt;T&gt; trunc &lt;target&gt; // yields value with casted type
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">target</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">result</td>
<td class="org-left">result with new type</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orga7cafab" class="outline-3">
<h3 id="orga7cafab">fptosi</h3>
<div class="outline-text-3" id="text-orga7cafab">
<p>
Floating point to signed integer cast. 
</p>

<pre class="example">
&lt;T&gt; fptosi &lt;target&gt; // yields value with casted type
</pre>
</div>
</div>
<div id="outline-container-org473a1bb" class="outline-3">
<h3 id="org473a1bb">fptoui</h3>
<div class="outline-text-3" id="text-org473a1bb">
<p>
Floating point to unsigned integer cast. 
</p>

<pre class="example">
&lt;T&gt; fptoui &lt;target&gt; // yields value with casted type
</pre>
</div>
</div>
<div id="outline-container-org691255b" class="outline-3">
<h3 id="org691255b">ptrtoint</h3>
<div class="outline-text-3" id="text-org691255b">
<p>
Pointer to integer cast. This cast is noop cast when T has same size as type of the target.
</p>

<pre class="example">
&lt;T&gt; ptrtoint &lt;target&gt; // yields value with casted type
</pre>
</div>
</div>
<div id="outline-container-orgc62ac96" class="outline-3">
<h3 id="orgc62ac96">inttoptr</h3>
<div class="outline-text-3" id="text-orgc62ac96">
<p>
Integer to pointer cast. This cast is noop cast when T has same size as type of the target.
</p>

<pre class="example">
&lt;T&gt; inttoptr &lt;target&gt; // yields value with casted type
</pre>
</div>
</div>
<div id="outline-container-orgc2654a7" class="outline-3">
<h3 id="orgc2654a7">fpext</h3>
<div class="outline-text-3" id="text-orgc2654a7">
<p>
Floating point extend cast. 
</p>

<pre class="example">
&lt;T&gt; fpext &lt;target&gt; // yields value with casted type
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">target</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">resutlt</td>
<td class="org-left">result with new type</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd03bbf5" class="outline-3">
<h3 id="orgd03bbf5">fptrunc</h3>
<div class="outline-text-3" id="text-orgd03bbf5">
<p>
Truncates floating point target to destination type 'T'.
</p>

<pre class="example">
&lt;T&gt; fptrunc &lt;target&gt; // yields value with casted type
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">target</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">result</td>
<td class="org-left">result with new type</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org4b5e6c5" class="outline-3">
<h3 id="org4b5e6c5">sizeof</h3>
<div class="outline-text-3" id="text-org4b5e6c5">
<p>
Determinates size of expresion or type in compile time.
</p>

<pre class="example">
usize sizeof &lt;expr|type&gt; // yields size of input in bytes
</pre>
</div>
</div>

<div id="outline-container-org8d57670" class="outline-3">
<h3 id="org8d57670">alignof</h3>
<div class="outline-text-3" id="text-org8d57670">
<p>
Determinates alignment of expresion or type in compile time.
</p>

<pre class="example">
usize alignof &lt;expr|type&gt; // yields alignment of input
</pre>
</div>
</div>
<div id="outline-container-org1fdd592" class="outline-3">
<h3 id="org1fdd592">compound</h3>
<div class="outline-text-3" id="text-org1fdd592">
<p>
Compound initializer.
</p>

<pre class="example">
&lt;T&gt; compound &lt;T&gt; {[val, ...]} // yields T
</pre>
</div>
</div>

<div id="outline-container-org85c056a" class="outline-3">
<h3 id="org85c056a">vargs</h3>
<div class="outline-text-3" id="text-org85c056a">
<p>
Builds vargs slice from input values.
</p>

<pre class="example">
&lt;slice{usize, *T}&gt; vargs &lt;T&gt; {[val, ...]} // yields T
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">arg 1</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">POP</td>
<td class="org-left">arg 2</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">POP</td>
<td class="org-left">arg 3</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">vargs slice</td>
<td class="org-left">VArgs array slice</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf470d38" class="outline-3">
<h3 id="orgf470d38">phi</h3>
<div class="outline-text-3" id="text-orgf470d38">
<p>
Yields value based on previous executed block. This instruction yields value associated to block which executed before owner block of this instruction.
</p>

<pre class="example">
&lt;T&gt; phi [&lt;value&gt;, &lt;block name&gt;] ... // yields value of type T 
</pre>

<p>
Stack operations:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">stack op</th>
<th scope="col" class="org-left">data</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POP</td>
<td class="org-left">value</td>
<td class="org-left">Pop selected value</td>
</tr>

<tr>
<td class="org-left">PUSH</td>
<td class="org-left">value</td>
<td class="org-left">Push selected value</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Martin Dorazil</p>
<p class="date">Created: 2019-04-22 Mon 19:53</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
