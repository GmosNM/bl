#!/usr/local/bin/blc --silent -run
#import "std/fs"
#import "std/io"
#import "std/arg_parser"

BL_EXE_PATH_WIN  :: "bin/blc.exe";
BL_EXE_PATH_UNIX :: "bin/blc";

// paths
TMP_DIR :: ".temp";
MAIN_TEST_SUITE_FILEPATH :: "tests/src/main.test.bl";
EXAMPLES_DIR :: "docs/master/examples";
EXPECT_FAIL_DIR :: "tests/src/expect_fail";

HARDCODED_MODULES :: [12]string_view.{
                      "lib/bl/api/std/arg_parser/arg_parser.test.bl",
                      "lib/bl/api/std/array/array.test.bl",
                      "lib/bl/api/std/debug_allocator/debug_allocator.test.bl",
                      "lib/bl/api/std/dlib/dlib.test.bl",
                      "lib/bl/api/std/fs/fs.test.bl",
                      "lib/bl/api/std/print/print.test.bl",
                      "lib/bl/api/std/string/string.test.bl",
                      "lib/bl/api/std/sync/sync.test.bl",
                      "lib/bl/api/std/table/table.test.bl",
                      "lib/bl/api/std/thread/thread.test.bl",
                      "lib/bl/api/std/tmp_allocator/tmp_allocator.test.bl",
                      "lib/bl/api/std/buffer_allocator/buffer_allocator.test.bl",
                     };

main :: fn () s32 {
    using std;
    
    defer arg_parser_ctx_terminate(&_args);
    defer tmp_release();
    
    wdir_init();
    dir_create(get_path(TMP_DIR));
    set_cwd(get_path(TMP_DIR));
    _args.test_count = 1;
    if !parse_args() { return 1; }
    #if PLATFORM == Platform.WINDOWS {
        _compiler_path = get_path(BL_EXE_PATH_WIN);
    } else {
        _compiler_path = get_path(BL_EXE_PATH_UNIX);
    }
    start_time_ms :: os_tick_ms();

    loop c := 0; c < _args.test_count; c += 1 {
        defer tmp_reset();
        print("---------------------------------- BL DOCTOR -----------------------------------\n");    

        // general
        print("Test general suite:\n");    
        {
            path :: get_path(MAIN_TEST_SUITE_FILEPATH);
            test_file(path, TestKind.RUNTIME);
            test_file(path, TestKind.TEST);
        }

        // modules
        print("Test modules:\n");    
        loop i := 0; i < HARDCODED_MODULES.len; i += 1 {
            path :: get_path(HARDCODED_MODULES[i]);
            test_file(path, TestKind.RUNTIME);
            //test_file(file, TestKind.TEST);
        }

        { // examples

            path :: get_path(EXAMPLES_DIR);
            test_all_in_dir(path);
        }

        print("Test misc:\n");    
        { // gen-docs
            path :: get_path("docs/master/make.bl");
            test_file(path, TestKind.ANALYZE);
        }

        // expect fail to compile
        {
            path :: get_path(EXPECT_FAIL_DIR);
            test_all_in_dir(path, true);
        }

        duration_ms :: os_tick_ms() - start_time_ms;
        print("\n----------------------------------- RESULTS ------------------------------------\n");
        print("Test suite count:  %\n", _suitec);
        print("Test suite failed: %\n", _errc);
        print("Finished in:       %s\n", fmt_real(duration_ms*0.001, 2));
        print("--------------------------------------------------------------------------------\n\n");
    }
    
    // cleanup
    dir_remove_all(get_path(TMP_DIR));
    return _errc;
}

#private
TestKind :: enum {
    RUNTIME;
    COMPILE_TIME;
    TEST;
    ANALYZE;
}

Args :: struct #base std.ArgParserCtx {
    diag_mode: bool;
    stop_on_fail: bool;
    test_count: s32;
}

TEST_RUN_OK :: 0;
_args: Args;
_compiler_path: string;
_wdir: string;
_suitec := 0;
_errc := 0;

wdir_init :: fn () {
    using std;
    
    lhs: string_view;
    if str_split_by_last(#file, '/', &lhs, null) {
        _wdir = str_new(lhs, &tmp_allocator);
    } else {
        _wdir = str_new(&tmp_allocator);
    }
}

get_path :: fn (sub: string_view) string #inline {
    return tprint("%/%", _wdir, sub);
}

parse_args :: fn () bool {
    using std;
    
    parser :: arg_parser_new();
    defer arg_parser_delete(parser);

    arg_parser_add(
        parser,
        "-d",
        "--diag",
        "Diagnostic mode.",
        &fn (_: ArgParser, _: []string_view, ctx: *ArgParserCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.diag_mode = true;
            return 1, ok();
        });


    arg_parser_add(
        parser,
        "-sf",
        "--stop-on-fail",
        "Stop testing on fail.",
        &fn (_: ArgParser, _: []string_view, ctx: *ArgParserCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.stop_on_fail = true;
            return 1, ok();
        });

    arg_parser_add(
        parser,
        "-c",
        "--count",
        "<N> Specify test repeat count.",
        &fn (_: ArgParser, args: []string_view, ctx: *ArgParserCtx) (s32, Error) {
            a: *Args = auto ctx;
            if (args.len < 2) {
                return 0, error("Expected count of test repeat!");
            }
            c :: str_to_s64(args[1]);
            if c < 1 {  
                return 0, error("Test count is expected to be at least 1 not %!", c);
            }
            a.test_count = auto c;
            return 2, ok();
        });

    state :: arg_parser_run(parser, command_line_arguments, &_args, 1);   
    if !is_ok(state) {
        print_err("%", state);
        arg_parser_print_help(parser);
        return false;
    }
    if _args.help { return false; }
    return true;
}

get_verbosity :: fn () string_view #inline {
    if _args.diag_mode { return ""; } // print all
    #if PLATFORM == Platform.WINDOWS {
        return "2>nul 1>nul";
    } else {
        return "1>/dev/null 2>/dev/null";
    }
}

get_expected_error :: fn (filepath: string_view, out_err: *s32) bool {
    using std;
    
    file, err1 :: file_open(filepath, FileOpenMode.READ);
    defer file_close(file);
    if !is_ok(err1) { print_err("%", err1); return false; }
    content, err2 :: read_string(file);
    defer str_delete(&content);
    if !is_ok(err2) { print_err("%", err2); return false; }
    
    tmp :: str_split_by(content, '@');
    defer slice_terminate(&tmp);
    if tmp.len < 3 { return false; }
    err :: strtoerr(tmp[1]);
    if err == -1 { return false; }
    @out_err = err;
    return true;
}

blc :: fn (file: string, args := "--no-bin --no-warning") s32 {
    using std;
    
    cmd :: str_new(64);
    defer str_delete(&cmd);
    _suitec += 1;
    str_concat(&cmd, _compiler_path, " ", args, " ");   
    str_append(&cmd, file);
    str_append(&cmd, " ");
    str_append(&cmd, get_verbosity());
    return os_execute(cmd);
}

report_ok :: fn (msg: string_view, file: string_view, state: s32) #inline {
    print("[   OK   ] % '%' (Process exit with state: %)\n", msg, file, state);
}

report_failed :: fn (msg: string_view, file: string_view, state: s32) #inline {
    print("[ FAILED ] % '%' (Process exit with state: %)\n", msg, file, state);
    if _args.stop_on_fail { panic("Abort on fail!"); }
    _errc += 1;
}

test_file :: fn (file: string, kind := TestKind.RUNTIME, expected_state := TEST_RUN_OK) {
    using std;
    
    state: s32;
    using TestKind;
    switch kind {
        RUNTIME {
            state = blc(file, "--no-warning");
            if state == expected_state {
                report_ok("Compilation", file, state);
            } else {
                report_failed("Compilation", file, state);
                return;
            }

            tmp := str_new();
            defer str_delete(&tmp);
            #if PLATFORM == Platform.WINDOWS {
                str_append(&tmp, "out.exe ");
            } else {
                str_append(&tmp, "./out ");
            }
            str_append(&tmp, get_verbosity());
            state = os_execute(tmp);
            if state == 0 {
                report_ok("Execution", file, state);
            } else {
                report_failed("Execution", file, state);
            } 
        }

        COMPILE_TIME {
            state = blc(file, "--no-warning --run");
            if state == expected_state {
                report_ok("Interpretation", file, state);
            } else {
                report_failed("Interpretation", file, state);
            }
        }
        
        TEST {
            state = blc(file, "--run-tests --no-bin --no-warning");
            if state == expected_state {
                report_ok("Run compile time tests", file, state);
            } else {
                report_failed("Run compile time tests", file, state);
            }
        }

        ANALYZE {
            state = blc(file, "--no-warning --no-bin");
            if state == expected_state {
                report_ok("Analyze", file, state);
            } else {
                report_failed("Analyze", file, state);
            }
        }
    }
    dir_remove_all(get_path(TMP_DIR), false);
}

test_all_in_dir :: fn (dir: string, expect_fail := false) {
    using std;
    
    file :: str_new(64);
    defer str_delete(&file);
    
    print("Testing files in directory '%':\n", dir);        
    list, err :: dir_scan(dir);
    if !is_ok(err) {
        print_err("%", err);
    }
    defer info_list_delete(list);

    loop i := 0; i < list.len; i += 1 {
        info :: &list[i];
        if info.kind != InfoKind.DIRECTORY {
            str_clear(&file);
            str_concat(&file, dir, "/", info.name);
            if expect_fail {
                error_code: s32 #noinit;
                if get_expected_error(file, &error_code) {
                    test_file(file, TestKind.ANALYZE, error_code);
                } else {
                    print_err("Cannot get expected error code for file '%'", file);
                }
            } else {
                test_file(file);
            }
        }
    }
}

// ERROR CODES (This must be keept in sync with src/error.h)
BlError :: enum s32 {
    NO_ERR = 0;
    ERR_FILE_NOT_FOUND          = 1;
    ERR_INVALID_SOURCE          = 2;
    ERR_INVALID_TOKEN           = 3;
    ERR_UNTERMINATED_COMMENT    = 4;
    ERR_UNTERMINATED_STRING     = 5;
    ERR_MISSING_SEMICOLON       = 6;
    ERR_MISSING_BRACKET         = 7;
    ERR_UNEXPECTED_DECL         = 8;
    ERR_EXPECTED_EXPR           = 9;
    ERR_MISSING_COMMA           = 10;
    ERR_EXPECTED_BODY           = 11;
    ERR_EXPECTED_BODY_END       = 12;
    ERR_EXPECTED_STMT           = 13;
    ERR_BREAK_OUTSIDE_LOOP      = 14;
    ERR_CONTINUE_OUTSIDE_LOOP   = 15;
    ERR_UNEXPECTED_DIRECTIVE    = 16;
    ERR_DUPLICATE_SYMBOL        = 17;
    ERR_UNKNOWN_SYMBOL          = 18;
    ERR_EXPECTED_TYPE           = 19;
    ERR_EXPECTED_NAME           = 20;
    ERR_EXPECTED_BINOP          = 21;
    ERR_DUPLICATE_ENTRY         = 22;
    ERR_NOT_VERIFIED            = 23;
    ERR_CANNOT_WRITE_BC         = 24;
    ERR_CANNOT_LINK             = 25;
    ERR_DIFF_KIND_OF_SYMBOL     = 26;
    ERR_INVALID_PARAM_COUNT     = 27;
    ERR_UNKNOWN_TYPE            = 28;
    ERR_PRIVATE                 = 29;
    ERR_UNCOMPATIBLE_MODIF      = 30;
    ERR_NO_MAIN_METHOD          = 31;
    ERR_INVALID_RESULT          = 32;
    ERR_INVALID_ARG_COUNT       = 33;
    ERR_INVALID_ARG_TYPE        = 34;
    ERR_INVALID_TYPE            = 35;
    ERR_INVALID_EXPR            = 36;
    ERR_JIT_RUN_FAILED          = 37;
    ERR_EXPECTED_STRING         = 38;
    ERR_EXPECTED_MODULE         = 39;
    ERR_EXPECTED_FUNC           = 40;
    ERR_MISSING_RETURN          = 41;
    ERR_EMPTY                   = 42;
    ERR_UNEXPECTED_SYMBOL       = 43;
    ERR_MULTIPLE_MAIN           = 44;
    ERR_EXPECTED_INITIALIZATION = 45;
    ERR_EXPECTED_TYPE_REF       = 46;
    ERR_EXPECTED_TYPE_STRUCT    = 47;
    ERR_INVALID_MUTABILITY      = 48;
    ERR_INVALID_NAME            = 49;
    ERR_INVALID_MEMBER_ACCESS   = 50;
    ERR_UNIMPLEMENTED           = 51;
    ERR_EXPECTED_CONST          = 52;
    ERR_EXPECTED_DECL           = 53;
    ERR_FILE_READ               = 54;
    ERR_FILE_EMPTY              = 55;
    ERR_INVALID_INITIALIZER     = 56;
    ERR_INVALID_CAST            = 57;
    ERR_INVALID_ADM             = 58;
    ERR_DIV_BY_ZERO             = 59;
    ERR_LIB_NOT_FOUND           = 60;
    ERR_LIB_SYMBOL_NOT_FOUND    = 61;
    ERR_EXPECTED_TEST_DESC      = 62;
    ERR_NULL_POINTER            = 63;
    ERR_INVALID_ARR_SIZE        = 64;
    ERR_BOUND_CHECK_FAILED      = 65;
    ERR_EMPTY_STRUCT            = 66;
    ERR_UNINITIALIZED           = 67;
    ERR_INVALID_ADDRES_MODE     = 68;
    ERR_EMPTY_ENUM              = 69;
    ERR_INVALID_DIRECTIVE       = 70;
    ERR_UNEXPECTED_EXPR         = 71;
    ERR_EXPECTED_COMPTIME       = 72;
    ERR_NUM_LIT_OVERFLOW        = 73;
    ERR_INVALID_SWITCH_CASE     = 74;
    ERR_DUPLICIT_SWITCH_CASE    = 75;
    ERR_INVALID_REFERENCE       = 76;
    ERR_UNEXPECTED_RETURN       = 77;
    ERR_AMBIGUOUS               = 78;
    ERR_MISSING_PLATFORM        = 79;
    ERR_UNEXPECTED_FUNCTION_BODY = 80;
    ERR_INVALID_POLY_MATCH       = 81;
    ERR_UNSUPPORTED_TARGET       = 82;
    ERR_COMPILE_TIME_ABORT       = 83;
    ERR_USER                     = 84;
}

strtoerr :: fn (s: string_view) s32 {
    info :: cast(*TypeInfoEnum) typeinfo(BlError);
    loop i := 0; i < info.variants.len; i += 1 {
        variant :: &info.variants[i];
        if std.str_match(variant.name, s) { return auto variant.value; }
    }
    return -1;
}
