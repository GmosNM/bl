#!/usr/local/bin/blc --silent -run
#import "std/arg_parser"
#import "std/fs"
#import "std/io"

TEMPORARY_DIR :: "tmp-doctor";
TEST_SRC_DIR :: "tests/src";
EXAMPLES_DIR :: "docs/master/docs/examples";
EXPECT_FAIL_DIR :: "tests/src/expect_fail";
DOCS_MAKE :: "docs/master/make.bl";

SKIP :: [1]Skip.{
    Skip.{
        name = "tmp_allocator.test.bl",
        kind = TestKind.TEST_RUN
    }
};

MODULES :: [12]string_view.{
    "lib/bl/api/std/arg_parser/arg_parser.test.bl",
    "lib/bl/api/std/array/array.test.bl",
    "lib/bl/api/std/debug_allocator/debug_allocator.test.bl",
    "lib/bl/api/std/dlib/dlib.test.bl",
    "lib/bl/api/std/fs/fs.test.bl",
    "lib/bl/api/std/print/print.test.bl",
    "lib/bl/api/std/string/string.test.bl",
    "lib/bl/api/std/sync/sync.test.bl",
    "lib/bl/api/std/table/table.test.bl",
    "lib/bl/api/std/thread/thread.test.bl",
    "lib/bl/api/std/pool/pool.test.bl",
    "lib/bl/api/std/buffer_allocator/buffer_allocator.test.bl",
};

TestKind :: enum {
    // Compile and execute.
    EXECUTE;
    // Just compile.
    COMPILE;
    // Compile and execute + include custom main.
    TEST_EXECUTE;
    // Compile and execute in compile-time + include custom main.
    TEST_RUN;
    // Compile and expect fail.
    TEST_EXPECT_FAIL;
}

State :: enum #flags {
    PASSED = 0;
    FAILED_COMPILE;
    FAILED_EXECUTE;
    FAILED_RUN;
    FAILED_EXPECT_FAIL;
}

Result :: struct {
    name: string_view;
    state: State;
}

Skip :: struct {
    name: string_view;
    kind: TestKind;
}

Args :: struct #base std.ArgParserCtx {
    keep_temporary: bool;
}

args: Args;
working_directory: string_view;
temporary_directory: string_view;
compiler: string_view;
main_file: string_view;

main :: fn () s32 {
    using std;

    defer temporary_release();
    defer arg_parser_ctx_terminate(&args);

    working_directory = get_working_directory();
    compiler = get_compiler_path();
    temporary_directory = get_full_path(TEMPORARY_DIR);
    main_file = get_full_path("tests/main.test.bl");

    dir_remove_all(temporary_directory);
    dir_create(temporary_directory);
    set_cwd(temporary_directory);
    defer cleanup();

    if !parse_args() { return 1; }

    start_time_ms :: os_tick_ms();

    results: [..]Result;
    files: [..]string_view;
    array_init(&results, 256, &default_temporary_allocator);
    array_init(&files, 256, &default_temporary_allocator);

    print_sections :: args.positional.len == 0;

    using TestKind;

    // Test main suite
    if print_sections {
        print("\nMain suite execution:\n");
    } else {
        print("Testing: %\n", args.positional);
    }
    list_dir(&files, get_full_path(TEST_SRC_DIR));
    loop i := 0; i < files.len; i += 1 {
        test_file(&results, files[i], TEST_EXECUTE);
    }
    if print_sections { print("\nMain suite interpretation:\n"); }
    loop i := 0; i < files.len; i += 1 {
        test_file(&results, files[i], TEST_RUN);
    }

    // Test modules
    if print_sections { print("\nModules:\n"); }
    loop i := 0; i < MODULES.len; i += 1 {
        test_file(&results, get_full_path(MODULES[i]), TEST_EXECUTE);
    }

    // Test examples
    if print_sections { print("\nExamples:\n"); }
    array_clear(&files);
    list_dir(&files, get_full_path(EXAMPLES_DIR));
    loop i := 0; i < files.len; i += 1 {
        test_file(&results, files[i], EXECUTE);
    }

    // Test fail expected
    if print_sections { print("\nExpect fail:\n"); }
    array_clear(&files);
    list_dir(&files, get_full_path(EXPECT_FAIL_DIR));
    loop i := 0; i < files.len; i += 1 {
        test_file(&results, files[i], TEST_EXPECT_FAIL);
    }

    // Test docs make
    if print_sections { print("\nMisc:\n"); }
    test_file(&results, get_full_path(DOCS_MAKE), COMPILE);

    // Print results
    failed_count := 0;
    print("\n----------------------------------- RESULTS ------------------------------------\n");
    loop i := 0; i < results.len; i += 1 {
        result :: &results[i];
        if result.state != State.PASSED {
            print("[ FAILED ] '%' (%)\n", result.name, result.state);
            failed_count += 1;
        }
    }
    if failed_count > 0 {
        print("--------------------------------------------------------------------------------\n");
    }
    duration_ms :: os_tick_ms() - start_time_ms;
    print("Test suite count:  %\n", results.len);
    print("Test suite failed: %\n", failed_count);
    print("Finished in:       %s\n", fmt_real(duration_ms*0.001, 2));
    print("--------------------------------------------------------------------------------\n\n");

    return 0;
}

cleanup :: fn () {
    using std;
    set_cwd(working_directory);
    if !args.keep_temporary {
        dir_remove_all(temporary_directory);
    }
}

test_file :: fn (results: *[..]Result, filepath: string_view, kind: TestKind) {
    using std;
    using State;
    name: string_view;
    if !str_split_by_last(filepath, '/', null, &name) {
        name = filepath;
    }
    test_only : []string_view : args.positional;
    excluded := test_only.len > 0;
    loop i := 0; i < test_only.len; i += 1 {
        other_name :: test_only[i];
        if str_match(name, other_name) {
            excluded = false;
            break;
        }
    }
    if excluded { return; }

    result := array_push(results);
    result.name  = name;
    result.state = PASSED;

    loop i := 0; i < SKIP.len; i += 1 {
        skip :: &SKIP[i];
        if str_match(skip.name, result.name) && kind == skip.kind { return; }
    }

    using TestKind;
    switch kind {
        EXECUTE {
            if os_execute(tprint("% % %", compiler, "--no-warning --silent", filepath)) != 0 {
                set_flag(&result.state, FAILED_COMPILE);
            } else if os_execute(tprint("% %", get_exe_name(), silent_output())) != 0 {
                set_flag(&result.state, FAILED_EXECUTE);
            }
            report(result);
        }

        COMPILE {
            if os_execute(tprint("% % %", compiler, "--no-warning --silent --no-bin", filepath)) != 0 {
                set_flag(&result.state, FAILED_COMPILE);
            }
            report(result);
        }

        TEST_EXECUTE {
            if os_execute(tprint("% % % %", compiler, "--no-warning --silent", main_file, filepath)) != 0 {
                set_flag(&result.state, FAILED_COMPILE);
            } else if os_execute(get_exe_name()) != 0 {
                set_flag(&result.state, FAILED_EXECUTE);
            }
        }

        TEST_RUN {
            if os_execute(tprint("% % % %", compiler, "--no-warning --silent --no-bin --run-tests --tests-minimal-output", main_file, filepath)) != 0 {
                set_flag(&result.state, FAILED_RUN);
            }
        }

        TEST_EXPECT_FAIL {
            msg := "";
            is_present, expected_code :: get_expected_error(filepath);
            if !is_present {
                set_flag(&result.state, FAILED_EXPECT_FAIL);
                msg = "Expected error code not found!";
            } else {
                state := os_execute(tprint("% % % %", compiler, "--no-warning --silent --no-bin", filepath, silent_output()));
                if state != expected_code {
                    set_flag(&result.state, FAILED_EXPECT_FAIL);
                    msg = tprint("Expected '%' but returned '%'\n", errtostr(expected_code), errtostr(state));
                }
            }
            report(result, msg);
        }
    }
}

report :: fn (result: *Result, msg := "") {
    if result.state != State.PASSED {
        print("[      | FAIL ] % %\n", result.name, msg);
    } else {
        print("[ PASS |      ] % %\n", result.name, msg);
    }
}

parse_args :: fn () bool {
    using std;

    parser :: arg_parser_new();
    defer arg_parser_delete(parser);

    arg_parser_add(
        parser,
        "",
        "--keep-tmp",
        "Keep temporary directory.",
        &fn (_: ArgParser, _: []string_view, ctx: *ArgParserCtx) (s32, Error) {
            a: *Args = auto ctx;
            a.keep_temporary = true;
            return 1, OK;
        });

    state :: arg_parser_run(parser, command_line_arguments, &args, 1);
    if state {
        print_err("%", state);
        arg_parser_print_help(parser);
        return false;
    }
    if args.help { return false; }
    return true;
}

list_dir :: fn (paths: *[..]string_view, dir: string_view) {
    using std;

    list, err :: dir_scan(dir);
    defer info_list_delete(list);
    if err {
        print_err("%", err);
        return;
    }

    loop i := 0; i < list.len; i += 1 {
        info :: &list[i];
        if info.kind != InfoKind.DIRECTORY {
            array_push(paths, tprint("%/%", dir, info.name));
        }
    }
}

get_working_directory :: fn () string_view {
    using std;
    lhs: string_view;
    if str_split_by_last(#file, '/', &lhs, null) {
        return str_new(lhs, &default_temporary_allocator);
    } else {
        return str_new(&default_temporary_allocator);
    }
}

get_full_path :: fn (relative: string_view) string_view #inline {
    return tprint("%/%", working_directory, relative);
}

silent_output :: fn () string_view #comptime {
    #if PLATFORM == Platform.WINDOWS {
        return "2>nul 1>nul";
    } else {
        return "1>/dev/null 2>/dev/null";
    }
}

get_compiler_path :: fn () string_view #inline {
    #if PLATFORM == Platform.WINDOWS {
        return get_full_path("bin/blc.exe");
    } else {
        return get_full_path("bin/blc");
    }
}

get_exe_name :: fn () string_view #comptime {
    #if PLATFORM == Platform.WINDOWS {
        return "out.exe";
    } else {
        return "./out";
    }
}

get_expected_error :: fn (filepath: string_view) (is_present: bool, error: s32) {
    using std;

    file, err1 :: file_open(filepath, FileOpenMode.READ);
    defer file_close(file);
    if err1 { print_err("%", err1); return false, 0; }
    content, err2 :: read_string(file);
    defer str_delete(&content);
    if err2 { print_err("%", err2); return false, 0; }

    tmp :: str_split_by(content, '@');
    defer slice_terminate(&tmp);
    if tmp.len < 3 { return false, 0; }
    err :: strtoerr(tmp[1]);
    if err == -1 { return false, 0; }
    return true, err;
}

// ERROR CODES (This must be keept in sync with src/error.h)
BlError :: enum s32 {
    NO_ERR = 0;
    ERR_FILE_NOT_FOUND          = 1;
    ERR_INVALID_SOURCE          = 2;
    ERR_INVALID_TOKEN           = 3;
    ERR_UNTERMINATED_COMMENT    = 4;
    ERR_UNTERMINATED_STRING     = 5;
    ERR_MISSING_SEMICOLON       = 6;
    ERR_MISSING_BRACKET         = 7;
    ERR_UNEXPECTED_DECL         = 8;
    ERR_EXPECTED_EXPR           = 9;
    ERR_MISSING_COMMA           = 10;
    ERR_EXPECTED_BODY           = 11;
    ERR_EXPECTED_BODY_END       = 12;
    ERR_EXPECTED_STMT           = 13;
    ERR_BREAK_OUTSIDE_LOOP      = 14;
    ERR_CONTINUE_OUTSIDE_LOOP   = 15;
    ERR_UNEXPECTED_DIRECTIVE    = 16;
    ERR_DUPLICATE_SYMBOL        = 17;
    ERR_UNKNOWN_SYMBOL          = 18;
    ERR_EXPECTED_TYPE           = 19;
    ERR_EXPECTED_NAME           = 20;
    ERR_EXPECTED_BINOP          = 21;
    ERR_DUPLICATE_ENTRY         = 22;
    ERR_NOT_VERIFIED            = 23;
    ERR_CANNOT_WRITE_BC         = 24;
    ERR_CANNOT_LINK             = 25;
    ERR_DIFF_KIND_OF_SYMBOL     = 26;
    ERR_INVALID_PARAM_COUNT     = 27;
    ERR_UNKNOWN_TYPE            = 28;
    ERR_PRIVATE                 = 29;
    ERR_UNCOMPATIBLE_MODIF      = 30;
    ERR_NO_MAIN_METHOD          = 31;
    ERR_INVALID_RESULT          = 32;
    ERR_INVALID_ARG_COUNT       = 33;
    ERR_INVALID_ARG_TYPE        = 34;
    ERR_INVALID_TYPE            = 35;
    ERR_INVALID_EXPR            = 36;
    ERR_JIT_RUN_FAILED          = 37;
    ERR_EXPECTED_STRING         = 38;
    ERR_EXPECTED_MODULE         = 39;
    ERR_EXPECTED_FUNC           = 40;
    ERR_MISSING_RETURN          = 41;
    ERR_EMPTY                   = 42;
    ERR_UNEXPECTED_SYMBOL       = 43;
    ERR_MULTIPLE_MAIN           = 44;
    ERR_EXPECTED_INITIALIZATION = 45;
    ERR_EXPECTED_TYPE_REF       = 46;
    ERR_EXPECTED_TYPE_STRUCT    = 47;
    ERR_INVALID_MUTABILITY      = 48;
    ERR_INVALID_NAME            = 49;
    ERR_INVALID_MEMBER_ACCESS   = 50;
    ERR_UNIMPLEMENTED           = 51;
    ERR_EXPECTED_CONST          = 52;
    ERR_EXPECTED_DECL           = 53;
    ERR_FILE_READ               = 54;
    ERR_FILE_EMPTY              = 55;
    ERR_INVALID_INITIALIZER     = 56;
    ERR_INVALID_CAST            = 57;
    ERR_INVALID_ADM             = 58;
    ERR_DIV_BY_ZERO             = 59;
    ERR_LIB_NOT_FOUND           = 60;
    ERR_LIB_SYMBOL_NOT_FOUND    = 61;
    ERR_EXPECTED_TEST_DESC      = 62;
    ERR_NULL_POINTER            = 63;
    ERR_INVALID_ARR_SIZE        = 64;
    ERR_BOUND_CHECK_FAILED      = 65;
    ERR_EMPTY_STRUCT            = 66;
    ERR_UNINITIALIZED           = 67;
    ERR_INVALID_ADDRES_MODE     = 68;
    ERR_EMPTY_ENUM              = 69;
    ERR_INVALID_DIRECTIVE       = 70;
    ERR_UNEXPECTED_EXPR         = 71;
    ERR_EXPECTED_COMPTIME       = 72;
    ERR_NUM_LIT_OVERFLOW        = 73;
    ERR_INVALID_SWITCH_CASE     = 74;
    ERR_DUPLICIT_SWITCH_CASE    = 75;
    ERR_INVALID_REFERENCE       = 76;
    ERR_UNEXPECTED_RETURN       = 77;
    ERR_AMBIGUOUS               = 78;
    ERR_MISSING_PLATFORM        = 79;
    ERR_UNEXPECTED_FUNCTION_BODY = 80;
    ERR_INVALID_POLY_MATCH       = 81;
    ERR_UNSUPPORTED_TARGET       = 82;
    ERR_COMPILE_TIME_ABORT       = 83;
    ERR_USER                     = 84;
}

strtoerr :: fn (s: string_view) s32 {
    info :: cast(*TypeInfoEnum) typeinfo(BlError);
    loop i := 0; i < info.variants.len; i += 1 {
        variant :: &info.variants[i];
        if std.str_match(variant.name, s) { return auto variant.value; }
    }
    return -1;
}

errtostr :: fn (code: s32) string_view {
    info :: cast(*TypeInfoEnum) typeinfo(BlError);
    loop i := 0; i < info.variants.len; i += 1 {
        variant :: &info.variants[i];
        if variant.value == code { return variant.name; }
    }
    return "UNKNOWN";
}
