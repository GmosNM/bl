* defer statement
  - defer must be executed at the end of the scope
  - when defer has not been reached it should not be executed
  - return should call all previous defers
  - defers must be called after return value is evaluated
  - generate only once

  if_block:
  ...
  eval return value
  br defer_block

  body_block:
  ...
  eval return value
  br defer_block

  return_block_A:
  ret value

  return_block_B:
  ret value

  defer_block: 
  call terminate()
  br return_block_A or return_block_B
  

  Code:
  #+BEGIN_SRC bl
  foo :: fn () s32 {
      defer A;         // push A
      if expr {
          defer B;     // push B
	  return 1;    // B, A 
      }                // pop B
      
      defer C;         // push C
      return 0;        // C, A
  } 
  #+END_SRC

  Implementation [40%]
  - [X] Tmp for return value
  - [X] Create return block
  - [ ] Store somewhere all defers in scope context (into the Scope ???)
  - [ ] Generate defer blocks
  - [ ] Connect all blocks
