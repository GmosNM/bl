// TODO: miniaudio, GL, shader compilation, texture loading

#import "extra/glfw3"
#import "extra/leo"

WINDOW_WIDTH  :: 800;
WINDOW_HEIGHT :: 600;
WINDOW_TITLE  :: "Gunner!";
window: *glfw.Window;

main :: fn () s32 {
    // Initialize GLFW.
    if glfw.Init() == 0 {
        print_glfw_error();
        panic("Cannot initialize Glfw.\n");
    }

    // Create GLFW window.
    glfw.WindowHint(glfw.CONTEXT_VERSION_MAJOR, 3);
    glfw.WindowHint(glfw.CONTEXT_VERSION_MINOR, 3);
    glfw.WindowHint(glfw.OPENGL_FORWARD_COMPAT, 1);
    glfw.WindowHint(glfw.OPENGL_PROFILE, glfw.OPENGL_CORE_PROFILE);
    glfw.WindowHint(glfw.DOUBLEBUFFER, glfw.TRUE);
    glfw.WindowHint(glfw.RESIZABLE, glfw.FALSE);

    window = glfw.CreateWindow(
        WINDOW_WIDTH,
        WINDOW_HEIGHT,
        std.strtoc(WINDOW_TITLE), // Convert bl string_view to C string.
        null,
        null
    );

    if !window {
        print_glfw_error();
        panic("Cannot create GLFW window.\n");
    }

    glfw.MakeContextCurrent(window);
    glfw.SwapInterval(1);

    leo.init(WINDOW_WIDTH, WINDOW_HEIGHT);

    // Game loop comes here!
    loop glfw.WindowShouldClose(window) == 0 {
        glfw.PollEvents();
        using leo;
        using glm;

        begin_frame();

        // Clear the frame.
        clear_color();

        set_color_shader();
        draw_rect(10.f, 20.f, 100.f, 100.f, v4.{ 1.f, 0.f, 1.f, 1.f });

        end_frame();

        // Swap buffers to see rendered stuff.
        glfw.SwapBuffers(window);

        // Since we use temporary allocator, we should reset it's internal storage
        // each frame.
        temporary_reset();
    }

    // Termination
    leo.terminate();
    glfw.DestroyWindow(window);
    glfw.Terminate();
    return 0;
}

#private
// Following code is private to this file.

print_glfw_error :: fn () {
    cstr: *u8;
    glfw.GetError(&cstr);

    if cstr == null { return; }
    tmp := string_view.{ auto C.strlen(auto cstr), auto cstr };
    print_err("GLFW Error: %", tmp);
}
