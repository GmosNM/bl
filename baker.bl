#!/usr/local/bin/blc -rs

#import "std/arg_parser"
#import "std/fs"

Args :: struct #base ArgParser.Ctx {
    generate: bool;
    cmake_cache_clear: bool;
    is_debug: bool;
    make: bool;
    tracy_enable: bool;
    format: bool;
}

TRACY_VERSION :: "0.7.8";
BIN_DIR :: "bin";
BUILD_DIR :: "build";
SRC_DIR :: "src";
CMAKE_CACHE :: "CMakeCache.txt";

FORMAT_EXCLUDED_FILES :: {:[1]string:
    "stb_ds.h"
};

HELP_TEXT ::
"Biscuit Baker Tool.\n\n"
"This tool can be used for generation and compilation of Biscuit compiler\n"
"project.\n\n"
"Requirements:\n"
"  - MS Build tools/gcc/clang\n"
"  - CMake\n"
"  - x64 development environment injected on Windows (use VS command line).\n"
"  - clang-format.\n\n"
"Usage:\n"
"  baker [options]\n";

g_args: Args;
g_root_dir: string;


main :: fn () s32 {
    defer temporary_release();
    
    parser :: ArgParser.new(HELP_TEXT);
    defer ArgParser.delete(parser);

    g_root_dir = Fs.get_cwd();
    defer String.delete(g_root_dir);
    
    ArgParser.add(
        parser,
        "-m",
        "--make",
        "Make project.",
        &fn (_: ArgParser.Parser, _: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.generate = true;
            a.make = true;
            return 1, ok();
        });
        
    ArgParser.add(
        parser,
        "-g",
        "--generate",
        "Generate project.",
        &fn (_: ArgParser.Parser, _: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.generate = true;
            return 1, ok();
        });
    
    ArgParser.add(
        parser,
        "-d",
        "--debug",
        "Switch from release to debug mode. (must be used with '--generate' or '--make').",
        &fn (_: ArgParser.Parser, _: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.is_debug = true;
            return 1, ok();
        });
    
    ArgParser.add(
        parser,
        "-te",
        "--tracy-enable",
        "Enable and compile Tracy profiler.",
        &fn (_: ArgParser.Parser, _: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.tracy_enable = true;
            a.generate = true;
            a.make = true;
            return 1, ok();
        });
        
    ArgParser.add(
        parser,
        "-f",
        "--format-source",
        "Format source code using clang-format.",
        &fn (_: ArgParser.Parser, _: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.format = true;
            return 1, ok();
        });

    ArgParser.add(
        parser,
        "",
        "--clear-cache",
        "Clear the cmake cache.",
        &fn (_: ArgParser.Parser, _: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.cmake_cache_clear = true;
            return 1, ok();
        });
   
    state :: ArgParser.run(parser, command_line_arguments, &g_args, 1);
    if !is_ok(state) {
        print_err("%", state);
        ArgParser.print_help(parser);
        return 1;
    }
    if g_args.help { return 0; }
    if command_line_arguments.len == 1 {
        g_args.cmake_cache_clear = true;
        g_args.generate = true;
        g_args.make = true;
    }
     
    Fs.dir_create(BUILD_DIR);
    Fs.dir_create(BIN_DIR);
    
    conf :: conf_name(g_args.is_debug);
    if g_args.format {
        print("Formating source files.\n");
        format();
    }
    if g_args.generate {
        print("Generate configuration '%' in '%'.\n", conf, BUILD_DIR);
        cmake_generate();
    }
    if g_args.make {
        print("Build configuration '%' in '%'.\n", conf, BUILD_DIR);
        cmake_compile();
    }
    if g_args.tracy_enable {
        print("Build Tracy profiler client.\n");
        tracy_compile();
    }
    return 0;
}

conf_name :: fn (is_debug: bool) string #inline {
    if is_debug { return "Debug"; }
    return "Release";
}

cmake_generate :: fn () s32 #inline {
    is_debug :: g_args.is_debug;
    conf :: conf_name(is_debug);
    cmd: string;
    
    Fs.set_cwd(BUILD_DIR);
    defer Fs.set_cwd(g_root_dir);
    if g_args.cmake_cache_clear { Fs.remove(CMAKE_CACHE); }
    #if PLATFORM == Platform.windows {
        cmd = tprint("cmake .. -G \"Visual Studio 16 2019\" -Thost=x64 -DCMAKE_BUILD_TYPE=%", conf);
    } else {
        cmd = tprint("cmake .. -DCMAKE_BUILD_TYPE=%", conf);
    }
    if g_args.tracy_enable {
        String.append(&cmd, " -DTRACY_ENABLE=ON");
        String.append(&cmd, " -DTRACY_VER=");
        String.append(&cmd, TRACY_VERSION);
    }
    return os_execute(cmd);
}

cmake_compile :: fn () s32 #inline {
    is_debug :: g_args.is_debug;
    conf :: conf_name(is_debug);
    cmd: string;
    Fs.set_cwd(BUILD_DIR);
    defer Fs.set_cwd(g_root_dir);
    #if PLATFORM == Platform.windows {
        cmd = tprint("cmake --build . --config %", conf);
    } else {
        cmd = tprint("make -j");
    }
    return os_execute(cmd);
}

format :: fn () s32 #inline {
    info, err :: Fs.dir_scan(SRC_DIR, &fn (info: *Fs.Info) bool {
        if info.kind == Fs.InfoKind.Directory { return false; }
        ext :: Fs.get_extension(info.name);
        if String.compare(ext, "c") || String.compare(ext, "h") || String.compare(ext, "cpp"){
            loop i := 0; i < FORMAT_EXCLUDED_FILES.len; i += 1 {
                if String.compare(FORMAT_EXCLUDED_FILES[i], info.name) {
                    return false;
                }
            }
            return true;
        }
        return false;
    });
    defer Fs.info_list_delete(info);
    if is_ok(err) {
        loop i := 0; i < info.len; i += 1 {
            print("Formatting: %\n", info[i].name);
            os_execute(tprint("clang-format -i -style=file %/%", SRC_DIR, info[i].name));
        }
    } else {
        print("%\n", err);
    }
    return 0;
}

tracy_compile :: fn () s32 {
    path := String.new();
    defer String.delete(path);
    
    Fs.set_cwd(String.clear_concat(&path, "deps/tracy-", TRACY_VERSION));
    defer Fs.set_cwd(g_root_dir);
    
    #if PLATFORM == Platform.windows {
        { // Deps
            print("Install Tracy dependencies...\n");
            Fs.set_cwd("vcpkg");
            defer Fs.set_cwd("..");
            if os_execute("call install_vcpkg_dependencies.bat") != 0 {
                print_err("Failed to install Tracy dependencies!");
                return -1;
            }
        }
        { // Profiler compilation
            print("Compile Tracy profiler...\n");
            if os_execute("msbuild profiler/build/win32/Tracy.sln /p:Configuration=Release /property:Platform=x64 /consoleloggerparameters:ErrorsOnly /nologo") != 0 {
                print_err("Failed to compile Tracy profiler!");
                return -1;   
            }
            err :: Fs.copy("profiler/build/win32/x64/Release/Tracy.exe", String.clear_concat(&path, g_root_dir, "/bin/Tracy.exe"), true);
            if is_ok(err) {
                print("Success, created executable 'bin/Tracy.exe'.\n");
            } else {
                print("%\n", err);
            }
        }
    } else {
        print_warn("Tracy compilation not implemented yet!");
    }
    return -1;
}
