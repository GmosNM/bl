#import "std/arg_parser"
#import "std/fs"

BIN_DIR :: "bin";

build :: fn () #build_entry {
    args: Args;
    if !handle_args(&args) { return; }
    if args.help { return; }
    if args.clean {
        print("Cleanup '%'.\n", BIN_DIR);
        fs_dir_remove_all(BIN_DIR, false);
        return;
    }

    exe :: add_executable("run");
    add_unit(exe, "main.bl");
    set_module_dir(exe, "modules", ModuleImportPolicy.BundleLatest);
    set_output_dir(exe, BIN_DIR);
    set_copy_deps(exe, true);

    if args.release {
        set_build_mode(exe, BuildMode.ReleaseFast);
    }

    print("Out dir:       %\n", get_output_dir(exe));
    print("Module dir:    %\n", get_module_dir(exe));
    print("Module policy: %\n", get_module_import_policy(exe));
}

Args :: struct #base ArgCtx {
    release: bool;
    clean: bool;
}

handle_args :: fn (args: *Args) bool {
    arg_parser :: arg_parser_new();
    defer arg_parser_delete(arg_parser);

    arg_parser_add(
        arg_parser,
        "-r",
        "--release",
        "Release build.",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) s32 {
            a: *Args = auto ctx;
            a.release = true;
            return 1;
        });

    arg_parser_add(
        arg_parser,
        "-c",
        "--clean",
        "Cleanup build artifacts and exit.",
        &fn (parser: ArgParser, args: []string, ctx: *ArgCtx) s32 {
            a: *Args = auto ctx;
            a.clean = true;
            return 1;
        });

    state :: arg_parser_run(arg_parser, command_line_arguments, args);   
    if !is_ok(state) {
        print_err("%", state);
        arg_parser_print_help(arg_parser);
        return false;
    }
    return true;
}