#import "std/io"

MyStream :: struct {
    vtable: *MyStreamVTable;
}

MyStreamVTable :: struct {
    using std;
    read: StreamReadFn(MyStream);
    write: StreamWriteFn(MyStream);
}

MY_STRAM_VTABLE :: MyStreamVTable.{
    read = &my_read,
    write = &my_write
};

my_read :: fn (stream: *MyStream, dest: *u8, bytes_to_read: s64) (bytes_read: s64, err: Error) {
    stream; dest; bytes_to_read;
    print("Reading!!!");
    return 0, OK;
}

my_write :: fn(stream: *MyStream, src: *u8, bytes_to_write: s64) (bytes: s64, err: Error) {
    stream; src; bytes_to_write;
    print("Writing!!!");
    return 0, OK;
}

main :: fn () s32 {
    stream := MyStream.{ vtable = &MY_STRAM_VTABLE };
    i: u8;
    std.write2(&stream, &i, 10);
    return 0;
}


/*
#import "std/io"

MyStream :: struct #base std.Stream {
    // Internal buffer used to hold data.
    buf: [64]u8;
    // Current index in the buffer array.
    index: s64;
}

// Custom stream virtual table.
MY_STREAM_VTABLE :: std.StreamVTable.{
    read = auto &my_stream_read,
    write = auto &my_stream_write,
};

my_stream_read :: fn (stream: *MyStream, dest: *u8, bytes_to_read: s64) (s64, Error) {
    using std;
    size := min(stream.index, bytes_to_read);
    stream.index -= size;
    assert(stream.index >= 0);
    if size > 0 { memcpy(dest, &stream.buf[stream.index], auto size); }
    return size, OK;
}

my_stream_write :: fn (stream: *MyStream, src: *u8, bytes_to_write: s64) (s64, Error) {
    size :: std.min(stream.buf.len - stream.index, bytes_to_write);
    if size > 0 { memcpy(&stream.buf[stream.index], src, auto size); }
    stream.index += size;
    assert(stream.index <= stream.buf.len);
    return size, OK;
}

make_my_stream :: fn () MyStream #inline {
    stream: MyStream #noinit;
    stream.vtable = &MY_STREAM_VTABLE;
    stream.index = 0;
    return stream;
}

main :: fn () s32 {
    using std;
    stream :: make_my_stream();

    // Write some data into the stream.
    write(&stream, "Hello");
    write(&stream, "world!");

    str := str_new();
    defer str_delete(&str);

    // Read everything.
    read(&stream, &str);
    print(str);

    return 0;
}
*/
