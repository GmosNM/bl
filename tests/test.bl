/*

- Mixture of compile time and regular arguments.
- Acts like a polymorph (generate new function for each value).
- Skip LLVM for comptime values.
- Does not evaluate automatically while compilation unless the whole function is marked as #comptime.
- Call side checking for constantness.
- Insert 'value' into scope when it's replaced to allow access to the symbol i.e. in return type.
- Comptime arguments needs to be registered into scope while they are processed in the type analyze pass
  to allow i.e. modification of a function return type.

!!! Checking of provided comptime-call arguments must be done before the mixed function is generated. !!!

bar :: macro (v: s32) s32 {
    return v + 1;
}

Mutation propagation:
a :: 10; // error, immutable

Foo :: struct {
    a: s32;
}

foo :: Foo.{};
foo.a = 10; // error immutable

foo_ptr :: 

*/

foo :: fn (a: bool, FOO: s32 #comptime, b: s32) {
    a = false;
    b = 10;
    print("FOO = %\n", FOO);
}

bar :: fn (T: type) type #comptime {
    return struct { a: T };
}

new :: fn (T: type #comptime) *u8 {
    print("T = %\n", T);
    return null;
}

Data :: struct {
    a: s32;
    e: [8]u64;
}

main :: fn () s32 {
    foo(10, 20, 30);
    bar(s32);
    new(s32);
    new(bool);
    return 0;
}
