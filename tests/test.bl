// Analyze state can be removed (only bool is enough)?
// 
// ADD FATAL analyze state to handle invalid polymorph generation!
// ADD FATAL analyze state to handle invalid polymorph generation!
// ADD FATAL analyze state to handle invalid polymorph generation!
//
// Remove INSTR_ARG

Data :: struct {
    a: s32;
    b: s32;
    c: s64;
}

main :: fn () s32 {
    foo();

    ptr := &foo;
    ptr();

    group();
    bar(20);
    bar(20, 40);

    poly(10, 20);
    //poly("hello", "world"); // @Incomplete: internal error
    poly(true, false); 

    poly_default(10);
    poly_default(10, 20);
 
    this_is_called_in_comptime(10, true);

    num : *s32 = new(s32) #maybe_unused;

    mixed_poly(10);
    mixed_poly(true);

    variable_args(666, 777);
    variable_args_2(666);
    variable_args_2(666, 10);
    variable_args_2(666, 10, 20);

    /*
    arr: [10]s32;
    mixed(10, &arr);

    arr2: [2]s32;
    mixed(2, &arr2);

    data :: Data.{};
    mixed_poly_2(data);
    */

    return 0;
}

foo :: fn () {
}

group :: fn {
    fn () {
        print("group()\n");
    };
    fn (i: s32) {
        print("group(%)\n", i);
    };
}

bar :: fn (j: s32, k: s32 = 666) s32 {
    print("bar(%, %)\n", j, k);
    return j + k;
}

poly :: fn (v: ?T, c: T) {
    print("poly(%, %)\n", v, c);
}

poly_default :: fn (v: ?T, c: T = 20) {
    print("poly_default(%, %)\n", v, c);
}

this_is_called_in_comptime :: fn (a: s32, b: bool) #comptime {
    // @Incomplete: internal error.
    //print("this_is_called_in_comptime(%, %)\n", a, b);
}

mixed_poly :: fn (v: ?T #comptime) {
    print("mixed_poly(%)\n", v);
}

variable_args :: fn (v: ...s32) {}

variable_args_2 :: fn (n: s32, v: ...s32) {}

/*
mixed :: fn (v: s32 #comptime, arr: *[v]s32) {
}

mixed_poly_2 :: fn (v: Data #comptime, arr: [v.a]s32) {
    v;
}
*/

new :: fn (T: type #comptime) *T {
    mem, err :: alloc(sizeof(T));
    if err { panic(err); }
    return auto mem; 
}

/*
// TODO: Currently we cannot have default value for polymorph master!
poly_default_2 :: fn (v: ?T = 10) {
    v;
    c;
}
*/

/* uncommnet while fixing using propagation into local functions.
list_dir :: fn (paths: *[..]string_view, dir: string_view) {
    using std;
    foo :: fn (i: *Info) {};
}
*/
