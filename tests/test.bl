/*

- Mixture of compile time and regular arguments.
- Acts like a polymorph (generate new function for each value).
- Skip LLVM for comptime values.
- Does not evaluate automatically while compilation unless the whole function is marked as #comptime.
- Call side checking for constantness.
- Insert 'value' into scope when it's replaced to allow access to the symbol i.e. in return type.
- Comptime arguments needs to be registered into scope while they are processed in the type analyze pass
  to allow i.e. modification of a function return type.

!!! Checking of provided comptime-call arguments must be done before the mixed function is generated. !!!

bar :: macro (v: s32) s32 {
    return v + 1;
}



Redesign comptime functions:
    
    - Any #comptime function is evaluated in compile time.
    - If any function is called with #run prefix, it's also evaluated in compile time.
    - All arguments must be known in compile-time on the call side.
    - Internally only arguments foo: s32 #comptime are comptime constants in the function body and may
      cause the function generation.


// comptime functions as:
foo :: fn (T: type #comptime) type #run {
    return T;
}

*/

//#import "std/fs"
//#import "std/table"

foo :: fn () #comptime {
    using std;
    file, err :: open_file(#file);
    defer close_file(&file);
    if err { 
        print("%\n", err); 
        return;
    }
    content := str_new();
    defer str_delete(&content);

    read_string(&file, &content);
    print("%\n\n", content);
}

my_size :: fn (T: type #comptime) usize #comptime {
    return sizeof(T);
}

main :: fn () s32 {
    using std;

    //foo();
    my_size(s32);
    return 0;
}

#private

Foo :: struct #maybe_unused {
    i: s32;
}
