
/// This is cool!
Foo :: struct {
	a: s32; /// Hello
	b: s32; /// World
}


main :: fn() s32 {
	return 0;
}

/// Nice!
foo :: fn (a := false, ptr : *u32 = null, str := "Hello", loc := #call_location) {}

/*

TODO:

- #comptime - automatically comptime evaluated in case all the arguments are compile-time known.
What about functions returning types?
- Invalid - operator precedence!
- Add blc --init="My Project" command.
- Nested functions ignore previous using statement in some cases.
- Consider application context vs thread context (i.e. temporary allocator is by default thread
local but application_context is not).
- Consider #import and #load to be limited only to the file scope.
- Allow creation of scoped constants in structure bodies:

    foo :: struct {
        THIS_IS_CONSTANT :: 10;

        number: s32;
    }

- Macros

    bar :: macro (v: s32) s32 {
        return v + 1;
    }

- Introduce calling conventions.
- Change syntax of default argument value assignment to ':'.
- Properly handle fail of ast_expr_lit_fn while generating recipe implementation.

- loop - else ?

    loop i := 0; i < arr.len; i += 1 {
        ...
    } else {}

ENUM FLAGS:
- Allow direct | (or) composition of flags.
- Builtin support for checking if the flag is set?
- Replace all functionality of flags-related helper functions.

STATIC IF:

- Static if in other scopes.
- Fix static ifs.
- No scopes introduced by static ifs? But what about {}? Maybe C style is better?
- Struct declaration?
- Global scope?



COMPILE TIME EXECUTION:

- Use #run to mark function to be executed in compile time on the call side: '#run foo()'.
- Use #run to mark function executed only in compile time on the declaration side: 'foo :: fn ()
#run {}'.


POLYMORPH:

- Polymorp types cannot be easily identified; i.e. 'table_insert' should be something like this
'table_insert :: fn (tbl: *Table)' where 'Table' can be any polymorph type. However this is a bit
problematic due to the way how polymorph types are generated by compile-time funcitons...



NEW FEATURES

- Anonymous structs/unions?
- Disable function calls based on condition:

    trace_runtime :: fn () #enable_if IS_DEBUG == true {
        ...
    }

- Module versions:

    dir: module@2.9.16
    dir: module@3.2.0

    #import "module"       // the latest one
    #import "module@2      // newest version 2.x.x
    #import "module@2.9    // newest version 2.9.x
    #import "module@3.2.0  // exact version
    #import "module@2+     // any >= 2.0.0
    #import "module@2.1+   // any 2.1.0, 2.1.1, 2.2.0 ...
    #import "module@2.9.0+ // any 2.9.0, 2.9.1, 2.9.2 ...


// To memory.bl???
bytes_to_value :: fn (TValue: type #comptime, bytes: []u8) TValue {
    tmp: TValue;
    assert(bytes.ptr);
    memcpy(auto &tmp, bytes.ptr, std.min(sizeof(TValue), auto bytes.len));
    return tmp;
}

BIG STUFF:

- Implement custom multithreaded linker for windows, lld is slow same as link.exe.

*/
