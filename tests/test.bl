/* playground */
// INCOMPLETE: enable "hello".ptr
// INCOMPLETE: local type declarations

A :: 20;
B :: 10 + 20 * A;
C :: 123;
D :: &C;
E :: A;
F :: ^D;
G :: cast(u64) ^D;
H :: ^cast(*u64) D;
I :: 0.5f;
J :: 0.5 + 0.012;
K : bool : true;
L :: cast(s32) -12.5;

arr1     :: {:[8]s32: 1, 2, 3, 4, 5, 6, 7, 8};
arr2     :: {:[8]s32: 0};
arr_ptrs :: {:[2]*[8]s32: &arr1, &arr2};

Data1 :: struct {
    a: s32;
    b: s32;
    c: bool;
}

gdata :: {:Data1: 10, 20, false};
arr3 :: {:[2]Data1:
         {:Data1: 10, 20, false}, 
         {:Data1: 30, 40, true},
};

str :: "Hello";
str2 := "Hello";
str3 := &str;

format :: " %d\n";
foo_ptr :: &foo;

Days :: enum s8 {
    SUN :: -1;
    MON;
    THU :: 10;
    WEN;
    THR;
    FRI;
    SAT;
}

my_func1 :: fn () {
    str :: "hello from my_func1!!!\n";
    printf(str.ptr, 0);
}

my_func2 :: fn () {
    str :: "hello from my_func2!!!\n";
    printf(str.ptr, 0);
}

Functions :: struct {
    first: *fn();
    second: *fn();
}

functions :: {:Functions: &my_func1, &my_func2};

main :: fn () s32 {
    MyType :: struct { i: s32 };
    my_value : MyType;
    
    printf(format.ptr, cast(s32) Days.SUN);
    printf(format.ptr, cast(s32) Days.MON);
    printf(format.ptr, cast(s32) Days.THU);
    day := Days.MON;

    switch day {
        Days.SUN {
            str :: "It's sunday!!!\n";
            printf(str.ptr, 0);
        }

        Days.MON {
            str :: "It's monday!!!\n";
            printf(str.ptr, 0);
        }

        Days.SAT {
            str :: "It's saturday!!!\n";
            printf(str.ptr, 0);
        }

        default;
    }
    
    loop i := 0; i < arr3.len; i += 1 {
        result := arr3[i].a + arr3[i].b;
        printf(format.ptr, result);
    }

    data : Data1;
    data.a = 10;
    data.b = 10;

    i :: gdata.a;

    str4 := "Hello";
    str5 :: "Hello";
    p :: str5.ptr;

    foo_ptr_ptr :: &foo_ptr;
    printf(format.ptr, (^foo_ptr_ptr)(10, 20));

    functions.first();
    functions.second();

    some_slice : []s32 = {:[]s32: 0, null};
    some_slice.ptr = null;
    some_slice.len = 10;

    c_num     :: {:s32: 10};
    c_real    :: {:f32: 0.5f};
    c_boolean :: {:bool: true};
    c_ptr     :: {:*s32: &c_num};
    c_day     :: {:Days: Days.MON};
    c_num2    :: {:s32: c_num};
    printf(format.ptr, c_num);

    i2 := 10;
    data2 :: {:Data1: i2, 20, true};
    printf(format.ptr, data2.a);
    printf(format.ptr, data2.b);

    data3 := {:Data1: 0};
    printf(format.ptr, data3.a);
    printf(format.ptr, data3.b);

    bar(data2);
    bar({:Data1: 30, 40, false});
    bar({:Data1: i2, 40, false});

    vargs(i2, 20, 30);

    sizeof(struct { a: s32; b : s32});
    alignof(struct { a: s32; b : s32});

    c := str4[0];

    { // s32
        t :: "type info s32:\n";
        printf(t.ptr, 0);
        info :: cast(*TypeInfoInt) typeinfo(s32);

        printf(format.ptr, cast(s32) info.kind);
        printf(format.ptr, cast(s32) info.size_bytes);
        printf(format.ptr, cast(s32) info.bit_count);
        print_bool(info.is_signed);
    }

    { // u32
        t :: "type info u32:\n";
        printf(t.ptr, 0);
        info :: cast(*TypeInfoInt) typeinfo(u32);

        printf(format.ptr, cast(s32) info.kind);
        printf(format.ptr, cast(s32) info.size_bytes);
        printf(format.ptr, cast(s32) info.bit_count);
        print_bool(info.is_signed);
    }

    { // enum
        info :: cast(*TypeInfoEnum) typeinfo(Days);

        printf(format.ptr, cast(s32) info.kind);
        printf(info.name.ptr, 0);
        printf(format.ptr, cast(s32) info.base_type.kind);

        loop i := 0; i < info.variants.len; i += 1 {
            printf(info.variants[i].name.ptr, 0);
            printf(format.ptr, auto info.variants[i].value);
        }
    }

    { // bool
        info :: typeinfo(bool);
        printf(format.ptr, cast(s32) info.kind);
    }

    { // real
        info :: typeinfo(f32);
        printf(format.ptr, cast(s32) info.kind);
    }

    { // ptr
        info :: cast(*TypeInfoPtr) typeinfo(*u32);
        printf(format.ptr, cast(s32) info.kind);
        printf(format.ptr, cast(s32) info.pointee_type.kind);
    }

    { // null
        info :: typeinfo(null);
        printf(format.ptr, cast(s32) info.kind);
    }

    { // string
        info :: typeinfo("hello");
        printf(format.ptr, cast(s32) info.kind);
    }

    { // arr
        info :: cast(*TypeInfoArray) typeinfo([10]s32);
        printf(format.ptr, cast(s32) info.kind);
        printf(info.name.ptr, 0);
        printf(format.ptr, cast(s32) info.elem_type.kind);
        printf(format.ptr, cast(s32) info.len);
    }

    { // struct
        info :: cast(*TypeInfoStruct) typeinfo(Data1);
        printf(format.ptr, cast(s32) info.kind);
        printf(info.name.ptr, 0);

        loop i := 0; i < info.members.len; i += 1 {
            printf(info.members[i].name.ptr, 0);
        }
    }

    { // fn
        info :: cast(*TypeInfoFn) typeinfo(foo);
        printf(format.ptr, cast(s32) info.kind);
        printf(info.name.ptr, 0);

        loop i := 0; i < info.args.len; i += 1 {
            printf(info.args[i].name.ptr, 0);
        }
    }

    { // fn
        info :: cast(*TypeInfoFn) typeinfo(main);
        printf(format.ptr, cast(s32) info.kind);
        printf(info.name.ptr, 0);

        loop i := 0; i < info.args.len; i += 1 {
            printf(info.args[i].name.ptr, 0);
        }
    }

    return foo(10, 20);
}

foo :: fn (i: s32, j: s32) s32 {
    return i * j;
}

bar :: fn (v: Data1) {
    printf(format.ptr, v.a);
    printf(format.ptr, v.b);
}

vargs :: fn (v: ...s32) {
    printf(format.ptr, auto v.len);
    loop i := 0; i < v.len; i += 1 {
        printf(format.ptr, v[i]);
    }
}

printf :: fn (format: *u8, n: s32) s32 #extern;

print_bool :: fn (b: bool) {
    if b {
        printf(format.ptr, 1);
    } else {
        printf(format.ptr, 0);
    }
}

#test "test case!" {
    functions.first();
    functions.second();
}