// Polymorph

// 0) Introduce AstTypePolymorph. Available only inside function types. Can be checked
//    in parser or during type analyze pass.
// 1) Detect if function type is_polymorph during parsing.
//    Register function as new symbol, but skip instruction generation when function type is_polymorph.
// 2) Introduce MirTypePolymorph primitive.
// 3) Function must be generated and analyzed after call arguments are ready.
// 4) Every polymorph variant must have unique hash based on input type combination,
//    to generate new one only in case it's not present yet.

// Introduce poly table for replacement of Ts, keep order as in parsed AST.
// Store first use call side to provide better errors.

// Duplicate entries when functions reuse same scopes, we must create layered scope?
// poly layer index?

// foo
// type:  *MirTypeFnPoly
// value: *MirFnPoly

add :: fn (a: ?T, b: T) T {
    this_is_it: T;
    return a + b;
}

/*
sum :: fn (values: []?T) T {
    result: T;
    loop i := 0; i < values.len; i += 1 {
        result += values[i];
    }
    return result;
}
*/

main :: fn () s32 {
    n1 : s64 = 10;
    n2 : u32 = 20;
    i :: add(n1, n1);
    b :: add(n2, n2);
    return 0;
}
