// #scope glwindow

main :: fn () s32 {
    using win32;
    window_class :: WNDCLASSA.{
        style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC,
        lpfnWndProc = &window_callback,
        hCursor = LoadCursorA(null, IDC_ARROW),
        lpszClassName = std.strtoc("GlWindowClass"),
    };
    if RegisterClassA(&window_class) == 0 {
        panic("Failed to register window.");
    }

    rect  :: RECT.{ 0, 0, 800, 600 };

    window := CreateWindowExA(
        WS_EX_CLIENTEDGE,
        window_class.lpszClassName,
        std.strtoc("OpenGL"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        rect.right-rect.left, rect.bottom-rect.top,
        null, null, null, null);
    if !window {
        panic("Failed to create window with error.");
    }

    ShowWindow(window, TRUE);
    UpdateWindow(window);

    is_running := true;
    loop is_running {
        msg: MSG;
        loop PeekMessageA(&msg, null, 0, 0, PM_REMOVE) != 0 {
            if (msg.message == WM_QUIT) {
                is_running = false;
                continue;
            }
            TranslateMessage(&msg);
            DispatchMessageA(&msg);
        }
    }
    return 0;
}

window_callback :: fn (window: win32.HWND, msg: win32.UINT, wparam: win32.WPARAM, lparam: win32.LPARAM) *s32 {
    using win32;
    switch msg {
        WM_DESTROY {
            PostQuitMessage(0);
        }
        default {
            return win32.DefWindowProcA(window, msg, wparam, lparam);
        }
    }
    return null; // null means handled
}
