#import "std/test"

main :: fn () s32 {
	o :: 1/0;

	n := std.nan(f32);
	print("n = %\n", n);
	print("is_nan(n) = %\n", std.is_nan(n));
	
	a := 1./0.;

	print("a = %\n", a);
	return 0;
}

my_test :: fn () #test {
	// This is crashing the compiler!!!
	// This is crashing the compiler!!!
	// This is crashing the compiler!!!
	assert(false);
}

/*

TODO:

- Invalid - operator precedence!
- Better error reporting! For referenced type structures, if one is missing, we get bunch of error even for obviously existing symbols.
  We may introduce some prioritization of errors or not't report existing incomplete types? 
- #comptime - automatically comptime evaluated in case all the arguments are compile-time known. What about functions returning types?
- Add blc --init="My Project" command.
- Nested functions ignore previous using statement in some cases.
- Consider application context vs thread context (i.e. temporary allocator is by default thread local but application_context is not).
- Consider #import and #load to be limited only to the file scope.
- Allow creation of scoped constants in structure bodies:
	foo :: struct {
		THIS_IS_CONSTANT :: 10;

		number: s32;
	}

- Macros
	bar :: macro (v: s32) s32 {
		return v + 1;
	}

- Introduce calling conventions.
- Change syntax of default argument value assignment to ':'.
- Properly handle fail of ast_expr_lit_fn while generating recipe implementation.
- is_one_or_more_flags(f) fails to run (empty varaibale argument count!).

- loop - else ?
	loop i := 0; i < arr.len; i += 1 {
		...
	} else {}

STATIC IF:

- Static if in other scopes.
- Fix static ifs.
- No scopes introduced by static ifs? But what about {}? Maybe C style is better?
- Struct declaration?
- Global scope?



COMPILE TIME EXECUTION:

- Use #run to mark function to be executed in compile time on the call side: '#run foo()'.
- Use #run to mark function executed only in compile time on the declaration side: 'foo :: fn () #run {}'.



POLYMORPH:

- Polymorp types cannot be easily identified; i.e. 'table_insert' should be something like this 'table_insert :: fn (tbl: *Table)' where 'Table' can be any polymorph type. However this is a bit problematic due to the way how polymorph types are generated by compile-time funcitons...


// To memory.bl???
bytes_to_value :: fn (TValue: type #comptime, bytes: []u8) TValue {
	tmp: TValue;
	assert(bytes.ptr);
	memcpy(auto &tmp, bytes.ptr, std.min(sizeof(TValue), auto bytes.len));
	return tmp;
}


*/
