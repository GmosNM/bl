// Polymorph

// 0) Introduce AstTypePolymorph. Available only inside function types. Can be checked
//    in parser or during type analyze pass.
// 1) Detect if function type is_polymorph during parsing.
//    Register function as new symbol, but skip instruction generation when function type is_polymorph.
// 2) Introduce MirTypePolymorph primitive.
// 3) Function must be generated and analyzed after call arguments are ready.
// 4) Every polymorph variant must have unique hash based on input type combination,
//    to generate new one only in case it's not present yet.

// Introduce poly table for replacement of Ts, keep order as in parsed AST.
// Store first use call side to provide better errors.

// Duplicate entries when functions reuse same scopes, we must create layered scope?
// poly layer index?

// foo
// type:  *MirTypeFnPoly
// value: *MirFnPoly

add :: fn (a: ?T, b: T) T {
    this_is_it: T;
    return a + b;
}

main :: fn () s32 {
    i :: add(cast(s64) 10, cast(s64) 10);
    return 0;
}

bar :: fn () {
    k :: add(cast(u8) 10, cast(u8) 10);
}

sailor :: fn () {
    k :: add(cast(u64) 10, cast(u64) 10);
}

/*

MirFnPoly:
    - ast node for the function literal prototype
    - array of already generated prototypes (or hash table?)
    - hashing done by types
    - first use call position

    generate_fn_poly (recepie: MirFnPoly, expected_argument_list)
*/


