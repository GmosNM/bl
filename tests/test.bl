/*

TODO:

- Remove INSTR_ARG
- Handle failing of ast generation of generated functions properly.
- Analyze of comptime arguments must be done when they are used.
- Change syntax of default argument value assignment to ':'.
- Update documentation.

*/

Data :: struct {
    a: s32;
    b: s32;
    c: s64;
}

main :: fn () s32 {
    n : s64 = 10;
    foo(&n);

    ptr := &foo;
    ptr(&n);

    group();
    bar(20);
    bar(20, 40);

    poly(10, 20);
    //poly("hello", "world"); // @Incomplete: internal error
    poly(true, false); 

    poly_default(10);
    poly_default(10, 20);
 
    this_is_called_in_comptime(10, true);

    //num : *s32 = new(s32) #maybe_unused;
    //(@num) = 800;
    //call_with_pointer(num);
    //to_any(num);

    mixed_poly(10);
    mixed_poly(true);

    variable_args(666, 777);
    variable_args_2(666);
    variable_args_2(666, 10);
    variable_args_2(666, 10, 20);

    tbl: MyTable(s32, bool);
    print("tbl = %\n", tbl);

    //with_call_loc(10);
    /*
    arr: [10]s32;
    mixed(10, &arr);

    arr2: [2]s32;
    mixed(2, &arr2);

    data :: Data.{};
    mixed_poly_2(data);
    */

    return 0;
}

MyTable :: fn (TKey: type #comptime, TValue: type #comptime) type #comptime {
    //print(">>> Generation table type!\n");
    return struct {
        key: TKey;
        value: TValue;
    };
}

my_static_assert :: fn (expr: bool) #comptime {
    if expr { return; }
    unreachable;
}

foo :: fn (p: *s64) {
    tmp := cast(*u64) p;
    (@tmp) = 0;
}

group :: fn {
    fn () {
        print("group()\n");
    };
    fn (i: s32) {
        print("group(%)\n", i);
    };
}

bar :: fn (j: s32, k: s32 = 666) s32 {
    print("bar(%, %)\n", j, k);
    return j + k;
}

poly :: fn (v: ?T, c: T) {
    print("poly(%, %)\n", v, c);
}

poly_default :: fn (v: ?T, c: T = 20) {
    print("poly_default(%, %)\n", v, c);
}

this_is_called_in_comptime :: fn (a: s32, b: bool) #comptime {
    // @Incomplete: assert!!!
    //print(">>> this_is_called_in_comptime(%, %)\n", a, b); 
}

mixed_poly :: fn (v: ?T #comptime) {
    print("mixed_poly(%)\n", v);
}

variable_args :: fn (v: ...s32) {}

variable_args_2 :: fn (n: s32, v: ...s32) {}

to_any :: fn (c: Any) {
    print("to_any(%)\n", c);
}

call_with_pointer :: fn (n_ptr: *s32) {
    print("call_with_pointer(%, %)\n", n_ptr, @n_ptr);
}

with_call_loc :: fn (n: s32, loc := #call_location) {
    print("with_call_loc(%, %)\n", n, loc);
}

/*
mixed :: fn (v: s32 #comptime, arr: *[v]s32) {
}

mixed_poly_2 :: fn (v: Data #comptime, arr: [v.a]s32) {
    v;
}

// @Incomplete: Documentation.
// @Incomplete: Tests.
new :: fn (T: type #comptime, preferred_allocator: *Allocator = null, loc := #call_location) (ptr: *T, err: Error) #inline {
    mem, err :: alloc(sizeof(T), alignof(T), preferred_allocator, loc);
    return auto mem, err; 
}
*/


/*
// TODO: Currently we cannot have default value for polymorph master!
poly_default_2 :: fn (v: ?T = 10) {
    v;
    c;
}
*/

/* uncommnet while fixing using propagation into local functions.
list_dir :: fn (paths: *[..]string_view, dir: string_view) {
    using std;
    foo :: fn (i: *Info) {};
}
*/
