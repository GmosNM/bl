/*

- Mixture of compile time and regular arguments.
- Acts like a polymorph (generate new function for each value).
- Skip LLVM for comptime values.
- Does not evaluate automatically while compilation unless the whole function is marked as #comptime.
- Call side checking for constantness.
- Insert 'value' into scope when it's replaced to allow access to the symbol i.e. in return type.
- Comptime arguments needs to be registered into scope while they are processed in the type analyze pass
  to allow i.e. modification of a function return type.

!!! Checking of provided comptime-call arguments must be done before the mixed function is generated. !!!

bar :: macro (v: s32) s32 {
    return v + 1;
}

Generate function implementation if:
    - The function type is polymorph.
    - Has #comptime arguments.
    - Is called in compile time.

- Replacement must be done in a single function to support mixed stuff as comptime polymorphic arguments???
*/

// Function evaluated in compile time without arguments.
// - arguments must be compile-time known but are mutable inside the function.
// - called after all arguments are analyzed on call-size
// - needs provided arguments before it's called
// - call can be postponed -> arguments needs to be persistant!

// Polymorph -> must be generated.
//foo_2 :: fn (a: ?T) { // type is polymorph
//}

// Generated only in case the fuction argument list contains types???
//foo_5 :: fn (T: type) #comptime { 
//}


foo :: fn (a: s32) #comptime {
    a;
}

main :: fn () s32 {
    foo();
    return 0;
}
