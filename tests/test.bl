/* playground */

main :: fn () s32 {
    arr: [..]s32;
    defer array_terminate(auto &arr);
    
    loop i := 0; i < 10; i += 1 {
        array_push(auto &arr, i);
    }

    print("array is %\n", arr);
    
    loop i := 0; i < arr.len; i += 1 {
        print("index % = %\n", i, arr[i]);
    }

    return 0;
}

/* array impl */
_Array :: struct #compiler {
    len: s64;
    ptr: *u8;
    allocated: usize;
}

array_terminate :: fn (arr: *_Array) #inline {
    mem_free(arr.ptr);
}

array_push :: fn (arr: *_Array, v: Any) {
    if v.data == null { panic("Invalid value (null)."); }

    elem_size :: v.type_info.size_bytes;

    arr.len += 1;
    ensure_space(arr, elem_size, auto arr.len, false);

    dest :: elem_ptr(arr, elem_size, arr.len - 1);
    mem_copy(dest, v.data, elem_size);
};

#private
ALLOC_BLOCK_SIZE : usize : 32;

elem_ptr :: fn (arr: *_Array, elem_size: usize, i: s64) *u8 #inline {
    if i >= arr.len {
        panic("Element index out of range, index is % but array size is %.", i, arr.len);
    }

    return ptr_shift_bytes(arr.ptr, i * cast(s64) elem_size);
};

ensure_space :: fn (arr: *_Array, elem_size: usize, space: usize, exact: bool) {
    if space == 0 { return; }
    if arr.allocated >= space { return; }

    if arr.allocated == 0 {
        if !exact { space = ALLOC_BLOCK_SIZE; }
    } else {
        space *= 2;
    }

    tmp := arr.ptr;

    arr.ptr = mem_alloc(space * elem_size); 
    if tmp != null {
        mem_copy(arr.ptr, tmp, arr.allocated * elem_size);
        mem_free(tmp);
    }
    
    arr.allocated = space;
};
