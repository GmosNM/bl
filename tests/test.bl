/*
Value :: struct (T: type) {
    key: s32;
    value: T;
}

table_insert :: fn (table: *Table(?T), value: T) {
    table.key = 0;
    table.value = value;
}

set_value :: fn (v: *?T, key: ?TKey, value: ?TValue) {
    v.key = key;
    v.value = value;
}

Entry :: struct {
    key: s32;
    value: string;
}

TableValue :: fn () type #comptime {
    return s32;
}
*/

get :: fn () type #comptime {
    return s32;
}

main :: fn () s32 {
    //i :: get();
    //print("i = %\n", i);
    return 0;
}

// =================================================================================================
// TODO
// =================================================================================================

// - [L] first_char :: fn (str: string #readonly) u8 {}
// - [L] #using Enum + use UPPERCASE for variants.
// - [L] allow static #if in global scope
// - [L] modules should use regular load scripts written in BL executed during import
// - [L] lazy load/import of sources (during analyze pass)
// - [L] BLC_VER :: #comptime get_version_string();
// - [M] test external calls returning something bigger than 64 bit integers!
// - [L] Implement lambda capture.
// - [L] @source/@src/@example tag parsing in documentation to automatically include files. 
// - [L] comptime function sould not return pointers 

// =================================================================================================
// Release: 1.0.0
// =================================================================================================
// - [H] limited support for #comptime calls.
// - [H] types should be also evaluated.
// - [H] polymorph struct types
// - [H] implement hash table using polymorph types.
// - [L] revalidate Fs module interface.
// - [L] improve auto documentation to report default values of functions correctly
// - [L] #switch ?

// =================================================================================================
// Module loader
// =================================================================================================

// 1) Create build assembly everytime even if build system is not used?
// 2) Create assembly only for imports?
//
// Every module importer should have uniquie name?

/*
module :: fn (bin: *Assembly) #module_entry {
    #if PLATFORM == Platform.windows {
        add_unit(bin, "_windows_impl.bl"
    } else {
        #error "Module does not support current target platform"
    }
}
*/


// =================================================================================================
// Polymorph structures
// =================================================================================================

// 1) Foo :: struct {} -> generated compile time call to type resolver function in AST
//    in this case Foo is constant compile-time known variable declaration set to result
//    of compile time call (call to the type resolver).
//
// 2) Foo :: struct (T: type) {} -> generate only type resolver function in AST, in this
//    Foo symbol is function declaration (callable only in compile-time).


// Use type as variable for type resolver function call?
// Lazy type generation?
// Dont generate type directly.
// Put T1 and T2 into struct scope.
// Store already generated types for reuse.
// Generate type resolvers directly in ast as implicit function calls???
// Argument list is optional.

/*
Foo :: struct (T1: type, T2: type, Size: s32 = 10) {
    i: T1;
    data: [Size]T2;
}
*/


// =================================================================================================
// Comptime marked functions
// =================================================================================================

// Function can be called only in compile time.
// All arguments must be compile time known.
// Call is replaced by constant.

/*
get_hash :: fn () #comptime {
}
*/

