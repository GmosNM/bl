// Polymorph
// Disable pointers to polymorph functions.

add :: fn (a: ?T, b: T) T {
    return a + b;
}

print_vec :: fn (v: ?T) {
    print("x = %\n", v.x);
    print("y = %\n", v.y);
    print("z = %\n", v.z);
}

maximum :: fn (a: ?T, b: T) T #inline {
    if a > b { return a; }
    return b;
}

table_insert :: fn (key: ?TKey, value: ?TValue) {
    print("[%] = %\n", key, value);
}

my_table_insert :: fn (key: ?TKey, value: ?TValue) {
    table_insert(key, value);
}

// Use in API
swap :: fn (a: *?T, b: *T) {
    tmp :: ^a;
    ^a = ^b;
    ^b = tmp;
}

// Use in API
sum :: fn (values: []?T) T {
    result: T;
    loop i := 0; i < values.len; i += 1 {
        result += values[i];
    }
    return result;
}

find :: fn (arr: []?T, value: T) s64 #inline {
    loop i := 0; i < arr.len; i += 1 {
        if arr[i] == value { return i; }
    }
    return -1;
}

foo :: fn (a: ?T, b : T = 10) {
    print("a = %\nb = %\n", a, b);
}

Vec :: struct {
    x: s32;
    y: s32;
    z: s32;
}

bar :: fn (a: ?T1, b: s32, c: T1) {
    a.x = c.x;
}

homo :: fn (f: *fn(a: ?T) T) {
    f(10);
}

alena :: fn (arg: T, f: *fn(a: ?T) T) T {
    return f(arg);
}

my_func :: fn () {
    local_poly :: fn (a: ?T) {
        print("local a = %\n", a);
    };
    
    local_poly("is here!!!");
}

group :: fn {
    fn (s: string) { print("string = %\n", s); };
    fn (s: ?T) { print("poly = %\n", s); };
};


main :: fn () s32 {
    n1 : s64 = 10;
    n2 : u32 = 20;
    n3 :: 0.5f;
    n4 :: 0.5;

    my_func();
    
    print("%\n", add(n1, n1));
    print("%\n", add(n2, n2));
    print("%\n", add(n3, n3));
    print("%\n", add(n4, n4));
    
    v := {:Vec: 10, 20, 30};
    print_vec(v);
    
    print("%\n", maximum(10, 20));
    print("%\n", maximum(34.4f, 20.f));
    
    table_insert(10, "hello!");
    table_insert(30, "foo!");
    table_insert(40, "bar!");
    table_insert(20, 10);
    my_table_insert(20, "My insert!");

    first := 10;
    second := 20;    
    print("Before % vs %\n", first, second);
    swap(&first, &second);
    print("After  % vs %\n", first, second);
    
    arr :: {:[10]s32: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    print("sum = %\n", sum(arr));
    
    dyn: [..]s32;
    defer array_terminate(dyn);
    loop i := 0; i < 100; i += 1 {
        array_push(dyn, i);
    }
    print("sum = %\n", sum(dyn));
    foo(20);
    
    slice: []s32;
    slice_init(slice, 10);
    defer slice_terminate(slice);
    loop i := 0; i < slice.len; i += 1 {
        slice[i] = i;
    }    
    print("sum = %\n", sum(slice));

    print("found index %\n", find(arr, 3));
    print("found index %\n", find(dyn, 3));
    print("found index %\n", find(slice, 3));

    homo(&fn (i: s32) s32 {
        print("Hello from callback, i = %\n", i);
        return i;
    });

    alena(666, &fn (a: s32) s32 {
        return a;
    });
    
    group("hello");
    group(10);

    return 0;
}

