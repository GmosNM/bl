/*
MyStream1 :: struct {
    read: s32;
}

MyStream2 :: struct {
    write: s32;
}

foo :: fn {
    fn (v: *?T) {
#if !symbol_exists(v.read) {
    #error "Stream is read only.";
}
        print("A\n");
    };
    fn (v: *?T, a: s32) { print("B\n"); };
};
*/

/*
my_static_assert :: fn (expr: bool, msg := "") #comptime {
    if expr { return; }
    #error msg;
    unreachable;
}

compiler_error(<comptime-expr>)
compiler_warning(<comptime-expr>)
symbol_exist(<comptime-expr)
debugbreak()
unreachable()

*/

main :: fn () s32 {
    print(">> %\n", sizeof(s32));
    return 0;
}


/*
#import "std/io"

MyStream :: struct #base std.Stream {
    // Internal buffer used to hold data.
    buf: [64]u8;
    // Current index in the buffer array.
    index: s64;
}

// Custom stream virtual table.
MY_STREAM_VTABLE :: std.StreamVTable.{
    read = auto &my_stream_read,
    write = auto &my_stream_write,
};

my_stream_read :: fn (stream: *MyStream, dest: *u8, bytes_to_read: s64) (s64, Error) {
    using std;
    size := min(stream.index, bytes_to_read);
    stream.index -= size;
    assert(stream.index >= 0);
    if size > 0 { memcpy(dest, &stream.buf[stream.index], auto size); }
    return size, OK;
}

my_stream_write :: fn (stream: *MyStream, src: *u8, bytes_to_write: s64) (s64, Error) {
    size :: std.min(stream.buf.len - stream.index, bytes_to_write);
    if size > 0 { memcpy(&stream.buf[stream.index], src, auto size); }
    stream.index += size;
    assert(stream.index <= stream.buf.len);
    return size, OK;
}

make_my_stream :: fn () MyStream #inline {
    stream: MyStream #noinit;
    stream.vtable = &MY_STREAM_VTABLE;
    stream.index = 0;
    return stream;
}

main :: fn () s32 {
    using std;
    stream :: make_my_stream();

    // Write some data into the stream.
    write(&stream, "Hello");
    write(&stream, "world!");

    str := str_new();
    defer str_delete(&str);

    // Read everything.
    read(&stream, &str);
    print(str);

    return 0;
}
*/
