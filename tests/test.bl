// Polymorph

// 0) Introduce AstTypePolymorph. Available only inside function types. Can be checked
//    in parser or during type analyze pass.
// 1) Detect if function type is_polymorph during parsing.
//    Register function as new symbol, but skip instruction generation when function type is_polymorph.
// 2) Introduce MirTypePolymorph primitive.
// 3) Function must be generated and analyzed after call arguments are ready.
// 4) Every polymorph variant must have unique hash based on input type combination,
//    to generate new one only in case it's not present yet.

// Introduce poly table for replacement of Ts, keep order as in parsed AST.
// Store first use call side to provide better errors.

// Duplicate entries when functions reuse same scopes, we must create layered scope?
// poly layer index?

// foo
// type:  *MirTypeFnPoly
// value: *MirFnPoly

add :: fn (a: ?T, b: T) T {
    return a + b;
}

print_vec :: fn (v: ?T) {
    print("x = %\n", v.x);
    print("y = %\n", v.y);
    print("z = %\n", v.z);
}

maximum :: fn (a: ?T, b: T) T #inline {
    if a > b { return a; }
    return b;
}

table_insert :: fn (key: ?TKey, value: ?TValue) {
    print("[%] = %\n", key, value);
}

Vec :: struct {
    x: s32;
    y: s32;
    z: s32;
}

main :: fn () s32 {
    n1 : s64 = 10;
    n2 : u32 = 20;
    n3 :: 0.5f;
    n4 :: 0.5;
    
    print("%\n", add(n1, n1));
    print("%\n", add(n2, n2));
    print("%\n", add(n3, n3));
    print("%\n", add(n4, n4));
    
    v := {:Vec: 10, 20, 30};
    print_vec(v);
    
    print("%\n", maximum(10, 20));
    print("%\n", maximum(34.4f, 20.f));
    
    table_insert(10, "hello!");
    table_insert(30, "foo!");
    table_insert(40, "bar!");
    return 0;
}

//sum :: fn (values: []?T) T {
//    result: T;
//    loop i := 0; i < values.len; i += 1 {
//        result += values[i];
//    }
//    return result;
//}
