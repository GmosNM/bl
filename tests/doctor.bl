#load "std/dir.bl"

main :: fn () s32 {
    print("--------------------------------------------------------------------------------\n");
    print("-                               Start BL doctor                                -\n");
    print("--------------------------------------------------------------------------------\n\n");
    
    // general
    print("Test general suite:\n");    
    test_file("src/main.test.bl", TestKind.Runtime);
    test_file("src/main.test.bl", TestKind.Test);
    
    // examples
    test_all_in_dir(EXAMPLES_DIR);
    
    // expect fail to compile
    print("Test expected to fail:\n");
    test_file("src/expect-fail/sizeof.test.bl", TestKind.Analyze, ERR_MISSING_SEMICOLON);
    return _errc;
}

#private
BL_EXE_PATH_WIN  :: "..\\bin\\blc.exe";
BL_EXE_PATH_UNIX :: "../bin/blc";

// paths
EXAMPLES_DIR :: "../examples";

TestKind :: enum {
    Runtime;
    CompileTime;
    Test;
    Analyze;
}

TEST_RUN_OK :: 0;

_errc := 0;

blc :: fn (file: string, args := "-no-bin -no-warning", print_errors := true) s32 {
    cmd :: string_new(64);
    defer string_delete(cmd);
    
    if OS_KIND == OSKind.Windows {
        mute := "2>&1 1>nul";
        if !print_errors { mute = "2>nul 1>nul"; }
        string_concatenate(&cmd, BL_EXE_PATH_WIN, " ", args, " ", file, " ", mute);   
    } else {
        mute := "2>&1 > /dev/null";
        if !print_errors { mute = "1>/dev/null 2>/dev/null"; }
        string_concatenate(&cmd, BL_EXE_PATH_UNIX, " ", args, " ", file, " ", mute);   
    }
    return os_execute(cmd);
}

report_ok :: fn (msg: string, file: string, state: s32) #inline {
    print("[   OK   ] % '%' (%)\n", msg, file, state);
}

report_failed :: fn (msg: string, file: string, state: s32) #inline {
    print("[ FAILED ] % '%' (%)\n", msg, file, state);
}

test_file :: fn (file: string, kind := TestKind.Runtime, expected_state := TEST_RUN_OK) {
    state: s32;
    print_errors := true;
    if expected_state != TEST_RUN_OK { print_errors = false; }
    switch kind {
        TestKind.Runtime {
            state = blc(file, "-no-warning");
            if state == expected_state {
                report_ok("Compilation", file, state);
            } else {
                report_failed("Compilation", file, state);
                _errc += 1;
                return;
            }

            tmp: string;
            if OS_KIND == OSKind.Windows { 
                tmp = "out.exe 2>&1 1>nul"; 
            } else {
                tmp = "./out 2>&1 > /dev/null"; 
            }
            state = os_execute(tmp);
            if state == 0 {
                report_ok("Execution", file, state);
            } else {
                report_failed("Execution", file, state);
                _errc += 1;
                return;
            } 
        }

        TestKind.CompileTime {
            state = blc(file, "-r -no-warning", print_errors);
            if state == expected_state {
                report_ok("Interpretation", file, state);
            } else {
                report_failed("Interpretation", file, state);
                _errc += 1;
                return;
            }
        }
        
        TestKind.Test {
            state = blc(file, "-rt -no-bin -no-warning", print_errors);
            if state == expected_state {
                report_ok("Run compile time tests", file, state);
            } else {
                report_failed("Run compile time tests", file, state);
                _errc += 1;
                return;
            }
        }

        TestKind.Analyze {
            state = blc(file, "-no-warning -no-bin", print_errors);
            if state == expected_state {
                report_ok("Analyze", file, state);
            } else {
                report_failed("Analyze", file, state);
                _errc += 1;
                return;
            }
        }
    }
}

test_all_in_dir :: fn (dir: string) {
    print("Testing files in directory '%':\n", dir);
    file :: string_new(64);
    defer string_delete(file);
    file_list: FileList #noinit;
    if !dir_scan(dir, &file_list) { print_err("Cannot scan directory!"); }
    defer dir_file_list_delete(file_list);

    loop i := 0; i < file_list.len; i += 1 {
        info :: &file_list[i];
        if info.kind != FileKind.Directory {
            string_concatenate(&file, dir, "/", info.name);
            test_file(file);
            string_clear(&file);
        }
    }
}


// ERROR CODES (This must be keept in sync with src/error.h)
NO_ERR :: 0;

ERR_FILE_NOT_FOUND          :: 1;
ERR_INVALID_SOURCE          :: 2;
ERR_INVALID_TOKEN           :: 3;
ERR_UNTERMINATED_COMMENT    :: 4;
ERR_UNTERMINATED_STRING     :: 5;
ERR_MISSING_SEMICOLON       :: 6;
ERR_MISSING_BRACKET         :: 7;
ERR_UNEXPECTED_DECL         :: 8;
ERR_EXPECTED_EXPR           :: 9;
ERR_MISSING_COMMA           :: 10;
ERR_EXPECTED_BODY           :: 11;
ERR_EXPECTED_BODY_END       :: 12;
ERR_EXPECTED_STMT           :: 13;
ERR_BREAK_OUTSIDE_LOOP      :: 14;
ERR_CONTINUE_OUTSIDE_LOOP   :: 15;
ERR_UNEXPECTED_DIRECTIVE    :: 16;
ERR_DUPLICATE_SYMBOL        :: 17;
ERR_UNKNOWN_SYMBOL          :: 18;
ERR_EXPECTED_TYPE           :: 19;
ERR_EXPECTED_NAME           :: 20;
ERR_EXPECTED_BINOP          :: 21;
ERR_DUPLICATE_ENTRY         :: 22;
ERR_NOT_VERIFIED            :: 23;
ERR_CANNOT_WRITE_BC         :: 24;
ERR_CANNOT_LINK             :: 25;
ERR_DIFF_KIND_OF_SYMBOL     :: 26;
ERR_INVALID_PARAM_COUNT     :: 27;
ERR_UNKNOWN_TYPE            :: 28;
ERR_PRIVATE                 :: 29;
ERR_UNCOMPATIBLE_MODIF      :: 30;
ERR_NO_MAIN_METHOD          :: 31;
ERR_INVALID_RESULT          :: 32;
ERR_INVALID_ARG_COUNT       :: 33;
ERR_INVALID_ARG_TYPE        :: 34;
ERR_INVALID_TYPE            :: 35;
ERR_INVALID_EXPR            :: 36;
ERR_JIT_RUN_FAILED          :: 37;
ERR_EXPECTED_STRING         :: 38;
ERR_EXPECTED_MODULE         :: 39;
ERR_EXPECTED_FUNC           :: 40;
ERR_MISSING_RETURN          :: 41;
ERR_EMPTY                   :: 42;
ERR_UNEXPECTED_SYMBOL       :: 43;
ERR_MULTIPLE_MAIN           :: 44;
ERR_EXPECTED_INITIALIZATION :: 45;
ERR_EXPECTED_TYPE_REF       :: 46;
ERR_EXPECTED_TYPE_STRUCT    :: 47;
ERR_INVALID_MUTABILITY      :: 48;
ERR_INVALID_NAME            :: 49;
ERR_INVALID_MEMBER_ACCESS   :: 50;
ERR_UNIMPLEMENTED           :: 51;
ERR_EXPECTED_CONST          :: 52;
ERR_EXPECTED_DECL           :: 53;
ERR_FILE_READ               :: 54;
ERR_FILE_EMPTY              :: 55;
ERR_INVALID_INITIALIZER     :: 56;
ERR_INVALID_CAST            :: 57;
ERR_INVALID_ADM             :: 58;
ERR_DIV_BY_ZERO             :: 59;
ERR_LIB_NOT_FOUND           :: 60;
ERR_LIB_SYMBOL_NOT_FOUND    :: 61;
ERR_EXPECTED_TEST_DESC      :: 62;
ERR_NULL_POINTER            :: 63;
ERR_INVALID_ARR_SIZE        :: 64;
ERR_BOUND_CHECK_FAILED      :: 65;
ERR_EMPTY_STRUCT            :: 66;
ERR_UNINITIALIZED           :: 67;
ERR_INVALID_ADDRES_MODE     :: 68;
ERR_EMPTY_ENUM              :: 69;
ERR_INVALID_DIRECTIVE       :: 70;
ERR_UNEXPECTED_EXPR         :: 71;
ERR_EXPECTED_COMPTIME       :: 72;
ERR_NUM_LIT_OVERFLOW        :: 73;
ERR_INVALID_SWITCH_CASE     :: 74;
ERR_DUPLICIT_SWITCH_CASE    :: 75;
ERR_INVALID_REFERENCE       :: 76;
ERR_UNEXPECTED_RETURN       :: 77;
ERR_AMBIGUOUS_OVERLOAD      :: 78;
