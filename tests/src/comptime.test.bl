#private

simple_fn :: fn () #test {
    get :: fn () s32 #comptime {
        return 10;
    };

    i :: get();
    test_eq(i, 10);
}

simple_fn_args :: fn () #test {
    get :: fn (a: s32, b: s32) s32 #comptime {
        return a + b;
    };

    i :: get(1, 2);
    test_eq(i, 3);
}

simple_type :: fn () #test {
    get :: fn () type #comptime {
        return s32;
    };

    i: get();
    test_eq(typeinfo(s32), typeinfo(i));
}

struct_type :: fn () #test {
    get :: fn () type #comptime {
        return struct { i: s32; j: bool; };
    };

    i: get();
    test_eq(typeinfo(i).kind, TypeKind.STRUCT);
}

multireturn :: fn () #test {
    get :: fn () (s32, s32) #comptime {
        return 10, 20;
    };

    i := get();
    test_eq(i, 10);
}

multireturn2 :: fn () #test {
    get :: fn () (s32, s32) #comptime {
        return 10, 20;
    };

    i, j := get();
    test_eq(i, 10);
    test_eq(j, 20);
}

Data :: struct {
    a: s32;
    b: s32;
    c: bool;
    d: u64;
    e: u64;
}

struct_value :: fn () #test {
    get :: fn () Data #comptime {
        return Data.{10, 20, true, 30, 40};
    };

    data := get();
    test_eq(data.a, 10);
    test_eq(data.b, 20);
    test_eq(data.c, true);
    test_eq(data.d, 30);
    test_eq(data.e, 40);
}

string_literal :: fn () #test{
    get :: fn () string_view #comptime {
        return "This is testing string.";
    };

    lit :: get();
    test_eq(lit, "This is testing string.");
}

mixed_args_1 :: fn () #test {
    foo :: fn (NUMBER: s32 #comptime) s32 {
        return NUMBER;
    };

    test_eq(foo(10), 10);
}

mixed_args_2 :: fn () #test {
    foo :: fn (a: s32, NUMBER: s32 #comptime) s32 {
        return NUMBER + a;
    };

    test_eq(foo(10, 20), 30);
}

mixed_args_3 :: fn () #test {
    foo :: fn (a: s32, NUMBER: s32 #comptime, b: s32) s32 {
        return NUMBER + a + b;
    };

    test_eq(foo(10, 20, 30), 60);
}

mixed_args_4 :: fn () #test {
    foo :: fn (STR: string_view #comptime) {
        test_eq(STR, "HELLO");
    };
    foo("HELLO");
}

mixed_args_5 :: fn () #test {
    foo :: fn (DATA: Data #comptime) {
        test_eq(DATA.a, 10);
    };
    data :: Data.{10, 20, true, 30, 40};
    foo(data);
}

ArrayData :: struct {
    i: s32;
    a: [10]s32;
    j: s32;
}

mixed_args_array_data :: fn () #test {
    foo :: fn (DATA: ArrayData #comptime) {
        test_eq(DATA.i, 10);
        test_eq(DATA.j, 20);
        loop i := 0; i < DATA.a.len; i += 1 {
            test_eq(DATA.a[i], i);
        }
    };
    data :: ArrayData.{
        i = 10,
        j = 20,
        a = [10]s32.{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    };
    foo(data);
}
