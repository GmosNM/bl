#load "std/debug.bl"

#test "fundametal types" {
  _u8:    u8; 
  _u16:   u16; 
  _u32:   u32; 
  _u64:   u64; 
  _usize: usize;
  _s8:    s8; 
  _s16:   s16; 
  _s32:   s32; 
  _s64:   s64; 
  _bool:  bool;
  _f32:   f32; 
  _f64:   f64; 
};

#test "type infer" {
  number := 0;
  boolean := true;
  float := 0.1f;
  double := 0.1;
};

#test "simple assignement" {
  {
    number := 0;
    assert(number == 0);
    number = 666;
    assert(number == 666);
    number = (1 + 2 * 3 - 1) / 2;
    assert(number == 3);
  }

  {
    real_number := 0.f;
    real_number = 10.1f;
    assert(real_number - 10.1f < 0.0001f);

    real_number = (0.1f + 10.f - 10.f) * 0.1f;
    assert(real_number - 0.01f < 0.0001f);
  }
};

#test "ifs" {
  b := true;
  if b {
    if !b {
      unreachable;
    }
  } else {
    unreachable;
  }

  if !b {
    unreachable;
  }
};

#test "function calls" {
  _1 :: fn () {
  };

  _2 :: fn (i: s32) s32 {
    return i;
  };

  _1();  
  assert(_2(10) == 10);
};

#test "implicit functions direct call" {
  i := fn (i: s32, j: s32) s32 {
    return i * j; 
  } (2, 3);

  assert(i == 6);

  fn () {
  } ();
};

#test "assign operators" {
  i := 5;
  assert(i == 5);

  i += 1;
  assert(i == 6);

  i -= 1;
  assert(i == 5);

  i *= 2;
  assert(i == 10);

  i /= 2;
  assert(i == 5);
};

#test "compare operators" {
  i := 10;
  assert(i == 10);
  assert(i != 9);
  assert(i > 0);
  assert(i < 11);
  assert(i >= 10);
  assert(i <= 10);
};

#test "simple loops" {
  count :: 10;
  i := 0;

  loop i < count {
    i += 1;
  }

  assert(i == count);

  i = 0;
  loop j := 0; j < count; j += 1 {
    i += 1;
  }

  assert(i == count);
};

#test "nested loops" {
  count :: 10;
  i := 0;

  loop x := 0; x < count; x += 1 {
    loop y := 0; y < count; y += 1 {
      i += 1;
    }
  }

  assert(i == count * count); 
};

#test "break/continue loop" {
  i := 0;
  loop {
    if i == 10 {
      break;
    } else {
      i += 1;
      continue;
    }
  }

  assert(i == 10);
};

#test "literal implicit casting" {
  _u8:    u8    = 10; 
  _u16:   u16   = 10; 
  _u32:   u32   = 10; 
  _u64:   u64   = 10; 
  _usize: usize = 10;
  _s8:    s8    = 10; 
  _s16:   s16   = 10; 
  _s32:   s32   = 10; 
  _s64:   s64   = 10; 

  _s64 = 10 * 2; 

  fn (i: u8) {
  } (10);

  if _u8 == 10 {
  }
};

#test "pointer casting" {
  i_ptr : *s32;
  j_ptr : *s8;

  i_ptr = cast(*s32) j_ptr;

  num := cast(u64) i_ptr;
  i_ptr = cast(*s32) num;
};

#test "real casting" {
  float : f32 = 12.5f;
  j := cast(s64) float;
  assert(j == 12);

  double : f64 = 12.5;
  j = cast(s64) double;
  assert(j == 12);
};

#test "pointers" {
  i       := 666;
  ptr     := &i;
  ptr_ptr := &ptr;

  j := ^^ptr_ptr;
  assert(j == 666);

  j = ^ptr;
  assert(j == 666);
};


#test "null pointers" {
  test_ptr :: fn (ptr: *s32) *s32 {
    return null;
  };

  foo : *s32 = null;
  assert(foo == null);
  assert(null == null);
  assert(test_ptr(null) == null);
};

#test "passed pointer" {
  value :: 10;
  i := 0;
  
  fn (ptr: *s32, v: s32) {
    ^ptr = v; 
  } (&i, value);

  assert(i == value);
};

#test "simple static array" {
  arr : [10]s32;

  arr[0] = 10;
  arr[1] = 20;
  arr[2] = 30;

  assert(arr.ptr == &arr[0]);
  assert(arr.len == 10);

  assert(arr[0] == 10);
  assert(arr[1] == 20);
  assert(arr[2] == 30);
};

#test "array initialization" {
  {
    arr := {:[2]s32: 0 };
    assert(arr[0] == 0);
    assert(arr[1] == 0);
  }

  {
    arr : [2]s32 = {:[2]s32: 10, 20 };
    assert(arr[0] == 10);
    assert(arr[1] == 20);
  }

  {
    arr := {:[2]s32: 10, 20 };
    assert(arr[0] == 10);
    assert(arr[1] == 20);
  }

  {
    i := 10;
    j := 20;

    arr := {:[2]s32: i, j };
    assert(arr[0] == 10);
    assert(arr[1] == 20);
  }
};

#test "simple static array loops" {
  arr : [10]s32;
  loop i := 0; i < arr.len; i += 1 {
    arr[i] = i;
    assert(arr[i] == i);
  }

  assert(arr[0] == 0);
  assert(arr[9] == 9);
};

#test "slices" {
  arr : [3]s32;

  arr[0] = 10;
  arr[1] = 20;
  arr[2] = 30;

  slice : []s32;
  slice.ptr = arr.ptr;
  slice.len = arr.len;

  assert(slice.ptr == &arr[0]);
  assert(slice.len == 3);
  assert(slice[0] == 10);
  assert(slice[1] == 20);
  assert(slice[2] == 30);
};

#test "structures" {
  Foo :: struct {
    _1: u8,
    _2: s32,
    _3: *s32,
    _4: [10] s32
  };

  int :: 10;

  foo : Foo;
  foo._1 = 10;
  foo._2 = 666;
  foo._3 = &int;
  (foo._4)[0] = 10;

  assert(foo._1 == 10);
  assert(foo._2 == 666);
  assert(foo._3 != null);
  assert((foo._4)[0] == 10);
};

#test "implicit struct" {
  foo : struct {
    _1: u8,
    _2: s32,
    _3: *s32,
    _4: [10] s32
  };

  int :: 10;

  foo._1 = 10;
  foo._2 = 666;
  foo._3 = &int;
  (foo._4)[0] = 10;

  assert(foo._1 == 10);
  assert(foo._2 == 666);
  assert(foo._3 != null);
  assert((foo._4)[0] == 10);
};

#test "nested struct" {
  Foo :: struct {
    i: s32,
    j: s32
  };

  Bar :: struct {
    foo: Foo
  };

  bar : Bar;
  (bar.foo).i = 10;
  (bar.foo).j = 20;

  assert((bar.foo).i == 10);
  assert((bar.foo).j == 20);
};

#test "structure initialization" {
  Foo :: struct {
    i: s32,
    j: s32
  };

  {
    foo := {:Foo: 0 };
    assert(foo.i == 0); 
    assert(foo.j == 0); 
  }

  {
    i := 10;
    j := 20;
    foo := {:Foo: i, j };
    assert(foo.i == i); 
    assert(foo.j == j); 
  }
};

_GlobalInt1     := 10;
_GlobalInt2     := 10 + 10; // 20
_GlobalConstInt :: 10;
_GlobalType     :: s32;

#test "globals" {
  assert(_GlobalInt1 == 10);
  assert(_GlobalInt2 == 20);
  assert(_GlobalConstInt == 10);

  foo : _GlobalType = 10;
  assert(foo == 10);
};

#test "strings" {
  _1 := "hello";
  assert(_1.ptr != null);
  assert(_1.len == 5);
};

#test "sizeof" {
  assert(sizeof(u8) == 1);
  assert(sizeof(u16) == 2);
  assert(sizeof(u32) == 4);
  assert(sizeof(u64) == 8);
  assert(sizeof(usize) == 8);
  assert(sizeof(s8) == 1);
  assert(sizeof(s16) == 2);
  assert(sizeof(s32) == 4);
  assert(sizeof(s64) == 8);
  assert(sizeof(1 + 2) == 4);
};

#test "vargs functions" {
  _0 :: fn (args: ...s32) {
    assert(args.len == 0);
  };

  _2 :: fn (args: ...s32) {
    assert(args.len == 2);
    assert(args[0] == 10);
    assert(args[1] == 20);
  };

  _10 :: fn (i: s32, args: ...s32) {
    assert(args.len == 0);
    assert(i == 10);
  };

  _12 :: fn (i: s32, args: ...s32) {
    assert(args.len == 2);
    assert(args[0] == 10);
    assert(args[1] == 20);
    assert(i == 10);
  };

  _0();
  _2(10, 20);
  _10(10);
  _12(10, 10, 20);
};