/*
    1) Static if
    2) Polymorphic procedures
    3) Multiple return arguments
    4) Scope import by #using
 */

/* 

STATIC IF

- code analyze is done only in case the if expression is true
- lazy #load

 */

main :: fn () s32 {
    A :: true;
    #if A {
        print("This is true\n");
    } else {
        print("This is false\n");
    }
}

/*

USING 

Using on local scope variables and arguments will import used scope into current one.
This seems to be valid for structures only.

*/

Foo :: struct {
    first: s32;
    second: s32;
}

procedure :: fn () {
    using foo: Foo = {:Foo: 0};

    first = 10;
    second = 20;
}

procedure :: fn (using foo: *Foo) {
    first = 10;
    second = 20;
}




/*

   Multiple return values.

*/

foo :: fn () bool, s32 {
    return true, 10;
}

i: s32 = 10;
i, j: s32 = 20, 10;
i, j := foo(); // bool, s32

foo :: fn () struct { bool, s32 } {
    return {:: true, 10};
}



/* Explicit overloading */

_add_f32 :: fn (a: f32, b: f32) {}
_add_f64 :: fn (a: f64, b: f64) {}

add :: group {
    _add_f32;
    _add_f64;
};




