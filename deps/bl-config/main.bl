#import "std/debug_allocator"
#import "std/arg_parser"
#import "std/fs"

Args :: struct #base ArgParser.Ctx {
    auto_config: bool;
}

Ctx :: struct {
    pwd: string;
    make_backup: bool;
    opt_filepath: string;
    blc_exec: string;
    blc_version: string;
    lib_dir: string;
    linker_executable: string;
    linker_opt_exec: string;
    linker_opt_shared: string;
    linker_lib_path: string;
}

HELP_TEXT ::
"Platform specific BL configuration generator.\n"
"Usage:\n"
"  bl-config [options]"
;

main :: fn () s32 {
    //DebugAllocator.init();
    //defer DebugAllocator.terminate();
    
    _context.print_log_fn = &custom_logger;

    parser :: ArgParser.new(HELP_TEXT);
    defer ArgParser.delete(parser);

    ArgParser.add(
        parser, 
        "", 
        "--auto",
        "Generate default configuration file.", // Help text.
        &fn (_: ArgParser.Parser, _: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.auto_config = true;
            return 1, ok(); 
        });

    args: Args;
    defer ArgParser.ctx_terminate(&args);
    state :: ArgParser.run(parser, command_line_arguments, &args, 1);
    if !is_ok(state) {
        print_err("%", state);
        ArgParser.print_help(parser);
        return 1;
    }

    print_log("%\nWelcome to BL Configuration Tool.\n%", SEPARATOR, SEPARATOR);
    defer print("\nDONE\n");

    ctx: Ctx;
    ctx.linker_opt_exec = String.new();
    ctx.linker_opt_shared = String.new();
    ctx.linker_lib_path = String.new();
    defer ctx_terminate(&ctx);

    set_pwd(&ctx);

    blc_error :: lookup_compiler(&ctx);
    if !is_ok(blc_error) {
        print_err(blc_error);
        return 1;
    }

    lib_error :: lookup_lib_dir(&ctx);
    if !is_ok(lib_error) {
        print_err(lib_error);
        return 1;
    }

    if (!args.auto_config) && (!add_to_PATH(&ctx)) { return 0; }

    if init_environments(&ctx, args.auto_config) {
        err :: write_config(&ctx, args.auto_config);
        if !is_ok(err) {
            print_err(err);
            return 1;
        }
    }
    return 0;
}

choose :: fn (question: string, options: []string) s64 {
    print("%\n%\n", question, SEPARATOR2);
    loop i := 0; i < options.len; i += 1 {
        print("  [%] %\n", i+1, options[i]);
    }
    print("%\n", SEPARATOR2);
    loop {
        print("Select option [1-%] and hit ENTER: ", options.len);
        buf: [128]u8 #noinit;
        cstr := c_fgets(auto buf.ptr, auto buf.len, auto os_stdin());
        str :: cstr_to_str(cstr);
        index := String.to_s64(str) - 1; 
        if index < 0 || index >= options.len {
            print_err("Invalid option!");
            continue;
        }
        return index;
    }
}

pipe_execute :: fn (cmd: string) (string, Error) {
    mode :: "r";
    file :: c_popen(auto cmd.ptr, auto mode.ptr); 
    defer c_pclose(file);
    str := String.new();
    if !file { return str, error("Execution of command '%' failed!", cmd); }
    buf: [128]u8 #noinit;
    loop c_fgets(buf.ptr, auto buf.len, file) {
        tmp :: {:string: auto c_strlen(auto buf.ptr), buf.ptr};
        String.append(&str, tmp);
    }
    if (!String.is_empty(str)) && (str[str.len-1] == '\n') {
        str[str.len-1] = '\0';
        str.len -= 1;
    }
    return str, ok();   
}

#private
LIB_DIR :: "../lib/bl/api";
SEPARATOR  :: "================================================================================";
SEPARATOR2 :: "--------------------------------------------------------------------------------";

TEMPLATE ::
    "# Automatically generated configuration file used by 'blc' compiler.\n"                       
    "# To generate new one use 'blc --configure' command or use 'bl-config' tool.\n\n"                                     
    "# Compiler version, this should match the executable version 'blc --version'.\n"              
    "version: \"%\"\n\n"                                                                          
    "# Main API directory containing all modules and source files. This option is mandatory.\n"    
    "lib_dir: \"%\"\n"                                                                            
    "\n"                                                                                           
    "# Default configuration environment. This section is mandatory.\n"                            
    "default:\n"                                                                                   
    "    # Optional path to the linker executable, 'lld' linker is used by default on some "       
    "platforms.\n"                                                                                 
    "    linker_executable: \"%\"\n"                                                              
    "    # Linker flags and options used to produce executable binaries.\n"                        
    "    linker_opt_exec: \"%\"\n"                                                                
    "    # Linker flags and options used to produce shared libraries.\n"                           
    "    linker_opt_shared: \"%\"\n"                                                              
    "    # File system location where linker should lookup for dependencies.\n"                    
    "    linker_lib_path: \"%\"\n\n"
;

custom_logger :: fn (kind: PrintLogKind, _: string, _: s32, format: string, args: ...) {
    switch kind {
        PrintLogKind.Message;
        PrintLogKind.Warning { print("warning: "); }
        default { print("error: "); }                        
    }
    print(format, args);
    print("\n");
}

ctx_terminate :: fn (ctx: *Ctx) {
    String.delete(ctx.pwd);
    String.delete(ctx.opt_filepath);
    String.delete(ctx.blc_exec);
    String.delete(ctx.blc_version);
    String.delete(ctx.lib_dir);
    String.delete(ctx.linker_opt_exec);
    String.delete(ctx.linker_opt_shared);
    String.delete(ctx.linker_lib_path);
}

set_pwd :: fn (ctx: *Ctx) {
    exec_path :: os_get_exec_path();
    dir: string;
    if String.split_by_last(exec_path, '/', &dir, null) {
        ctx.pwd = sprint(dir);
        String.delete(exec_path);
    } else {
        ctx.pwd = exec_path;
    }
}

lookup_compiler :: fn (ctx: *Ctx) Error {
    print_log("Lookup BL compiler executable...");
    ctx.blc_exec = sprint("%/%", ctx.pwd, BLC_EXEC);
    if !Fs.exist(ctx.blc_exec) {
        return error(
            "Cannot find compiler executable. The 'bl-config' executable must be located next "
            "to the 'blc' compiler in the 'bin' directory."
        );
    }
    print_log("Found: %", ctx.blc_exec);
    print_log("Checking the compiler version...");
    cmd :: sprint("\"%\" --version", ctx.blc_exec);
    defer String.delete(cmd);
    version, exec_error :: pipe_execute(cmd);
    if !is_ok(exec_error) {
        defer String.delete(version);
        return exec_error;
    }
    ctx.blc_version = version;
    print_log("Version of the compiler: %", ctx.blc_version);
    return ok();
}

lookup_lib_dir :: fn (ctx: *Ctx) Error {
    print_log("Lookup API directory...");
    lib_dir := sprint("%/%", ctx.pwd, LIB_DIR);
    e :: Fs.normalize(&lib_dir);
    if !is_ok(e) {
        String.delete(lib_dir);
        return e;
    }
    ctx.lib_dir = lib_dir;
    print_log("Found: %", ctx.lib_dir);
    return ok();
}

write_config :: fn (ctx: *Ctx, auto_config: bool) Error {
    // Write results.
    ctx.opt_filepath = sprint("%/../%", ctx.pwd, DEFAULT_CONFIG_FILE);
    file_err :: Fs.normalize(&ctx.opt_filepath);
    if is_ok(file_err) && (!auto_config) {
        print_warn("Configuration file already exist at '%'.", ctx.opt_filepath);
        options :: {:[3]string: "Backup", "Override", "Quit"};
        opt :: choose("What to do:", options);
        switch opt {
            0 {
                bak :: sprint("%.bak", ctx.opt_filepath);
                defer String.delete(bak);
                Fs.copy(ctx.opt_filepath, bak, true);
                print_log("Configuration backup written to '%'.", bak);
            }
            1; // Do nothing
            2 { return ok(); }
            default { assert(false); }
        }
    } else {
        dir :: Fs.get_directory(ctx.opt_filepath);
        defer String.delete(dir);
        Fs.dir_create(dir);
    }

    file, err :: Fs.open(ctx.opt_filepath, Fs.OpenMode.Create, Fs.OpenMode.Write);
    defer Fs.close(file);
    if !is_ok(err) { return err; }
    Fs.write_fmt(2048, file, TEMPLATE,
                    ctx.blc_version,
                    ctx.lib_dir,
                    ctx.linker_executable,
                    ctx.linker_opt_exec,
                    ctx.linker_opt_shared,
                    ctx.linker_lib_path
                );
    print_log("Configuration written to '%'.", ctx.opt_filepath);
    return ok();
}

add_to_PATH :: fn (ctx: *Ctx) bool {
    rootdir :: Fs.get_directory(ctx.blc_exec);
    defer String.delete(rootdir);
    if is_in_PATH(rootdir) { return true; }
    options :: {:[3]string: "Yes", "No", "Quit"};
    question :: sprint("Add '%' to system PATH?", rootdir);
    defer String.delete(question);
    opt :: choose(question, options);
    switch opt {
        0 { append_PATH(rootdir); }
        1; // Do nothing
        2 { return false; }
        default { assert(false); }
    }
    return true;
}