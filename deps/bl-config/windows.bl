BLC_EXEC :: "blc.exe";

init_environments :: fn (ctx: *Ctx, auto_config: bool) bool {
    // Lookup program files
    _program_files_path = env_get("ProgramFiles(x86)");
    defer String.delete(_program_files_path);
    String.replace_all(&_program_files_path, '\\', '/');

    state: Error;
    if auto_config {
        state = build_tools(ctx);
        if is_ok(state) { return true; }

        state = visual_studio(ctx);
        if is_ok(state) { return true; }

        print_err("No suitable toolset found. Exiting with error: %", state);
        return false;
    }

    options :: {:[4]string: 
        "MSVC Build Tools (Requires Windows SDK and MS Build Tools installed)",
        "MSVC Visual Studio (Requires Windows SDK and Visual Studio with C/C++ support installed)",
        "Custom (Generate empty configuration template file)",
        "Quit"
    };

    result := true;
    loop result {
        opt :: choose("Please select the toolset:", options);
        switch opt {
            0 { state = build_tools(ctx);   } 
            1 { state = visual_studio(ctx); }
            2 {
                print_log("Custom configuration file must be fixed by hand.");
                state = ok();
            }
            3 {
                result = false;
                state = ok();
            }
            default { assert(false); }
        }
        if is_ok(state) { break; }
    }
    if !is_ok(state) { print_err(state); }
    return result;
}

is_in_PATH :: fn (path: string) bool {
    dup := String.new(path);
    defer String.delete(dup);
    String.replace_all(&dup, '/', '\\');
    p := env_get("PATH");
    defer String.delete(p);
    tmp := p;
    sub: string;
    loop String.split_by_first(tmp, ';', &sub, &tmp) {
        if String.compare(dup, sub) { return true; }
    }
    return String.compare(dup, tmp);
}

append_PATH :: fn (path: string) {
    CMD :: "pwsh -Command "
        "\"[Environment]::SetEnvironmentVariable(\\\"Path\\\",[Environment]::GetEnvironmentVariable(\\\"Path\\\", \\\"User\\\") + \\\";%\\\",\\\"User\\\")\"";
    
    String.replace_all(&path, '/', '\\');
    cmd :: sprint(CMD, path);
    defer String.delete(cmd);
    os_execute(cmd);
    print_warn("User level PATH was updated, after you're done, restart your terminal emulator."); 
}

#private
_program_files_path: string;

// =================================================================================================
// MSVC
// =================================================================================================
BUILD_TOOLS :: "Microsoft Visual Studio/2019/BuildTools";
MSVC_TOOLS :: "VC/Tools/MSVC";
WIN_SDK :: "Windows Kits/10/Lib";
UCRT :: "ucrt/x64";
UM :: "um/x64";
LINKER_OPT_EXEC :: 
    "/NOLOGO /ENTRY:__os_start /SUBSYSTEM:CONSOLE /INCREMENTAL:NO /MACHINE:x64 "
    "kernel32.lib user32.lib gdi32.lib shell32.lib ucrt.lib legacy_stdio_definitions.lib msvcrt.lib vcruntime.lib Shlwapi.lib";

LINKER_OPT_SHARED :: 
    "/NOLOGO /INCREMENTAL:NO /MACHINE:x64 /DLL "
    "kernel32.lib user32.lib gdi32.lib shell32.lib ucrt.lib legacy_stdio_definitions.lib msvcrt.lib vcruntime.lib Shlwapi.lib";

build_tools :: fn (ctx: *Ctx) Error {
    build_tools_path := sprint("%/%", _program_files_path, BUILD_TOOLS);
    defer String.delete(build_tools_path);

    if !Fs.exist(build_tools_path) {
        return error(
            "MS Build Tools not found on path '%'. You can download it from https://visualstudio.microsoft.com/visual-cpp-build-tools.",
            build_tools_path
        );
    }
    print_log("Using MS Build Tools at: '%'.", build_tools_path);

    msvc_err :: msvc(ctx, build_tools_path);
    if !is_ok(msvc_err) { return msvc_err; }

    return ok();
}

visual_studio :: fn (ctx: *Ctx) Error {
    cmd :: sprint("vswhere.exe -latest -nologo -property installationPath");
    defer String.delete(cmd);
    vs_path, vs_err :: pipe_execute(cmd);
    defer String.delete(vs_path);
    if !is_ok(vs_err) { return error("No suitable Visual Studio installation found!"); }
    String.replace_all(&vs_path, '\\', '/');
    print_log("Using Visual Studio Tools at: '%'.", vs_path);

    return msvc(ctx, vs_path);
}

msvc :: fn (ctx: *Ctx, build_tools_path: string) Error {
    msvc_linker_lib_path := sprint("%/%", build_tools_path, MSVC_TOOLS);
    defer String.delete(msvc_linker_lib_path);
    path_err :: Fs.normalize(&msvc_linker_lib_path);
    if !is_ok(path_err) { return error("Cannot find MSVC lib tools at '%'", msvc_linker_lib_path); }
    list, scan_err :: Fs.dir_scan(msvc_linker_lib_path);
    defer Fs.info_list_delete(list);
    if !is_ok(scan_err) { return(scan_err); }
    if list.len == 0 { return error("Cannot find MSVC lib tools at '%'", msvc_linker_lib_path); }
    
    best_version :: fn (name: string, best: []s32) bool {
        str: string;
        v: [3]s32;
        if String.split_by_first(name, '.', &str, &name) { v[0] = auto String.to_s64(str); }
        if String.split_by_first(name, '.', &str, &name) { v[1] = auto String.to_s64(str); }
        if String.split_by_first(name, '.', &str, &name) { v[2] = auto String.to_s64(str); }

        if v[0] < best[0] {
            return false;
        } else if v[0] == best[0] {
            if v[1] < best[1] {
                return false;
            } else if v[1] == best[1] {
                return v[2] < best[2];
            }
        }
        memcpy(auto best.ptr, auto v.ptr, sizeof(v));
        return true;
    };

    chosen := list[0].name;
    version: [3]s32;
    loop i := 0; i < list.len; i += 1 {
        item :: &list[i];
        name := item.name;
        if best_version(name, version) { chosen = name; }
    }
    String.concatenate(&msvc_linker_lib_path, "/", chosen, "/lib/x64");
    path_err2 :: Fs.normalize(&msvc_linker_lib_path);
    if !is_ok(path_err2) {
        return error("Cannot find MSVC x64 libs path '%'", msvc_linker_lib_path);
    }
    
    String.concatenate(&ctx.linker_lib_path, msvc_linker_lib_path, ";");
    winsdk_path, sdk_err :: winsdk();
    defer String.delete(winsdk_path);
    if !is_ok(sdk_err) { return sdk_err; }

    // Lookup ucrt lib path
    ucrt_path := sprint("%/%", winsdk_path, UCRT);
    defer String.delete(ucrt_path);
    ucrt_err :: Fs.normalize(&ucrt_path);
    if !is_ok(ucrt_err) {
        return error("Cannot find ucrt lib path '%'", ucrt_path);
    }
    String.concatenate(&ctx.linker_lib_path, ucrt_path, ";");
    
    // Lookup ucrt lib path
    um_path := sprint("%/%", winsdk_path, UM);
    defer String.delete(um_path);
    um_err :: Fs.normalize(&um_path);
    if !is_ok(um_err) {
        return error("Cannot find um lib path '%'", um_path);
    }
    String.concatenate(&ctx.linker_lib_path, um_path, ";");
    String.concatenate(&ctx.linker_opt_exec, LINKER_OPT_EXEC);
    String.concatenate(&ctx.linker_opt_shared, LINKER_OPT_SHARED);
    
    return ok();
}

winsdk :: fn () (string, Error) {
    winsdk_path := sprint("%/%", _program_files_path, WIN_SDK);
    path_err :: Fs.normalize(&winsdk_path);
    if !is_ok(path_err) { return winsdk_path, error("Cannot find windows SDK at '%'", winsdk_path); }
    list, scan_err :: Fs.dir_scan(winsdk_path);
    defer Fs.info_list_delete(list);
    if !is_ok(scan_err) { return winsdk_path, scan_err; }
    if list.len == 0 { return winsdk_path, error("Cannot find windows SDK at '%'", winsdk_path); }

    best_version :: fn (name: string, best: []s32) bool {
        str: string;
        v: [4]s32;
        if String.split_by_first(name, '.', &str, &name) { v[0] = auto String.to_s64(str); }
        if String.split_by_first(name, '.', &str, &name) { v[1] = auto String.to_s64(str); }
        if String.split_by_first(name, '.', &str, &name) { v[2] = auto String.to_s64(str); }
        if String.split_by_first(name, '.', &str, &name) { v[3] = auto String.to_s64(str); }

        if v[0] < best[0] {
            return false;
        } else if v[0] == best[0] {
            if v[1] < best[1] {
                return false;
            } else if v[1] == best[1] {
                if v[2] < best[2] {
                    return false;
                } else if v[2] == best[2] {
                    return v[3] < best[3];
                }
            }
        }
        memcpy(auto best.ptr, auto v.ptr, sizeof(v));
        return true;
    };

    chosen := list[0].name;
    version: [4]s32;
    loop i := 0; i < list.len; i += 1 {
        item :: &list[i];
        name := item.name;
        if best_version(name, version) { chosen = name; }
    }

    String.concatenate(&winsdk_path, "/", chosen);
    print_log("Using Windows SDK at: '%'.", winsdk_path);
    return winsdk_path, ok();
}