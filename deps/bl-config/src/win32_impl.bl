#load "std/utils.bl"

BUILD_TOOLS :: "Microsoft Visual Studio/2019/BuildTools";
MSVC_TOOLS :: "VC/Tools/MSVC";
WIN_SDK :: "Windows Kits/10/Lib";
UCRT :: "ucrt/x64";
UM :: "um/x64";
LINKER_OPT_EXEC :: 
    "/NOLOGO /ENTRY:__os_start /SUBSYSTEM:CONSOLE /INCREMENTAL:NO /MACHINE:x64 "
    "kernel32.lib user32.lib gdi32.lib shell32.lib ucrt.lib legacy_stdio_definitions.lib msvcrt.lib vcruntime.lib Shlwapi.lib";

LINKER_OPT_SHARED :: 
    "/NOLOGO /INCREMENTAL:NO /MACHINE:x64 /DLL "
    "kernel32.lib user32.lib gdi32.lib shell32.lib ucrt.lib legacy_stdio_definitions.lib msvcrt.lib vcruntime.lib Shlwapi.lib";

CONFIG :: 
    "// BL configuration file\n"
    "// This file is generated by bl-config tool and used by 'blc' compiler during compilation\n"
    "// process.\n\n"
    "VERSION \"%\"\n"
    "// Main API directory containing all modules and source files.\n"
    "LIB_DIR \"%\"\n"
    "// Default linker options used for executable linking.\n"
    "LINKER_OPT_EXEC \"%\"\n"
    "// Default linker options used for shared library linking.\n"
    "LINKER_OPT_SHARED \"%\"\n"
    "// Additional linker library path.\n"
    "LINKER_LIB_PATH \"%;%;%;\"\n"
    ;

popen :: fn (f: *c_char, m: *c_char) c_void_ptr #extern "_popen";
pclose :: fn (f: c_void_ptr) #extern "_pclose";

ArgsImpl :: struct #base ArgParser.Ctx {
    build_tools_path: string;
}
    
setup :: fn (parser: ArgParser.Parser) {
     ArgParser.add(
        parser,
        "-b",
        "--build-tools-path",
        "Specify custom MS Build Tools directory.",
        &fn (_: ArgParser.Parser, args: []string, ctx: *ArgParser.Ctx) (s32, Error) {
            a := cast(*Args) ctx;
            if (args.len < 2) {
                return 0, error("Expected directory name!");
            }
            path := args[1];
            String.replace_all(&path, '\\', '/');
            if (!String.is_empty(path)) && path[path.len-1] == '\"' {
                path[path.len-1] = '\0';
                path.len -= 1;
            }
            a.build_tools_path = path;
            is_valid_directory :: Fs.is_directory(a.build_tools_path);
            if !is_valid_directory {  
                return 0, error("Invalid directory path '%'!", a.build_tools_path);
            }
            return 2, ok();
        });
}

configure :: fn () Error {
    print_log("Generate configuration file");
    program_files_path :: env_get("ProgramFiles(x86)");
    String.replace_all(&program_files_path, '\\', '/'); // oh my!
    build_tools_path: string;
    lib_dir: string; 
    linker_exec: string;
    win_sdk_path: string;
    ucrt_path: string;
    um_path: string;
    msvc_lib_path: string;
    defer String.delete(build_tools_path);
    defer String.delete(linker_exec);
    defer String.delete(lib_dir);
    defer String.delete(program_files_path);
    defer String.delete(win_sdk_path);
    defer String.delete(ucrt_path);
    defer String.delete(um_path);
    defer String.delete(msvc_lib_path);
        
    // Ugly windows bullshit!
    
    // Lookup build tools instalation.
    if String.is_empty(g_args.build_tools_path) {
        build_tools_path = sprint("%/%", program_files_path, BUILD_TOOLS);
    } else {
        build_tools_path = String.new(g_args.build_tools_path);
    }
    if !Fs.exist(build_tools_path) {
        return error(
            "Cannot find MS Build Tools installation on '%'. "
            "Download & install MS Build Tools from https://visualstudio.microsoft.com/visual-cpp-build-tools "
            "or specify custom location, see 'bl-config.exe -h' for more information", 
            build_tools_path);
    }
    print_log("MS Build Tools instalation on '%'.", build_tools_path);

    // Lookup Windows SDK
    win_sdk_path = sprint("%/%", program_files_path, WIN_SDK);
    {
        err :: Fs.normalize(&win_sdk_path);
        if !is_ok(err) { return error("Cannot find windows SDK on '%'", win_sdk_path); }
        list, err2 :: Fs.dir_scan(win_sdk_path);
        defer Fs.info_list_delete(list);
        if !is_ok(err2) { panic(err); }
        if list.len == 0 { return error("Cannot find windows SDK on '%'", win_sdk_path); }

        best_version :: fn (name: string, best: []s32) bool {
            v: string;
            v1, v2, v3, v4: s32;
            if String.split_by_first(name, '.', &v, &name) { v1 = auto String.to_s64(v); }
            if String.split_by_first(name, '.', &v, &name) { v2 = auto String.to_s64(v); }
            if String.split_by_first(name, '.', &v, &name) { v3 = auto String.to_s64(v); }
            if String.split_by_first(name, '.', &v, &name) { v4 = auto String.to_s64(v); }

            if v1 < best[0] {
                return false;
            } else if v1 == best[0] {
                if v2 < best[1] {
                    return false;
                } else if v2 == best[1] {
                    if v3 < best[2] {
                        return false;
                    } else if v3 == best[2] {
                        return v4 < best[3];
                    }
                }
            }
            best[0] = v1;
            best[1] = v2;
            best[2] = v3;
            best[3] = v4;
            return true;
        };

        chosen := list[0].name;
        version: [4]s32;
        loop i := 0; i < list.len; i += 1 {
            item :: &list[i];
            name := item.name;
            if best_version(name, version) { chosen = name; }
        }

        String.concatenate(&win_sdk_path, "/", chosen);
    }
    
    // Lookup ucrt lib path
    ucrt_path = sprint("%/%", win_sdk_path, UCRT);
    {
        err :: Fs.normalize(&ucrt_path);
        if !is_ok(err) {
            return error("Cannot find ucrt lib path '%'", ucrt_path);
        }
    }
    
    // Lookup ucrt lib path
    um_path = sprint("%/%", win_sdk_path, UM);
    {
        err :: Fs.normalize(&um_path);
        if !is_ok(err) {
            return error("Cannot find um lib path '%'", um_path);
        }
    }

    // Lookup MSVC lib tools
    msvc_lib_path = sprint("%/%", build_tools_path, MSVC_TOOLS);
    {
        err :: Fs.normalize(&msvc_lib_path);
        if !is_ok(err) { return error("Cannot find MSVC lib tools on '%'", msvc_lib_path); }
        list, err2 :: Fs.dir_scan(msvc_lib_path);
        defer Fs.info_list_delete(list);
        if !is_ok(err2) { panic(err); }
        if list.len == 0 { return error("Cannot find MSVC lib tools on '%'", msvc_lib_path); }
        
        best_version :: fn (name: string, best: []s32) bool {
            v: string;
            v1, v2, v3: s32;
            if String.split_by_first(name, '.', &v, &name) { v1 = auto String.to_s64(v); }
            if String.split_by_first(name, '.', &v, &name) { v2 = auto String.to_s64(v); }
            if String.split_by_first(name, '.', &v, &name) { v3 = auto String.to_s64(v); }

            if v1 < best[0] {
                return false;
            } else if v1 == best[0] {
                if v2 < best[1] {
                    return false;
                } else if v2 == best[1] {
                    return v3 < best[2];
                }
            }
            best[0] = v1;
            best[1] = v2;
            best[2] = v3;
            return true;
        };

        chosen := list[0].name;
        version: [4]s32;
        loop i := 0; i < list.len; i += 1 {
            item :: &list[i];
            name := item.name;
            if best_version(name, version) { chosen = name; }
        }

        String.concatenate(&msvc_lib_path, "/", chosen);
    }
    
    // Lookup MSVC x64 libs
    String.concatenate(&msvc_lib_path, "/lib/x64");
    {
        err :: Fs.normalize(&msvc_lib_path);
        if !is_ok(err) {
            return error("Cannot find MSVC x64 libs path '%'", msvc_lib_path);
        }
    }
    
    // Lookup BL lib directory
    lib_dir = sprint("%/%", g_pwd, LIB_DIR);
    {
        err :: Fs.normalize(&lib_dir);
        if !is_ok(err) {
            return error("Cannot find BL API libs on '%'", lib_dir);
        }
    }
    print_log("Found BL API on '%'.", lib_dir);
    
    return write_config(
        CONFIG, 
        VERSION,
        lib_dir,
        LINKER_OPT_EXEC,
        LINKER_OPT_SHARED,
        ucrt_path, um_path, msvc_lib_path
    );
}
