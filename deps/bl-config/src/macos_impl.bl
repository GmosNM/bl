#load "std/utils.bl"

LINKER_EXEC::"usr/bin/ld";
LINKER_OPT_EXEC :: "-e ___os_start -lc -lm";
LINKER_OPT_SHARED :: "-dylib -lc -lm";
LINKER_LIB_PATH :: "/usr/lib:/usr/local/lib";
COMMAND_LINE_TOOLS :: "/Library/Developer/CommandLineTools";
MACOS_SDK :: "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib";

CONFIG :: 
    "// BL configuration file\n"
    "// This file is generated by bl-config tool and used by 'blc' compiler during compilation\n"
    "// process.\n\n"
    "VERSION \"%\"\n"
    "// Linker executable (This is optional compiler will use internal LLD when not defined or empty).\n"
    "LINKER_EXECUTABLE \"%\"\n"
    "// Main API directory containing all modules and source files.\n"
    "LIB_DIR \"%\"\n"
    "// Default linker options used for executable linking.\n"
    "LINKER_OPT_EXEC \"%\"\n"
    "// Default linker options used for shared library linking.\n"
    "LINKER_OPT_SHARED \"%\"\n"
    "// Additional linker library path.\n"
    "LINKER_LIB_PATH \"%\"\n"
    ;

popen :: fn (f: *c_char, m: *c_char) c_void_ptr #extern "popen";
pclose :: fn (f: c_void_ptr) #extern "pclose";

ArgsImpl :: struct #base arg_parser.Ctx {
    use_lld: bool;
}
    
setup :: fn (parser: arg_parser.Parser) {
    arg_parser.add(
        parser,
        "",
        "--use-lld",
        "Use internal LLD linker (this is experimental).",
        &fn (parser: arg_parser.Parser, args: []string, ctx: *arg_parser.Ctx) (s32, Error) {
            a: *Args = auto ctx;
            a.use_lld = true;
            return 1, ok();
        });
}

configure :: fn () Error {
    print_log("Generate configuration file");
    os_ver :: pipe_execute("sw_vers -productVersion");
    lib_dir: string; 
    linker_opt_exec: string;
    linker_opt_shared: string;
    linker_lib_path: string;
    linker_executable: string;
    defer strings.delete(linker_executable);
    defer strings.delete(linker_lib_path);
    defer strings.delete(os_ver);
    defer strings.delete(linker_opt_exec);    
    defer strings.delete(linker_opt_shared);    
    defer strings.delete(lib_dir);
    
    lib_dir = sprint(g_pwd, "/", LIB_DIR);
    {
       err :: fs.normalize(&lib_dir);
       if !is_ok(err) {
           return error("Cannot find BL API libs on '%'", lib_dir);
       }
    }
    print_log("Found BL API on '%'.", lib_dir);
    
    if !fs.exist(COMMAND_LINE_TOOLS) {
        return error("Cannot find Command Line Tools on '%', use 'xcode-select --install'.", COMMAND_LINE_TOOLS);
    }
    print_log("Found Command Line Tools on '%'.", COMMAND_LINE_TOOLS);

    if !g_args.use_lld {
        linker_executable = sprint(COMMAND_LINE_TOOLS, "/", LINKER_EXEC);
        if !fs.exist(linker_executable) {
            return error("Cannot find linker on '%'.", linker_executable);
        }
        print_log("Found linker on '%'.", linker_executable);
    }

    linker_lib_path = sprint(LINKER_LIB_PATH);

    print_log("Setup for MacOS version '%'.", os_ver);
    if get_os_ver_major(os_ver) >= 11 {
        if !fs.exist(MACOS_SDK) {
            return error("Cannot find MacOS SDK on '%'.", MACOS_SDK);
        }
        print_log("Found MacOS SDK on '%'.", MACOS_SDK);
        strings.append(&linker_lib_path, ":");
        strings.append(&linker_lib_path, MACOS_SDK);
    }
    
    linker_opt_exec = sprint("-macosx_version_min ", os_ver, " -sdk_version ", os_ver, " ", LINKER_OPT_EXEC);
    linker_opt_shared = sprint("-macosx_version_min ", os_ver, " -sdk_version ", os_ver, " ", LINKER_OPT_SHARED);

    return write_config(
        CONFIG, 
        VERSION,
        linker_executable,
        lib_dir,
        linker_opt_exec,
        linker_opt_shared,
        linker_lib_path,
    );
}

#private
get_os_ver_major :: fn (ver: string) s32 {
    lhs: string;
    if strings.split_by_first(ver, '.', &lhs, null) {
        return auto strings.to_s64(lhs);
    }
    return 0;
}
